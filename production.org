#+TITLE: The kcats Programming Language (Production Implementation)
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Production implementation
** Base Language
We will use Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
** Status
Experimental, currently learning a new language.
** Using
*** Dependencies
- rustc
- cargo
*** Build
Run =cargo build=, the binary will be placed in =./target/debug= by
default.
*** Run
Execute the binary: =./target/debug/kcats=. It will read a program
from stdin and execute it, then print the resulting stack.

** Project File
#+begin_src toml :tangle Cargo.toml
[package]
name = "kcats"
version = "0.1.1"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#rug = "1.15.0"
edn-format = "3.2.3"
base64 = "0.13.0"
internment = "0.6.0" 
lazy_static = "1.4.0"
num-integer = "0.1.44"
dyn-clone = "1.0.5"

[dev-dependencies]
test-case = "2.0.0"
#+end_src
** Code
Let's start by defining some data structures in a separate module
#+begin_src rust :tangle src/types.rs
use crate::pipes::{In, Out, Tunnel};
use internment::Intern;
use lazy_static::lazy_static;
use std::collections::{HashMap, VecDeque};
use std::fmt;
use std::hash::Hash;
use std::rc::Rc;
//use std::convert::From as _;
//use std::array::IntoIter;

//extern crate thiserror;

pub type Word = Intern<String>;

pub type ListContent = VecDeque<Item>;

pub type List = Rc<ListContent>;

pub type KeyList = VecDeque<KeyItem>;

pub type Stack = List;

pub type Bytes = Vec<u8>;

pub type Int = i64;

pub type Float = f64;

pub type AssociationContent = HashMap<KeyItem, Item>;

pub type Association = Rc<AssociationContent>;

#[derive(Clone, PartialEq)]
struct Extensible<Core> {
    pub core: Core,
    pub extra: Option<AssociationContent>,
}

pub trait Associative {
    fn get(&self, k: KeyItem) -> Option<&Item>;
    fn insert(&mut self, k: KeyItem, val: Item) -> Option<Item>;
    fn remove(&mut self, k: KeyItem) -> Option<Item>;
}

impl Associative for AssociationContent {
    fn get(&self, k: KeyItem) -> Option<&Item> {
        return self.get(&k);
    }

    fn insert(&mut self, k: KeyItem, val: Item) -> Option<Item> {
        return self.insert(k, val);
    }

    fn remove(&mut self, k: KeyItem) -> Option<Item> {
        return self.remove(&k);
    }
}

#[derive(Clone, PartialEq)]
pub struct ErrorCore {
    pub asked: List,
    pub unwound: Option<List>,
    pub reason: Option<String>,
    pub is_handled: bool,
}

pub type Error = Extensible<ErrorCore>;

pub trait From<T>: Sized {
    fn from(_: T) -> Self;
}

impl Associative for Error {
    fn get(&self, k: KeyItem) -> Option<&Item> {
        match k {
            KeyItem::Word(w) => match w.as_str() {
                "asked" => return Some(&Item::List(self.core.asked)),
                "unwound" => {
                    return self
                        .core
                        .unwound
                        .and_then(|uw| Some(Item::List(uw)))
                        .as_ref()
                }
                "reason" => {
                    return self
                        .core
                        .reason
                        .and_then(|r| Some(Item::String(r)))
                        .as_ref()
                }
                "handled?" => return Some(&From::from(self.core.is_handled)),
            },
            _ => return self.extra.and_then(|xtra| xtra.get(&k)),
        }
    }

    fn insert(&mut self, k: KeyItem, val: Item) -> Option<Item> {
        return self.insert(k, val);
    }

    fn remove(&mut self, k: KeyItem) -> Option<Item> {
        return self.remove(k);
    }
}

// impl IntoIterator for Error {
//     type Item = (KeyItem, Item);
//     type IntoIter = std::array::IntoIter<Self::Item, 1>;
//     fn into_iter(self) -> Self::IntoIter {
//         let i = self.extra.unwrap();
//         let j = [
//             (word_key("asked"), Item::List(self.core.asked)),
//             (word_key("unw"), Item::List(self.core.asked)),
//         ]
//         .into_iter();
//         return j.chain(i);
//     }
// }

lazy_static! {
    pub static ref S_ASSOC: Intern<String> = Intern::new("association".to_string());
    pub static ref S_BOOLEAN: Intern<String> = Intern::new("boolean".to_string());
    pub static ref S_BYTES: Intern<String> = Intern::new("bytes".to_string());
    pub static ref S_ENVIRONMENT: Intern<String> = Intern::new("environment".to_string());
    pub static ref S_ERROR: Intern<String> = Intern::new("error".to_string());
    pub static ref S_FLOAT: Intern<String> = Intern::new("float".to_string());
    pub static ref S_INTEGER: Intern<String> = Intern::new("integer".to_string());
    pub static ref S_ITEM: Intern<String> = Intern::new("item".to_string());
    pub static ref S_LIST: Intern<String> = Intern::new("list".to_string());
    pub static ref S_NUMBER: Intern<String> = Intern::new("number".to_string());
    pub static ref S_PIPE: Intern<String> = Intern::new("pipe".to_string());
    pub static ref S_PROGRAM: Intern<String> = Intern::new("program".to_string());
    pub static ref S_STRING: Intern<String> = Intern::new("string".to_string());
    pub static ref S_WORD: Intern<String> = Intern::new("word".to_string());
}

#[derive(Debug, Clone)]
pub enum Item {
    Int(Int),
    Float(Float),
    //Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    Assoc(Association),
    List(List),
    Env(Environment),
    AxiomDef(AxiomDef),
    DerivedDef(DerivedDef),
    Error(Error),
    In(Box<dyn In>),
    Out(Box<dyn Out>),
    Tunnel(Box<dyn Tunnel>),
    Nothing,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum KeyItem {
    Int(Int),
    //Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    List(VecDeque<KeyItem>),
    Nothing,
}

pub type Dictionary = Association;

#[derive(Clone, PartialEq)]
pub struct Environment {
    pub stack: Stack,
    pub expression: Stack,
    pub dictionary: Dictionary,
}

pub type StepFn = dyn Fn(Environment) -> Environment;

#[derive(Clone)]
pub struct AxiomDef {
    pub word: Word,
    pub examples: Option<List>,
    pub spec: Option<List>,
    // whether or not to print this as a compiled word (false) or an
    // entire dictionary entry (true)
    pub serialize: bool,
    pub f: &'static StepFn,
}

#[derive(Debug, Clone, PartialEq)]
pub struct DerivedDef {
    pub word: Word,
    pub examples: Option<List>,
    pub spec: Option<List>,
    pub serialize: bool,
    pub definition: List,
}

impl PartialEq for Item {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            // same types, just use their own eq
            (Item::Int(i), Item::Int(j)) => i == j,
            (Item::Float(i), Item::Float(j)) => i == j,
            (Item::String(i), Item::String(j)) => i == j,
            (Item::Bytes(i), Item::Bytes(j)) => i == j,
            (Item::Word(i), Item::Word(j)) => i == j,
            (Item::Assoc(i), Item::Assoc(j)) => i == j,
            (Item::Env(i), Item::Env(j)) => i == j,
            (Item::AxiomDef(i), Item::AxiomDef(j)) => i == j,
            (Item::DerivedDef(i), Item::DerivedDef(j)) => i == j,
            (Item::List(i), Item::List(j)) => i == j,
            (Item::Error(i), Item::Error(j)) => i == j,

            (Item::Nothing, Item::List(l)) => l.is_empty(),
            (Item::List(l), Item::Nothing) => l.is_empty(),

            (Item::Nothing, Item::Assoc(l)) => l.is_empty(),
            (Item::Assoc(l), Item::Nothing) => l.is_empty(),

            (Item::List(l), Item::Assoc(a)) => a.is_empty() && l.is_empty(),
            (Item::Assoc(a), Item::List(l)) => a.is_empty() && l.is_empty(),

            //(Item::Error(i), Item::Assoc(j)) => (*i).data == *j,
            //(Item::Assoc(i), Item::Error(j)) => (*j).data == *i,
            (Item::Word(i), Item::AxiomDef(j)) => j.word == *i,
            (Item::AxiomDef(i), Item::Word(j)) => i.word == *j,

            //TODO env to assoc
            _ => false,
        }
    }
}

// dictionary entries are equal if they have the same function reference,
// no need to compare the function values
impl PartialEq for AxiomDef {
    fn eq(&self, other: &Self) -> bool {
        self.word == other.word && self.examples == other.examples && self.spec == other.spec
    }
}

impl Eq for AxiomDef {}

impl Environment {
    pub fn push(mut self, i: Item) -> Environment {
        Rc::make_mut(&mut self.stack).push_front(i);
        self
    }

    pub fn pop(&mut self) -> Item {
        Rc::make_mut(&mut self.stack).pop_front().unwrap()
    }

    pub fn push_expr(mut self, i: Item) -> Environment {
        Rc::make_mut(&mut self.expression).push_front(i);
        self
    }

    pub fn pop_expr(&mut self) -> Item {
        Rc::make_mut(&mut self.expression).pop_front().unwrap()
    }

    pub fn append_expression(mut self, items: List) -> Environment {
        let expr = Rc::make_mut(&mut self.expression);
        let ct = expr.len();
        expr.append(Rc::make_mut(&mut items.clone()));
        expr.rotate_left(ct);
        self
    }
}

impl Error {
    pub fn create(asked: List, reason: &str, unwound: Option<List>) -> Error {
        Error {
            core: ErrorCore {
                is_handled: false,
                asked,
                reason: Some(reason.to_string()),
                unwound,
            },
            extra: None,
        }
    }

    pub fn stack_underflow() -> Error {
        Error::create(wrap(word("consume")), "not enough items on stack", None)
    }

    pub fn undefined(w: Word) -> Error {
        Error::create(wrap(Item::Word(w)), "word is not defined", None)
    }

    pub fn type_mismatch(asked: List) -> Error {
        Error::create(asked, "type mismatch", None)
    }

    pub fn expected(typestr: &str) -> Error {
        Error::type_mismatch(wrap(word(typestr)))
    }

    pub fn short_list(expected: Int) -> Error {
        Error::create(
            Rc::new(ListContent::from_iter([
                word("count"),
                Item::Int(expected),
                word(">="),
            ])),
            "list had too few items",
            None,
        )
    }

    pub fn list_count(expected: Int) -> Error {
        Error::create(
            Rc::new(ListContent::from_iter([
                word("count"),
                Item::Int(expected),
                word("="),
            ])),
            "list had wrong number of items",
            None,
        )
    }

    pub fn parse(reason: &str) -> Error {
        Error::create(wrap(word("read")), reason, None)
    }

    pub fn test_assertion(program: List, expected: List, actual: List) -> Error {
        let mut e = Error::create(program, "assertion failed", None);
        e.insert(word_key("expected"), Item::List(expected));
        e.insert(word_key("actual"), Item::List(actual));
        return e;
    }
}

pub fn wrap(i: Item) -> List {
    Rc::new(ListContent::from_iter([i]))
}

impl TryFrom<Item> for List {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        match i {
            Item::List(l) => Ok(l),
            Item::Assoc(mut a) => Ok(From::from(a)),
            Item::Error(e) => Ok(From::from(e)),
            // 'Nothing' is equivalent to an empty list
            Item::Nothing => Ok(Rc::new(ListContent::new())),
            _ => Err(Error::expected("list")),
        }
    }
}

impl TryFrom<Item> for AxiomDef {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::AxiomDef(b) = i {
            Ok(b)
        } else {
            Err(Error::expected("AxiomWord"))
        }
    }
}

impl TryFrom<Item> for Int {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Int(i) = i {
            Ok(i)
        } else {
            Err(Error::expected("integer"))
        }
    }
}

impl TryFrom<Item> for Float {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Float(f) = i {
            Ok(f)
        } else {
            Err(Error::expected("float"))
        }
    }
}

impl TryFrom<Item> for String {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::String(i) = i {
            Ok(i)
        } else {
            Err(Error::expected("string"))
        }
    }
}

impl TryFrom<Item> for Word {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Word(i) = i {
            Ok(i)
        } else {
            Err(Error::expected("word"))
        }
    }
}

impl TryFrom<Item> for Association {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        match i {
            Item::Assoc(a) => Ok(a),
            Item::List(l) => Ok(to_hash(l)?),
            Item::Nothing => Ok(Rc::new(AssociationContent::new())),
            Item::DerivedDef(d) => Ok(From::from(d)),
            Item::AxiomDef(a) => Ok(From::from(a)),
            Item::Env(e) => Ok(From::from(e)),
            Item::Error(e) => Ok(From::from(e)),
            _ => Err(Error::expected("association")),
        }
    }
}

impl TryFrom<Item> for Environment {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Env(i) = i {
            Ok(i)
        } else {
            Err(Error::expected("environment"))
        }
    }
}

impl TryFrom<Item> for Box<dyn In> {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::In(i) = i {
            Ok(i)
        } else {
            Err(Error::expected("pipe"))
        }
    }
}

impl TryFrom<Item> for Box<dyn Out> {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        match i {
            Item::Out(o) => Ok(o),
            _ => Err(Error::expected("pipe")),
        }
    }
}

impl TryFrom<Item> for Box<dyn Associative> {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        match i {
            Item::Error(e) => Ok(Box::new(e) as Box<dyn Associative>),
            // TODO env, deriveddef etc
            _ => Err(Error::expected("pipe")),
        }
    }
}
impl From<DerivedDef> for Association {
    fn from(d: DerivedDef) -> Association {
        let mut a = AssociationContent::new();
        a.insert(word_key("definition"), Item::List(d.definition.clone()));
        d.examples
            .and_then(|l| a.insert(word_key("examples"), Item::List(l.clone())));
        d.spec
            .and_then(|l| a.insert(word_key("spec"), Item::List(l.clone())));
        Rc::new(a)
    }
}

impl From<DerivedDef> for Item {
    fn from(dd: DerivedDef) -> Item {
        Item::Assoc(From::from(dd))
    }
}

impl From<AxiomDef> for Association {
    fn from(d: AxiomDef) -> Association {
        let mut a = AssociationContent::new();
        d.examples
            .and_then(|l| a.insert(word_key("examples"), Item::List(l.clone())));
        d.spec
            .and_then(|l| a.insert(word_key("spec"), Item::List(l.clone())));
        Rc::new(a)
    }
}

impl From<Association> for DerivedDef {
    fn from(mut d: Association) -> DerivedDef {
        let dmut = Rc::make_mut(&mut d);
        DerivedDef {
            word: Intern::new("".to_string()),
            serialize: true,
            definition: dmut
                .remove(&key_item("definition"))
                .and_then(|i| List::try_from(i).ok())
                .unwrap_or(Rc::new(ListContent::new())),
            examples: dmut
                .remove(&key_item("examples"))
                .and_then(|i| List::try_from(i).ok()),
            spec: dmut
                .remove(&key_item("spec"))
                .and_then(|i| List::try_from(i).ok()),
        }
    }
}

impl From<AxiomDef> for Item {
    fn from(ad: AxiomDef) -> Item {
        Item::Assoc(From::from(ad))
    }
}

// As there are no real booleans, we use the word 'true' but literally
// any value except the empty list is truthy. If we read a value
// 'false' in edn, that's not actually a boolean, it's just the
// symbol/word false.
impl From<bool> for Item {
    fn from(b: bool) -> Item {
        if b {
            word("true")
        } else {
            Item::Nothing
        }
    }
}

impl From<Environment> for Association {
    fn from(env: Environment) -> Association {
        let mut a = AssociationContent::new();
        a.insert(word_key("stack"), Item::List(env.stack.clone()));
        a.insert(word_key("expression"), Item::List(env.expression.clone()));
        a.insert(word_key("dictionary"), Item::Assoc(env.dictionary.clone()));
        Rc::new(a)
    }
}

impl From<Environment> for Item {
    fn from(env: Environment) -> Item {
        Item::Env(Environment::from(env))
    }
}

impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Error {
        Error::create(wrap(word("io")), &err.to_string(), None)
    }
}

impl From<ErrorCore> for AssociationContent {
    fn from(ec: ErrorCore) -> AssociationContent {
        let ac = AssociationContent::new();
        let b: Item = From::from(ec.is_handled);
        ac.insert(word_key("handled?"), b);
       
        if let Some(u) = ec.unwound {
            ac.insert(word_key("unwound"), Item::List(u));
        }
        if let Some(s) = ec.reason {
            ac.insert(word_key("reason"), Item::String(s));
        }
        return ac;
    }
}

impl From<AssociationContent> for ListContent {
    fn from(a: AssociationContent) -> ListContent {
        a.into_iter()
            .map(|(k, v)| {
                Item::List(Rc::new(std::convert::From::from(vec![
                    to_value_item(k.clone()),
                    std::convert::From::from(v.clone()),
                ])))
            })
            .collect::<ListContent>()
    }
}

impl From<Association> for List {
    fn from(a: Association) -> List {
        Rc::new(From::from(*a))
    }
}

// impl From<Error> for Association {
//     fn from(e: Error) -> Association {
//         let ac: AssociationContent = From::from(e.core);
//         let extra: AssociationContent = e.extra.unwrap_or_default();
//         ac.extend(extra);
//         return Rc::new(ac);
//     }
// }
impl<T: Into<AssociationContent>> From<Extensible<T>> for Association {
    fn from(e: Extensible<T>) -> Association {
        let ac: AssociationContent = e.core.into();
        let extra: AssociationContent = e.extra.unwrap_or_default();
        ac.extend(extra);
        return Rc::new(ac);
    }
}

impl fmt::Debug for AxiomDef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ds = f.debug_struct("AxiomDef");
        ds.field("word", &self.word);
        ds.finish()
    }
}

pub fn word(s: &str) -> Item {
    Item::Word(Word::from(s))
}

pub fn word_key(s: &str) -> KeyItem {
    KeyItem::Word(Word::from(s))
}

pub fn to_key_item(i: Item) -> Result<KeyItem, Error> {
    match i {
        Item::Int(i) => Ok(KeyItem::Int(i)),
        Item::String(i) => Ok(KeyItem::String(i)),
        Item::List(l) => Ok(KeyItem::List(
            l.iter()
                .map(|i| to_key_item(i.clone()))
                .collect::<Result<KeyList, Error>>()?,
        )),
        Item::Word(w) => Ok(KeyItem::Word(w)),
        Item::AxiomDef(w) => Ok(KeyItem::Word(w.word)),
        Item::Bytes(bs) => Ok(KeyItem::Bytes(bs)),
        Item::Nothing => Ok(KeyItem::Nothing),
        Item::DerivedDef(d) => Ok(KeyItem::Word(d.word)),
        _ => Err(Error::expected("KeyItem")),
    }
}

pub fn to_value_item(i: KeyItem) -> Item {
    match i {
        KeyItem::Int(i) => Item::Int(i),
        KeyItem::String(i) => Item::String(i),
        KeyItem::List(l) => Item::List(Rc::new(
            l.iter()
                .map(|i| to_value_item(i.clone()))
                .collect::<ListContent>(),
        )),
        KeyItem::Word(w) => Item::Word(w),
        KeyItem::Bytes(bs) => Item::Bytes(bs),
        KeyItem::Nothing => Item::Nothing,
    }
}

pub fn key_item(s: &str) -> KeyItem {
    to_key_item(word(s)).unwrap()
}

pub fn to_entry(i: Item) -> Result<(KeyItem, Item), Error> {
    match i {
        Item::List(mut l) => {
            if l.len() != 2 {
                Err(Error::expected("List[2]"))
            } else {
                let lm = Rc::make_mut(&mut l);
                let v = lm.pop_back();
                let k = lm.pop_back();
                let e = lm.pop_back();
                match (k, v, e) {
                    (Some(k), Some(v), None) => Ok((to_key_item(k)?, v)),
                    _ => Err(Error::expected("List[2]")),
                }
            }
        }
        _ => Err(Error::expected("list")),
    }
}

pub fn to_hash(l: List) -> Result<Association, Error> {
    Ok(Rc::new(
        l.iter()
            .map(|i| to_entry(i.clone()))
            .collect::<Result<HashMap<KeyItem, Item>, Error>>()?,
    ))
}
#+end_src

Next is the top level functions, including =main=, how to evaluate
kcats ASTs, later we'll put command line options here.

#+begin_src rust :tangle src/main.rs
mod types;
use crate::types::*;
use std::rc::Rc;
mod axiom;
mod serialize;
mod pipes;
use std::io;
use std::io::BufRead;

fn print_result(env: Environment) {
    if env.expression.is_empty() {
        println!("\n{}", serialize::emit(&Item::List(env.stack)));
    } else {
        println!(
            "\nstack: {}\nexpression: {}",
            serialize::emit(&Item::List(env.stack)),
            serialize::emit(&Item::List(env.expression))
        )
    }
}

fn get_stdin() -> String {
    let mut buf = String::new();
    for line in io::stdin().lock().lines() {
        buf.push_str(&line.unwrap());
        buf.push('\n');
    }
    buf
}

fn main() {
    let program = get_stdin();
    let mut env = axiom::standard_env(None, None);
    let parse_result = serialize::parse(program, Some(&env.dictionary));
    match parse_result {
        Ok(mut program) => {
            let expr = Rc::make_mut(&mut env.expression);
            expr.extend(Rc::make_mut(&mut program).drain(..));
            print_result(axiom::eval(env));
        }
        Err(e) => {
            println!("Error parsing input: {:?}", e);
        }
    }
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;
    use internment::Intern;
    use test_case::test_case;

    pub fn get_item(i: Item, index: usize) -> Option<Item> {
        if let Item::List(l) = i {
            match l.get(index) {
                Some(x) => Some(x.clone()),
                None => None,
            }
        } else {
            None
        }
    }

    fn test_example(
        mut prog_env: Environment,
        program: List,
        expected: List,
    ) -> Option<Error> {
        let mut exp_env = prog_env.clone();
        prog_env = prog_env.append_expression(program.clone());
        exp_env = exp_env.append_expression(expected.clone());

        //let res = eval(env).ok()?;
        prog_env = axiom::eval(prog_env);
        exp_env = axiom::eval(exp_env);
        println!("Testing {:?} {:?}", prog_env.stack, exp_env.stack);
        if prog_env.stack == exp_env.stack {
            None
        } else {
            println!(
                "uh oh expected {:?} got {:?}",
                exp_env.stack, prog_env.stack
            );
            Some(Error::test_assertion(program, expected, prog_env.stack))
        }
    }

    fn test_word(standard_env: Environment, w: Word) -> Vec<Error> {
        println!("hi");
        if let Some(d) = standard_env.dictionary.get(&KeyItem::Word(w)) {
            let examples = match d {
                Item::AxiomDef(a) => &a.examples,
                Item::DerivedDef(d) => &d.examples,
                _ => &None
            };
            examples
                .iter()
                .filter_map(|ex| {
                    let x = ex.get(0).unwrap().clone();
                    match (get_item(x.clone(), 0).unwrap(), get_item(x, 1).unwrap()) {
                        (Item::List(p), Item::List(exp)) => {
                            test_example(standard_env.clone(), p.clone(), exp.clone())
                        }
                        _ => Some(Error::expected("list")),
                    }
                })
                .collect::<Vec<Error>>()
        } else {
            Vec::new()
        }
    }

    #[test_case("+" ; "plus")]
    #[test_case("-" ; "minus")]
    #[test_case("=" ; "eq")]
    #[test_case(">" ; "gt")]
    #[test_case("and")]
    #[test_case("any?" ; "is_any")]
    #[test_case("assign")]
    #[test_case("association?" ; "is_association")]
    #[test_case("both?" ; "is_both")]
    #[test_case("branch")]
    #[test_case("clone")]
    #[test_case("count")]
    #[test_case("decide")]
    #[test_case("dip")]
    #[test_case("dipdown")]
    #[test_case("discard")]
    #[test_case("even?" ; "is_even")]
    #[test_case("evert")]
    #[test_case("every?" ; "is_every")]
    #[test_case("execute")]
    #[test_case("filter")]
    #[test_case("first")]
    #[test_case("float")]
    #[test_case("if")]
    #[test_case("inc")]
    #[test_case("inject")]
    #[test_case("inscribe")]
    #[test_case("join")]
    #[test_case("list?" ; "is_list")]
    #[test_case("lookup")]
    #[test_case("loop")]
    #[test_case("map")]
    #[test_case("not")]
    #[test_case("nothing?" ; "is_nothing")]
    #[test_case("number?" ; "is_number")]
    #[test_case("odd?" ; "is_odd")]
    #[test_case("or")]
    #[test_case("pack")]
    #[test_case("prepend")]
    #[test_case("primrec")]
    #[test_case("range")]
    #[test_case("recover")]
    #[test_case("recur")]
    #[test_case("rest")]
    #[test_case("reverse")]
    #[test_case("shield")]
    #[test_case("shielddown")]
    #[test_case("shielddowndown")]
    #[test_case("sink")]
    #[test_case("snapshot")]
    #[test_case("something?" ; "is_something")]
    #[test_case("step")]
    #[test_case("string")]
    #[test_case("string?" ; "is_string")]
    #[test_case("swap")]
    #[test_case("swapdown")]
    #[test_case("times")]
    #[test_case("type")]
    #[test_case("unpack")]
    #[test_case("unwrap")]
    #[test_case("update")]
    #[test_case("value")]
    #[test_case("while")]
    #[test_case("wrap")]
    #[test_case("zero?" ; "is_zero")]
    #[test_case("zip")]
    fn test_lexicon(word: &str) {
        let e = axiom::standard_env(None, None);
        let r = test_word(e.clone(), Intern::new(word.to_string()));
        assert!(r.is_empty(), "{:?}", r);
    }
}

// if let (Item::List(program), Item::List(expected)) = (program, expected) {

//     } else {
//         Err(Error::from("Example should be a pair"))
//     }

// for ex in d.examples().iter() {
//             let e = List::try_from(*ex).ok().unwrap();
//             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
//             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

//             test_example(axiom::standard_env.clone(), w, p,exp)
//         }.retain(|i| i.is_some()).collect::<Vec<Error>>()
#+end_src

Here are the axiom functions. Some of them are just functions of the
topmost stack items, and we'll call them with =f_stack1= etc. The rest
modify the expression or dictionary and are functions of the environment.
#+begin_src rust :tangle src/axiom.rs
use super::serialize;
use crate::types::*;
use internment::Intern;
use num_integer::Roots;
use std::collections::VecDeque;
use std::fs;
use std::mem;
use std::ops::Range;
use std::rc::Rc;

pub type ItemResult = Result<Item, Error>;

impl From<ItemResult> for Item {
    fn from(i: ItemResult) -> Self {
        match i {
            Ok(i) => i,
            Err(e) => Item::Error(e),
        }
    }
}

fn f_stack1_option(
    f: fn(Item) -> Result<Option<Item>, Error>,
) -> impl Fn(Environment) -> Environment {
    move |mut env: Environment| {
        let x = env.pop();
        match f(x) {
            Ok(r) => {
                if let Some(r) = r {
                    match r {
                        Item::Error(e) => env.push(Item::Error(e)),
                        _ => env,
                    }
                } else {
                    env
                }
            }
            Err(e) => env.push(Item::Error(e)),
        }
    }
}

fn f_stack1(f: fn(Item) -> ItemResult) -> impl Fn(Environment) -> Environment {
    move |mut env: Environment| {
        let x = env.pop();
        env.push(From::from(f(x)))
    }
}

fn f_stack2(f: fn(Item, Item) -> ItemResult) -> impl Fn(Environment) -> Environment {
    move |mut env: Environment| {
        let x = env.pop();
        let y = env.pop();
        env.push(From::from(f(y, x)))
    }
}

fn f_stack3(f: fn(Item, Item, Item) -> ItemResult) -> impl Fn(Environment) -> Environment {
    move |mut env: Environment| {
        let x = env.pop();
        let y = env.pop();
        let z = env.pop();
        env.push(From::from(f(z, y, x)))
    }
}

fn update_axiom_entries(mut d: Dictionary, updates: Vec<(&str, &'static StepFn)>) -> Dictionary {
    let dm = Rc::make_mut(&mut d);
    for (w, f) in updates {
        dm.entry(KeyItem::Word(Word::from(w)))
            .and_modify(|e| match e {
                Item::AxiomDef(a) => {
                    a.f = f;
                }
                _ => {}
            });
    }
    d
}

pub fn add_builtins(d: Dictionary) -> Dictionary {
    update_axiom_entries(
        d,
        vec![
            ("*", Box::leak(Box::new(f_stack2(mult)))),
            ("+", Box::leak(Box::new(f_stack2(plus)))),
            ("++lookup", Box::leak(Box::new(f_stack2(lookup)))),
            ("-", Box::leak(Box::new(f_stack2(minus)))),
            ("/", Box::leak(Box::new(f_stack2(div)))),
            ("<", Box::leak(Box::new(f_stack2(lt)))),
            ("<=", Box::leak(Box::new(f_stack2(lte)))),
            ("=", Box::leak(Box::new(f_stack2(eq)))),
            (">", Box::leak(Box::new(f_stack2(gt)))),
            (">=", Box::leak(Box::new(f_stack2(gte)))),
            ("and", Box::leak(Box::new(f_stack2(and)))),
            ("assign", Box::leak(Box::new(f_stack3(assign)))),
            ("association", Box::leak(Box::new(f_stack1(association)))),
            (
                "association?",
                Box::leak(Box::new(f_stack1(is_association))),
            ),
            ("branch", Box::leak(Box::new(branch))),
            ("bytes", Box::leak(Box::new(f_stack1(bytes)))),
            ("bytes?", Box::leak(Box::new(f_stack1(is_bytes)))),
            ("clone", Box::leak(Box::new(clone))),
            ("close", Box::leak(Box::new(f_stack1(crate::pipes::close)))),
            ("ceil", Box::leak(Box::new(f_stack1(ceil)))),
            (
                "closed?",
                Box::leak(Box::new(f_stack1(crate::pipes::is_closed))),
            ),
            ("count", Box::leak(Box::new(f_stack1(count)))),
            ("dec", Box::leak(Box::new(f_stack1(dec)))),
            ("decide", Box::leak(Box::new(decide))),
            ("dip", Box::leak(Box::new(dip))),
            ("dictionary", Box::leak(Box::new(dictionary))),
            ("dipdown", Box::leak(Box::new(dipdown))),
            ("discard", Box::leak(Box::new(discard))),
            ("environment", Box::leak(Box::new(f_stack1(environment)))),
            ("error?", Box::leak(Box::new(f_stack1(is_error)))),
            ("errored?", Box::leak(Box::new(f_stack1(is_errored)))),
            ("eval-step", Box::leak(Box::new(f_stack1(eval_step_outer)))),
            ("evaluate", Box::leak(Box::new(f_stack1(evaluate)))),
            ("even?", Box::leak(Box::new(f_stack1(is_even)))),
            ("evert", Box::leak(Box::new(evert))),
            ("execute", Box::leak(Box::new(execute))),
            (
                "file-in",
                Box::leak(Box::new(f_stack1(crate::pipes::fs::file_in))),
            ),
            (
                "file-out",
                Box::leak(Box::new(f_stack1(crate::pipes::fs::file_out))),
            ),
            ("first", Box::leak(Box::new(f_stack1(first)))),
            ("float", Box::leak(Box::new(float))),
            ("handle", Box::leak(Box::new(f_stack1(handle)))),
            ("inc", Box::leak(Box::new(f_stack1(inc)))),
            ("inscribe", Box::leak(Box::new(inscribe))),
            ("join", Box::leak(Box::new(f_stack2(join)))),
            ("list?", Box::leak(Box::new(f_stack1(is_list)))),
            ("loop", Box::leak(Box::new(loop_))),
            ("mod", Box::leak(Box::new(f_stack2(mod_)))),
            ("not", Box::leak(Box::new(f_stack1(not)))),
            ("number?", Box::leak(Box::new(f_stack1(is_number)))),
            ("odd?", Box::leak(Box::new(f_stack1(is_odd)))),
            ("or", Box::leak(Box::new(f_stack2(or)))),
            ("pack", Box::leak(Box::new(f_stack2(pack)))),
            ("pipe?", Box::leak(Box::new(f_stack1(is_pipe)))),
            ("put", Box::leak(Box::new(crate::pipes::put_))),
            ("range", Box::leak(Box::new(range))),
            ("read", Box::leak(Box::new(read))),
            ("recur", Box::leak(Box::new(recur))),
            ("rest", Box::leak(Box::new(f_stack1(rest)))),
            ("resume", Box::leak(Box::new(identity))),
            ("reverse", Box::leak(Box::new(f_stack1(reverse)))),
            ("second", Box::leak(Box::new(f_stack1(second)))),
            (
                "serversocket",
                Box::leak(Box::new(f_stack2(crate::pipes::net::server_socket))),
            ),
            ("sink", Box::leak(Box::new(sink))),
            ("sqrt", Box::leak(Box::new(f_stack1(sqrt)))),
            ("step", Box::leak(Box::new(step))),
            ("string", Box::leak(Box::new(f_stack1(string)))),
            ("string?", Box::leak(Box::new(f_stack1(is_string)))),
            ("swap", Box::leak(Box::new(swap))),
            ("swapdown", Box::leak(Box::new(swapdown))),
            ("take", Box::leak(Box::new(crate::pipes::take_))),
            ("true", Box::leak(Box::new(true_))),
            ("unassign", Box::leak(Box::new(f_stack2(unassign)))),
            ("unpack", Box::leak(Box::new(unpack))),
            ("unwrap", Box::leak(Box::new(unwrap))),
            ("word?", Box::leak(Box::new(f_stack1(is_word)))),
            ("wrap", Box::leak(Box::new(wrap))),
            ("zero?", Box::leak(Box::new(f_stack1(is_zero)))),
        ],
    )
}

pub fn read_lexicon_file(filename: &str, mut env: Environment) -> Environment {
    match fs::read_to_string(filename) {
        Ok(s) => {
            let items = serialize::parse(s, Some(&env.dictionary)).unwrap();
            let mut vitems = to_hash(List::from(items)).unwrap();
            let vitemsmut = Rc::make_mut(&mut vitems);
            for (k, def) in vitemsmut.into_iter() {
                let h = to_hash(List::try_from(def.clone()).unwrap()).unwrap();
                let word = as_word(k.clone()).unwrap();
                let newdef = to_lexicon_entry(word, h);
                let newdef2 = newdef.clone();
                let dict = Rc::make_mut(&mut env.dictionary);
                dict.entry(KeyItem::Word(word))
                    .and_modify(|e| match (e, newdef) {
                        (Item::AxiomDef(a), Item::AxiomDef(new_a)) => {
                            a.examples = new_a.examples;
                            a.spec = new_a.spec;
                        }
                        (Item::DerivedDef(d), Item::DerivedDef(new_d)) => {
                            d.examples = new_d.examples;
                            d.spec = new_d.spec;
                            d.definition = new_d.definition;
                        }
                        _ => {}
                    })
                    .or_insert(newdef2);
            }
            env
        }
        Err(_) => env.push(Item::Error(Error::undefined(Word::from("lexicon")))),
    }
}

fn add_derivations(mut env: Environment) -> Environment {
    let d = Rc::make_mut(&mut env.dictionary);
    d.insert(
        word_key("derivations"),
        Item::DerivedDef(DerivedDef {
            definition: Rc::new(ListContent::from_iter([
                //Item::Word(*S_LIST),
                Item::Assoc(Rc::new(AssociationContent::new())),
            ])),
            examples: None,
            spec: None,
            serialize: false,
            word: Intern::new("derivations".to_string()),
        }),
    );
    env
}

pub fn add_standard_dictionary(env: Environment) -> Environment {
    // read builtins
    let mut env = read_lexicon_file("src/kcats/builtins.kcats", env);
    env.dictionary = add_builtins(env.dictionary);
    env = add_derivations(env);
    read_lexicon_file("src/kcats/lexicon.kcats", env)
}

pub fn invalid_type_error(asked: List) -> ItemResult {
    Err(Error::type_mismatch(asked))
}

fn number_type_error() -> ItemResult {
    invalid_type_error(crate::types::wrap(Item::Word(*S_NUMBER)))
}

pub fn plus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i + j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i + j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float + j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i + j as Float)),
        _ => number_type_error(),
    }
}

pub fn minus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i - j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i - j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float - j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i - j as Float)),
        _ => number_type_error(),
    }
}

pub fn mult(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i * j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i * j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float * j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i * j as Float)),
        _ => number_type_error(),
    }
}

pub fn div(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i / j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i / j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float / j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i / j as Float)),
        _ => number_type_error(),
    }
}

pub fn mod_(i: Item, j: Item) -> ItemResult {
    let i = Int::try_from(i)?;
    let j = Int::try_from(j)?;
    Ok(Item::Int(i % j))
}

pub fn inc(i: Item) -> ItemResult {
    Ok(Item::Int(Int::try_from(i)? + 1))
}

pub fn dec(i: Item) -> ItemResult {
    Ok(Item::Int(Int::try_from(i)? - 1))
}

pub fn is_zero(i: Item) -> ItemResult {
    match i {
        Item::Int(i) => Ok(Item::from(i == 0)),
        Item::Float(i) => Ok(Item::from(i == 0.0)),
        _ => number_type_error(),
    }
}

pub fn gt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::from(i > j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::from(i > j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float > j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::from(i > j as Float)),

        _ => number_type_error(),
    }
}

pub fn lt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(From::from(i < j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::from(i < j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float) < j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::from(i < j as Float)),

        _ => number_type_error(),
    }
}

pub fn gte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::from(i >= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::from(i >= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float >= j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::from(i >= j as Float)),

        _ => number_type_error(),
    }
}

pub fn lte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::from(i <= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::from(i <= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float).le(&j))),
        (Item::Float(i), Item::Int(j)) => Ok(Item::from(i <= j as Float)),

        _ => number_type_error(),
    }
}

pub fn join(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::List(mut i), Item::List(mut j)) => {
            let imut = Rc::make_mut(&mut i);

            imut.append(Rc::make_mut(&mut j));
            Ok(Item::List(i))
        }
        (Item::String(mut i), Item::String(j)) => {
            i.push_str(&j);
            Ok(Item::String(i))
        }
        _ => invalid_type_error(serialize::to_list("[[list?] [string?]] [execute] any?")),
    }
}

pub fn pack(i: Item, j: Item) -> ItemResult {
    let mut l = List::try_from(i)?;
    Rc::make_mut(&mut l).push_back(j);
    Ok(Item::List(l))
}

pub fn clone(env: Environment) -> Environment {
    let clone = env.stack.front().unwrap().clone();
    env.push(clone)
}

fn swap2(mut env: Environment, offset: usize) -> Environment {
    Rc::make_mut(&mut env.stack).swap(offset, offset + 1);
    env
}

pub fn swap(env: Environment) -> Environment {
    swap2(env, 0)
}

pub fn swapdown(env: Environment) -> Environment {
    swap2(env, 1)
}

pub fn sink(mut env: Environment) -> Environment {
    let s = Rc::make_mut(&mut env.stack);
    s.swap(0, 2);
    s.swap(0, 1);
    env
}

pub fn float(mut env: Environment) -> Environment {
    let s = Rc::make_mut(&mut env.stack);
    s.swap(0, 2);
    s.swap(1, 2);
    env
}

pub fn discard(mut env: Environment) -> Environment {
    env.pop();
    env
}

pub fn eq(i: Item, j: Item) -> ItemResult {
    Ok(Item::from(i == j))
}

pub fn count(i: Item) -> ItemResult {
    Ok(Item::Int(List::try_from(i)?.len().try_into().unwrap()))
}

pub fn is_string(i: Item) -> ItemResult {
    Ok(Item::from(if let Item::String(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_bytes(i: Item) -> ItemResult {
    Ok(Item::from(if let Item::Bytes(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_error(i: Item) -> ItemResult {
    Ok(Item::from(if let Item::Error(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_word(i: Item) -> ItemResult {
    Ok(Item::from(match i {
        Item::Word(_) => true,
        Item::AxiomDef(_) => true,
        Item::DerivedDef(_) => true,
        _ => false,
    }))
}

pub fn is_pipe(i: Item) -> ItemResult {
    Ok(Item::from(match i {
        Item::In(_) => true,
        Item::Out(_) => true,
        _ => false,
    }))
}
pub fn is_number(i: Item) -> ItemResult {
    Ok(Item::from(if let Item::Int(_) | Item::Float(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_list(i: Item) -> ItemResult {
    Ok(Item::from(
        if let Item::List(_) | Item::Nothing | Item::Assoc(_) = i {
            true
        } else {
            false
        },
    ))
}

pub fn first(i: Item) -> ItemResult {
    let l = List::try_from(i)?;
    Ok(if let Some(i) = l.front() {
        i.clone()
    } else {
        Item::Nothing
    })
}

pub fn second(i: Item) -> ItemResult {
    let l = List::try_from(i)?;
    Ok(if let Some(i) = l.get(1) {
        i.clone()
    } else {
        Item::Nothing
    })
}

pub fn loop_(mut env: Environment) -> Environment {
    let p = List::try_from(env.pop());
    match p {
        Ok(mut p) => {
            let f = env.pop();
            if is_truthy(&f) {
                let p2 = p.clone();
                let pm = Rc::make_mut(&mut p);
                pm.push_back(Item::List(p2));
                pm.push_back(word("loop"));
                env.append_expression(p)
            } else {
                env
            }
        }
        Err(e) => env.push(Item::Error(e)),
    }
}

pub fn execute(mut env: Environment) -> Environment {
    match List::try_from(env.pop()) {
        Ok(program) => env.append_expression(program),
        Err(e) => env.push(Item::Error(e)),
    }
}

pub fn wrap(mut env: Environment) -> Environment {
    let item = env.pop();
    let mut lc = ListContent::new();
    lc.push_front(item);
    env.push(Item::List(Rc::new(lc)))
}

pub fn unwrap(mut env: Environment) -> Environment {
    match List::try_from(env.pop()) {
        Ok(l) => {
            let len = l.len();
            let l2 = (0..len).map(move |i| l[i].clone());
            for i in l2 {
                env = env.push(i);
            }
            env
        }
        Err(e) => env.push(Item::Error(e)),
    }
}

pub fn dip(mut env: Environment) -> Environment {
    match List::try_from(env.pop()) {
        Ok(program) => {
            let item = env.pop();
            let mut lc = ListContent::new();
            lc.push_front(item);
            let v = Rc::new(lc);
            let expr = Rc::make_mut(&mut env.expression);
            expr.push_front(word("unwrap"));
            expr.push_front(Item::List(v));
            env.append_expression(program)
        }
        Err(e) => env.push(Item::Error(e)),
    }
}

pub fn dipdown(mut env: Environment) -> Environment {
    match List::try_from(env.pop()) {
        Ok(program) => {
            let item1 = env.pop();
            let item2 = env.pop();
            let mut lc = ListContent::new();
            lc.push_front(item1);
            lc.push_front(item2);
            let v = Rc::new(lc);
            let expr = Rc::make_mut(&mut env.expression);
            expr.push_front(word("unwrap"));
            expr.push_front(Item::List(v));
            env.append_expression(program)
        }
        Err(e) => env.push(Item::Error(e)),
    }
}

pub fn unpack(mut env: Environment) -> Environment {
    // TODO: handle Nothing case
    let stack = Rc::make_mut(&mut env.stack);
    let i = if let Some(s) = stack.front_mut() {
        if let Item::List(ref mut l) = s {
            if let Some(i) = Rc::make_mut(l).pop_front() {
                i
            } else {
                Item::Nothing
            }
        } else {
            Item::from(invalid_type_error(Rc::new(ListContent::from_iter([
                Item::Word(*S_LIST),
            ]))))
        }
    } else {
        Item::Error(Error::stack_underflow())
    };
    stack.push_front(i);
    env
}

fn is_truthy(i: &Item) -> bool {
    match i {
        Item::Nothing => false,
        Item::List(l) => !l.is_empty(),
        Item::Assoc(a) => !a.is_empty(),
        _ => true,
    }
}

fn boolean_value(b: bool) -> Item {
    if b {
        word("true")
    } else {
        Item::Nothing
    }
}

pub fn branch(mut env: Environment) -> Environment {
    match (List::try_from(env.pop()), List::try_from(env.pop())) {
        (Ok(false_branch), Ok(true_branch)) => {
            let b = env.pop();

            env.append_expression(if is_truthy(&b) {
                true_branch
            } else {
                false_branch
            })
        }
        (Err(e), _) => env.push(Item::Error(e)),
        (_, Err(e)) => env.push(Item::Error(e)),
    }
}

pub fn step(mut env: Environment) -> Environment {
    let p = List::try_from(env.pop()).unwrap();
    let mut l = List::try_from(env.pop()).unwrap();
    let lm = Rc::make_mut(&mut l);
    if let Some(litem) = lm.pop_front() {
        let expr = Rc::make_mut(&mut env.expression);
        if !l.is_empty() {
            expr.push_front(word("step"));
            expr.push_front(Item::List(p.clone()));
            expr.push_front(Item::List(l));
        }
        expr.push_front(word("execute"));
        env.push(litem).push(Item::List(p))
    } else {
        env
    }
}

pub fn range(mut env: Environment) -> Environment {
    let to = Int::try_from(env.pop()).unwrap();
    let from = Int::try_from(env.pop()).unwrap();
    env.push(Item::List(Rc::new(
        (from..to).map(|i| Item::Int(i)).collect::<VecDeque<Item>>(),
    )))
}

// (effect [rec2 rec1 then pred]
//                   ['[if]
//[(concat rec1
//         [[pred then rec1 rec2 'recur]] rec2)
// then pred]])

pub fn recur(mut env: Environment) -> Environment {
    let mut rec2 = List::try_from(env.pop()).unwrap();
    let mut rec1 = List::try_from(env.pop()).unwrap();
    let then = List::try_from(env.pop()).unwrap();
    let pred = List::try_from(env.pop()).unwrap();
    env = env.push_expr(word("if"));
    let r = Item::List(Rc::new(ListContent::from([
        Item::List(pred.clone()),
        Item::List(then.clone()),
        Item::List(rec1.clone()),
        Item::List(rec2.clone()),
        word("recur"),
    ])));
    let mut e = ListContent::new();
    e.extend(Rc::make_mut(&mut rec1).drain(..));
    e.push_back(r);
    e.extend(Rc::make_mut(&mut rec2).drain(..));

    env.push(Item::List(pred))
        .push(Item::List(then))
        .push(Item::List(Rc::new(e)))
}

//(fn [{[l & others] 'stack :as env}]
//            (assoc env 'stack (apply list (vec others) l)))

pub fn evert(mut env: Environment) -> Environment {
    let mut l = List::try_from(env.pop()).unwrap();
    mem::swap(&mut env.stack, &mut l);
    env.push(Item::List(l))
}

fn as_word(i: KeyItem) -> Option<Word> {
    match i {
        KeyItem::Word(w) => Some(w.clone()),
        _ => None,
    }
}

fn to_lexicon_entry(w: Word, mut def: Association) -> Item {
    let dm = Rc::make_mut(&mut def);
    if dm.get(&key_item("definition")).is_some() {
        let mut d = DerivedDef::from(def);
        d.word = w;
        Item::DerivedDef(d)
    } else {
        Item::AxiomDef(AxiomDef {
            word: w,
            serialize: true,
            examples: dm
                .remove(&key_item("examples"))
                .and_then(|i| List::try_from(i).ok()),
            spec: dm
                .remove(&key_item("spec"))
                .and_then(|i| List::try_from(i).ok()),
            f: Box::leak(Box::new(move |env: Environment| {
                env.push(Item::Error(Error::undefined(w)))
            })),
        })
    }
}

fn assoc_in(i: Item, ks: &[KeyItem], v: Item) -> Result<Association, Error> {
    let mut h = Association::try_from(i)?;
    let hm = Rc::make_mut(&mut h);
    if let [k, ks @ ..] = ks {
        if ks.is_empty() {
            hm.insert(k.clone(), v);
        } else {
            let inner = hm.get(&k.clone()).unwrap_or(&Item::Nothing).clone();
            // if the inner value isn't a map, we're just overwriting whatever it
            // is with a new map.

            hm.insert(
                k.clone(),
                Item::Assoc(assoc_in(
                    Item::Assoc(match inner {
                        Item::Assoc(inner) => inner,
                        _ => Rc::new(AssociationContent::new()),
                    }),
                    ks,
                    v,
                )?),
            );
        }
    }
    Ok(h)
}

pub fn assign(m: Item, ks: Item, v: Item) -> ItemResult {
    let mut kit = List::try_from(ks).unwrap();
    let ks = Rc::make_mut(&mut kit).drain(..);
    let mut ksvec = ks
        .into_iter()
        .map(|k| to_key_item(k))
        .collect::<Result<KeyList, Error>>()?;
    ksvec.make_contiguous();
    let (ks, _) = ksvec.as_slices();
    Ok(Item::Assoc(assoc_in(m, ks, v)?))
}

//TODO: this should really take a keylist like assign and lookup
pub fn unassign(m: Item, k: Item) -> ItemResult {
    let mut m = Association::try_from(m).unwrap();
    let mm = Rc::make_mut(&mut m);
    let k = to_key_item(k)?;
    mm.remove(&k);
    Ok(Item::Assoc(m))
}

pub fn association(m: Item) -> ItemResult {
    match Association::try_from(m) {
        Ok(m) => Ok(Item::Assoc(m)),
        Err(e) => Err(e),
    }
}

pub fn lookup(m: Item, k: Item) -> ItemResult {
    //println!("lookup {:?} \n {:?}", m, k);
    let k = to_key_item(k)?;
    let m = Association::try_from(m)?;
    Ok(m.get(&k).unwrap_or(&Item::Nothing).clone())
}

pub fn or(i: Item, j: Item) -> ItemResult {
    Ok(if is_truthy(&i) {
        i
    } else {
        if is_truthy(&j) {
            j
        } else {
            Item::Nothing
        }
    })
    //Ok(Item::from(is_truthy(i) || is_truthy(j)))
}

pub fn and(i: Item, j: Item) -> ItemResult {
    Ok(if is_truthy(&i) && is_truthy(&j) {
        j
    } else {
        Item::Nothing
    })
}

pub fn not(i: Item) -> ItemResult {
    Ok(Item::from(!is_truthy(&i)))
}

pub fn is_association(i: Item) -> ItemResult {
    Ok(Item::from(match i {
        Item::Assoc(_) => true,
        Item::Nothing => true,
        Item::Env(_) => true,
        Item::List(l) => Association::try_from(Item::List(l)).is_ok(),
        _ => false,
    }))
}

pub fn is_odd(i: Item) -> ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::from(i & 1 == 1))
}

pub fn is_even(i: Item) -> ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::from(i & 1 == 0))
}

pub fn decide(mut env: Environment) -> Environment {
    let mut clauses = List::try_from(env.pop()).unwrap();
    let clauses_data = Rc::make_mut(&mut clauses);
    let clause = clauses_data.pop_front();

    if let Some(clause) = clause {
        if let Item::List(mut clause) = clause {
            if clause.len() != 2 {
                env.push(Item::Error(Error::list_count(2)))
            } else {
                let clause_data = Rc::make_mut(&mut clause);
                let test = clause_data.pop_front().unwrap();
                let expr = clause_data.pop_front().unwrap();

                match (test, expr) {
                    (Item::List(test), Item::List(expr)) => {
                        // construct if
                        let testp =
                            Rc::new(ListContent::from(vec![Item::List(test), word("shield")]));
                        let elsep =
                            Rc::new(ListContent::from(vec![Item::List(clauses), word("decide")]));
                        let newexpr = Rc::new(ListContent::from(vec![
                            Item::List(testp),
                            Item::List(expr),
                            Item::List(elsep),
                            word("if"),
                        ]));
                        env.append_expression(newexpr)
                    }
                    _ => env.push(Item::from(invalid_type_error(serialize::to_list(
                        "[list?] both",
                    )))),
                }
            }
        } else {
            env.push(Item::Error(Error::expected("list")))
        }
    } else {
        // clauses empty, return nothing
        env.push(Item::Nothing)
    }
}

pub fn read(mut env: Environment) -> Environment {
    let s = String::try_from(env.pop()).unwrap();
    let parsed = serialize::parse(s, Some(&env.dictionary));
    env.push(match parsed {
        Ok(l) => Item::List(l),
        Err(e) => Item::Error(e),
    })
}

fn check_type(i: &Item, w: Word) -> Result<(), Error> {
    match i {
        Item::Int(_) => {
            if w == *S_INTEGER || w == *S_NUMBER || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::List(_) => {
            if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_PROGRAM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Float(_) => {
            if w == *S_FLOAT || w == *S_NUMBER || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Bytes(_) => {
            if w == *S_BYTES || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::String(_) => {
            if w == *S_STRING || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Word(_) => {
            if w == *S_WORD || w == *S_ITEM || w == *S_BOOLEAN {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::AxiomDef(_) => {
            if w == *S_WORD || w == *S_ITEM || w == *S_ASSOC {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }

        Item::DerivedDef(_) => {
            if w == *S_WORD || w == *S_ITEM || w == *S_ASSOC {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Assoc(_) => {
            if w == *S_ASSOC || w == *S_LIST || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Env(_) => {
            if w == *S_ASSOC || w == *S_LIST || w == *S_ITEM || w == *S_ENVIRONMENT {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Nothing => {
            if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_BOOLEAN || w == *S_PROGRAM {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Error(_) => {
            if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_ERROR {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::In(_) => {
            if w == *S_ITEM || w == *S_PIPE {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Out(_) => {
            if w == *S_ITEM || w == *S_PIPE {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
        Item::Tunnel(_) => {
            if w == *S_ITEM || w == *S_PIPE {
                Ok(())
            } else {
                Err(Error::expected(&w))
            }
        }
    }
}

fn check_stack_depth(env: &Environment, min_depth: usize) -> Result<(), Error> {
    //println!("Checking stack has at least {} items", min_depth);
    if env.stack.len() < min_depth {
        Err(Error::stack_underflow())
    } else {
        Ok(())
    }
}

fn check_input_spec(spec: &List, env: &Environment) -> Result<(), Error> {
    let input_spec = spec.front().unwrap();
    if let Item::List(specs) = input_spec {
        check_stack_depth(env, specs.len())?;
        let indexes = Range {
            start: 0,
            end: specs.len(),
        };

        indexes
            .into_iter()
            .map(|i| {
                let item = env.stack.get(i).unwrap();
                let spec = specs.get(i).unwrap();
                match spec {
                    Item::List(named) => {
                        if let Item::Word(w) = named.get(0).unwrap() {
                            check_type(item, *w)
                        } else {
                            Err(Error::expected("list"))
                        }
                    }
                    Item::Word(w) => check_type(item, *w),
                    // the type might happen to also be a defined
                    // word, like 'association'
                    Item::AxiomDef(a) => check_type(item, a.word),
                    _ => Err(Error::expected("list")),
                }
            })
            .collect::<Result<(), Error>>()
    } else {
        Err(Error::expected("list"))
    }
}

pub fn eval_step(mut env: Environment) -> Environment {
    //println!("{:?}", env);
    let next_item = env.expression.front();

    if let Some(val) = next_item {
        match val {
            Item::Word(word) => {
                if let Some(dfn) = env.dictionary.get(&KeyItem::Word(*word)) {
                    match dfn {
                        Item::AxiomDef(d) => {
                            if let Some(spec) = &d.spec {
                                if let Err(e) = check_input_spec(&spec, &env) {
                                    env = env.push(Item::Error(e));
                                    return env;
                                }
                            } else {
                                println!("No spec for {}!", word);
                            }
                            let expr = Rc::make_mut(&mut env.expression);
                            expr.pop_front();
                            let f = d.f.clone();

                            (f)(env)
                        }
                        Item::DerivedDef(d) => {
                            if let Some(spec) = &d.spec {
                                if let Err(e) = check_input_spec(&spec, &env) {
                                    let stack = Rc::make_mut(&mut env.stack);
                                    stack.push_front(Item::Error(e));
                                }
                            } else {
                                println!("No spec for {}!", word);
                            }
                            let expr = Rc::make_mut(&mut env.expression);

                            expr.pop_front();
                            let items = d.definition.clone();
                            env.append_expression(items)
                        }
                        _ => {
                            let w = *word;
                            env.push(Item::Error(Error::undefined(w)))
                        }
                    }
                } else {
                    let w = *word;
                    env.push(Item::Error(Error::undefined(w)))
                }
            }
            _ => {
                // handle the case where it's a builtin and we want to use
                // the owned value, so we pop it
                if let Item::AxiomDef(builtin) = val {
                    if let Some(spec) = &builtin.spec {
                        if let Err(e) = check_input_spec(&spec, &env) {
                            env = env.push(Item::Error(e));
                            return env;
                        }
                    }
                    let b = AxiomDef::try_from(env.pop_expr()).unwrap();
                    (b.f)(env)
                } else {
                    // not a word, just push onto stack
                    let i = env.pop_expr();
                    env.push(i)
                }
            }
        }
    } else {
        env.push(Item::Error(Error::short_list(1)))
    }
}

fn reverse(i: Item) -> ItemResult {
    let mut l = List::try_from(i).unwrap();
    //l.make_contiguous().reverse();
    let lmut = Rc::make_mut(&mut l);
    Ok(Item::List(Rc::new(lmut.drain(..).rev().collect())))
}

fn bytes(i: Item) -> ItemResult {
    match i {
        Item::String(s) => Ok(Item::Bytes(Bytes::from(s.as_bytes()))),
        i => Ok(Item::Bytes(Bytes::from(serialize::emit(&i)))),
    }
}

fn string(i: Item) -> ItemResult {
    match i {
        Item::Bytes(b) => Ok(Item::String(std::str::from_utf8(&b).unwrap().to_string())),
        i => Ok(Item::String(serialize::emit(&i))),
    }
}

fn rest(i: Item) -> ItemResult {
    let mut l = List::try_from(i).unwrap();
    let ld = Rc::make_mut(&mut l);
    ld.pop_front();
    Ok(Item::List(l))
}

fn get_error(env: &Environment) -> Option<&Error> {
    if let Some(i) = env.stack.front() {
        if let Item::Error(e) = i {
            return Some(e);
        }
    }
    return None;
}

fn is_unhandled_error(env: &Environment) -> bool {
    if let Some(err) = get_error(env) {
        if !err.core.is_handled {
            return true;
        }
    }
    return false;
}

fn is_unhandlable_error(env: &Environment, err: &Error) -> bool {
    if !err.core.is_handled {
        let w = &word("handle");
        if env.expression.contains(w) {
            return false;
        } else {
            return true;
        };
    }
    return false;
}

fn handle_error(env: Environment) -> Environment {
    if let Some(err) = get_error(&env) {
        if is_unhandlable_error(&env, err) {
            println!("Unhandled error!");
            return env;
        } else {
            return unwind(env);
        };
    }
    return env;
}

/// Takes an env on ToS and replaces it with whether there's an
/// unhandlable error on its ToS. Only for use with nested
/// environments.
pub fn is_errored(i: Item) -> ItemResult {
    let env = Environment::try_from(i)?;
    Ok(boolean_value(if let Some(err) = get_error(&env) {
        is_unhandlable_error(&env, err)
    } else {
        false
    }))
    
}
fn unwind(mut env: Environment) -> Environment {
    let mut next = env.expression.front();
    let w = &word("handle");
    while next.is_some() && next.unwrap() != w {
        env.pop_expr();
        next = env.expression.front();
    }
    return env;
}

pub fn eval(mut env: Environment) -> Environment {
    loop {
        if let Some(err) = get_error(&env) {
            if is_unhandlable_error(&env, err) {
                //println!("unhandled err!");
                break;
            } else {
                if !err.core.is_handled {
                    env = unwind(env); // TODO: this should be done in eval_step
                };
            }
        }
        if !env.expression.is_empty() {
            env = eval_step(env);
        } else {
            break;
        }
    }
    env
}

pub fn standard_env(program: Option<List>, stack: Option<List>) -> Environment {
    let prog_expr = match program {
        Some(p) => Stack::from(p),
        _ => Stack::new(ListContent::new()),
    };

    let env = Environment {
        stack: stack.unwrap_or(Stack::new(ListContent::new())),
        expression: prog_expr,
        dictionary: Rc::new(AssociationContent::new()),
    };
    add_standard_dictionary(env)
}

fn environment(p: Item) -> ItemResult {
    let mut env = Association::try_from(p).unwrap();
    let envm = Rc::make_mut(&mut env);
    let stack = envm
        .remove(&to_key_item(word("stack")).unwrap())
        .and_then(|s| List::try_from(s).ok())
        .or(Some(List::new(ListContent::new())));
    let expression = envm
        .remove(&to_key_item(word("expression")).unwrap())
        .and_then(|s| List::try_from(s).ok())
        .or(Some(List::new(ListContent::new())));
    let dictionary = envm
        .remove(&to_key_item(word("dictionary")).unwrap())
        .and_then(|d| Association::try_from(d).ok());
    let mut env = standard_env(expression, stack);
    if let Some(mut d) = dictionary {
        let dmut = Rc::make_mut(&mut d);
        let edmut = Rc::make_mut(&mut env.dictionary);
        for (k, v) in dmut {
            List::try_from(v.clone())
                .and_then(to_hash)
                .and_then(|h| {
                    edmut.insert(k.clone(), Item::DerivedDef(DerivedDef::from(h)));
                    Ok(())
                })
                .ok();
        }
    }
    Ok(Item::Env(env))
}

pub fn eval_step_outer(env: Item) -> ItemResult {
    let inner_env = Environment::try_from(env)?;
    Ok(Item::Env(eval_step(inner_env)))
}

pub fn evaluate(env: Item) -> ItemResult {
    let inner_env = Environment::try_from(env)?;
    Ok(Item::Env(eval(inner_env)))
}

pub fn identity(env: Environment) -> Environment {
    env
}

pub fn dictionary(env: Environment) -> Environment {
    let d = env.dictionary.clone();
    env.push(Item::Assoc(d))
}

fn ceil(i: Item) -> ItemResult {
    let f = Float::try_from(i)?;
    Ok(Item::Float(f.ceil()))
}

fn sqrt(i: Item) -> ItemResult {
    match i {
        Item::Int(i) => Ok(Item::Int(i.sqrt())),
        Item::Float(f) => Ok(Item::Float(f.sqrt())),
        _ => Err(Error::expected("number")),
    }
}

fn handle(i: Item) -> ItemResult {
    match i {
        Item::Error(mut e) => Ok(Item::Error({
            e.core.is_handled = true;
            e
        })),
        i => Ok(i),
    }
}

fn inscription(env: &mut Environment) -> Result<(Word, DerivedDef), Error> {
    let d = Association::try_from(env.pop())?;
    let mut wl = List::try_from(env.pop())?;
    let w1 = Rc::make_mut(&mut wl).pop_front();
    let x = w1.ok_or(Error::short_list(1))?;
    let w = Word::try_from(x.clone())?;
    Ok((w, DerivedDef::from(d)))
}

pub fn inscribe(mut env: Environment) -> Environment {
    let r = inscription(&mut env);
    match r {
        Ok((w, def)) => {
            let d = Rc::make_mut(&mut env.dictionary);
            d.insert(KeyItem::Word(w), Item::DerivedDef(def));
            env
        }
        Err(e) => env.push(Item::Error(e)),
    }
}

// make 'true' a word that doesn't have to be quoted, just pushes itself onto the stack.
pub fn true_(env: Environment) -> Environment {
    env.push(word("true"))
}
#+end_src

Now we'll add the functions for parsing and emitting kcats source. 

#+begin_src rust :tangle src/serialize.rs
extern crate edn_format;
use crate::types::*;
use base64;
use internment::Intern;
use std::collections::VecDeque;
use std::fmt;
use std::rc::Rc;

pub trait Display {
    fn representation(&self) -> Item;
}

fn lookup_builtin(w: Word, standard_dictionary: Option<&Dictionary>) -> Item {
    if let Some(dict) = standard_dictionary {
        //println!("Looking up {} in dict of {} words", w, dict.len());
        if let Some(def) = dict.get(&KeyItem::Word(w)) {
            if let Item::AxiomDef(a) = def {
                let mut aa = a.clone();
                aa.serialize = false;
                return Item::AxiomDef(aa);
            };
        }
    }
    return Item::Word(w);
}
const BYTE_TAG: &str = "b64";

fn to_item(
    item: &edn_format::Value,
    standard_dictionary: Option<&Dictionary>,
) -> Result<Item, Error> {
    //println!("to item {:?}", item);
    match item {
        edn_format::Value::Integer(i) => Ok(Item::Int(*i)),
        edn_format::Value::Vector(v) => Ok(Item::List(Rc::new(
            v.iter()
                .map(|i| to_item(i, standard_dictionary))
                .collect::<Result<VecDeque<Item>, Error>>()?,
        ))),
        edn_format::Value::Symbol(s) => Ok(lookup_builtin(
            Intern::new(s.name().to_string()),
            standard_dictionary,
        )),
        // we don't have booleans in kcats, so if we see 'false' that
        // is the word false which is not defined in the base
        // language, but might be user-defined later.
        edn_format::Value::Boolean(b) => Ok(if *b { word("true") } else { word("false") }),
        edn_format::Value::String(s) => Ok(Item::String(s.to_string())),
        edn_format::Value::Float(f) => Ok(Item::Float(f.into_inner())),
        edn_format::Value::TaggedElement(tag, e) => {
            if *tag == edn_format::Symbol::from_name(BYTE_TAG) {
                if let edn_format::Value::String(s) = &**e {
                    Ok(Item::Bytes(base64::decode(s).unwrap()))
                } else {
                    Err(Error::parse("Invalid tag datatype for byte literal"))
                }
            } else {
                Err(Error::parse("Unsupported tag"))
            }
        }
        _ => Err(Error::parse("Unsupported data literal")),
    }
}

pub fn vectorize(a: &Association) -> Vec<edn_format::Value> {
    a.iter()
        .map(|(k, v)| {
            edn_format::Value::Vector(vec![from_item(&to_value_item(k.clone())), from_item(v)])
        })
        .collect()
}

pub fn from_item(item: &Item) -> edn_format::Value {
    match item {
        Item::Int(i) => edn_format::Value::Integer(*i),
        Item::List(v) => edn_format::Value::Vector(
            v.iter()
                .map(|i| from_item(i))
                .collect::<Vec<edn_format::Value>>(),
        ),
        Item::Word(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
        Item::AxiomDef(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(&w.word)),
        Item::String(s) => edn_format::Value::String(s.to_string()),
        Item::Float(f) => edn_format::Value::from(*f),
        Item::Bytes(bs) => edn_format::Value::TaggedElement(
            edn_format::Symbol::from_name("b64"),
            Box::new(edn_format::Value::String(base64::encode(bs))),
        ),
        Item::Assoc(h) => edn_format::Value::Vector(vectorize(h)),
        Item::Error(h) => edn_format::Value::Vector(vectorize(&h.data)),
        Item::Env(e) => edn_format::Value::Vector(vec![
            edn_format::Value::Vector(vec![
                from_item(&word("stack")),
                from_item(&Item::List(e.stack.clone())),
            ]),
            edn_format::Value::Vector(vec![
                from_item(&word("expression")),
                from_item(&Item::List(e.expression.clone())),
            ]),
            // TODO emit the non-builtin words of the dictionary
        ]),
        Item::Nothing => edn_format::Value::Vector(Vec::new()),
        Item::DerivedDef(d) => {
            if d.serialize {
                from_item(&Item::from(d.clone()))
            } else {
                from_item(&Item::Word(d.word))
            }
        }
        Item::In(i) => from_item(&i.representation()),
        Item::Out(i) => from_item(&i.representation()),
        Item::Tunnel(i) => from_item(&i.representation()),
    }
}

pub fn parse(s: String, standard_dictionary: Option<&Dictionary>) -> Result<List, Error> {
    let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
    Ok(Rc::new(
        parser
            .map(move |r| match r {
                Ok(expr) => Ok(to_item(&expr, standard_dictionary)?),
                Err(_) => Err(Error::parse("Invalid edn")),
            })
            .collect::<Result<ListContent, Error>>()?,
    ))
}

pub fn to_list(s: &str) -> List {
    parse(s.to_string(), None).unwrap()
}

pub fn emit(item: &Item) -> String {
    edn_format::emit_str(&from_item(item))
}

// print out envs in error messages
impl fmt::Debug for Environment {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ stack: {}, expression: {} }}",
            emit(&Item::List(self.stack.clone())),
            emit(&Item::List(self.expression.clone())),
        )
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", emit(&Item::Assoc(self.data.clone())))
    }
}
#+end_src

Now we'll add the functions that do input/output (pipes)

#+begin_src rust :tangle src/pipes.rs
use crate::axiom::ItemResult;
use crate::types::{Environment, Error, Item};
use crate::{word, ListContent};
use dyn_clone::DynClone;
use std::fmt::Debug;
use std::rc::Rc;
pub mod fs;
pub mod net;

pub trait Writable: Close + Debug + crate::serialize::Display + DynClone {}
pub trait Readable: Close + Debug + crate::serialize::Display + DynClone {}

pub trait In: Writable {
    fn put(&mut self, i: Item) -> Result<(), Error>;
}

pub trait Out: Readable {
    fn take(&mut self) -> Result<Item, Error>;
}

pub trait Tunnel: In + Out {}

/* Pipes can be "closed", from either end to signal that either the
 ,* putter or taker has gone away. Sometimes the type of pipe
 ,* may not really support this concept but an implementation is
 ,* required.  For example, files. When you open a file for writing and
 ,* then "close" it, that doesn't really do anything. Rust doesn't have
 ,* an explicit file close. You have to drop the reference to it, which
 ,* in kcats you can do by popping the pipe off the stack. Rust will
 ,* clean up automatically, other impls might have to reference count.
 ,*
 ,* The contract here is as follows:
 ,* 1. After calling close, put on the pipe returns an error
 ,*
 ,* 2. After calling close, take on the pipe will return still-buffered
 ,* items (if the pipe has a buffer), but once buffer is exhausted it
 ,* will return error.
 ,*
 ,* 2. Errors cannot be put into a pipe (the taker can't distinguish
 ,* between io error and an error value). To work around this, wrap the
 ,* error value in a list to quote it. Putting error into a pipe will
 ,* return an io error.
 ,*
 ,* 3. Once closed pipes cannot be ever be put into again. closed? will always
 ,* return true thereafter.
 ,*
 ,* One use case that has to be handled specially is a file we've fully
 ,* read but later someone else might write more bytes to the end. Does
 ,* the pipe close when we reach EOF? I think we might need to support
 ,* both types (a type that closes when hitting eof and one that
 ,* doesn't). The former is the "normal" use case, which will be the
 ,* default.
 ,*
 ,* These two types are basically static vs dynamic content. Either all
 ,* the content is known now, or it isn't.
 ,*
,*/
pub trait Close: Debug + DynClone {
    fn close(&mut self) -> Result<(), Error>;
    fn is_closed(&self) -> bool;
}

dyn_clone::clone_trait_object!(In);
dyn_clone::clone_trait_object!(Out);
dyn_clone::clone_trait_object!(Close);
dyn_clone::clone_trait_object!(Tunnel);

fn closed_error(on_take: bool) -> Error {
    Error::create(
        Rc::new(ListContent::from_iter([
            word("close"),
            word(if on_take { "take" } else { "put" }),
        ])),
        "attempt to use closed pipe",
    )
}

pub fn put_(mut env: Environment) -> Environment {
    let item = env.pop();
    let pipe = env.expression.front().unwrap();
    if let Item::In(p) = pipe {
        match (p.clone()).put(item) {
                Ok(_) => { env }
                Err(e) => {
                    env.push(Item::Error(e))
                }
            }
    }
    else {
        env.push(Item::Error(Error::expected("pipe")))

    }
    
}

pub fn take_(env: Environment) -> Environment {
    let pipe = env.expression.front().unwrap().clone();
    
    match pipe {
        Item::Out(mut p) => {
            let i = Out::take(&mut *p);
            match i {
                Ok(i) => env.push(i),
                Err(e) => {
                    env.push(Item::Error(e))
                }
            }
        }
        _ => {
            env.push(Item::Error(Error::expected("pipe")))
        }
    }
}

pub fn is_closed(i: Item) -> ItemResult {
    match i {
        Item::In(p) => Ok(Item::from(p.is_closed())),
        Item::Out(p) => Ok(Item::from(p.is_closed())),
        _ => Err(Error::expected("pipe")),
    }
}

pub fn close(i: Item) -> ItemResult {
    match i {
        Item::In(mut p) => Ok({
            p.close()?;
            Item::In(p)
        }),
        Item::Out(mut p) => Ok({
            p.close()?;
            Item::Out(p)
        }),
        _ => Err(Error::expected("pipe")),
    }
}
#+end_src

Now some specific types of pipes. These are for reading/writing data to files.
#+begin_src rust :tangle src/pipes/fs.rs
use crate::axiom::ItemResult;
use crate::pipes::{closed_error, Close, In, Out, Readable, Writable};
use crate::types::{word, word_key, AssociationContent, Error, Item};
use std::fs::File;
use std::io::{Read, Write};
use std::rc::Rc;

#[derive(Debug)]
struct StaticFile {
    pub file: File,
    pub closed: bool,
    pub path: String,
}

impl Clone for StaticFile {
    fn clone(&self) -> Self {
        StaticFile {
            file: self.file.try_clone().unwrap(),
            closed: false,
            path: self.path.clone(),
        }
    }
}

impl Close for StaticFile {
    fn close(&mut self) -> Result<(), Error> {
        Ok(())
    }

    fn is_closed(&self) -> bool {
        self.closed
    }
}

impl Writable for StaticFile {}
impl Readable for StaticFile {}

impl In for StaticFile {
    fn put(&mut self, i: Item) -> Result<(), Error> {
        match i {
            Item::Bytes(bs) => {
                let mut pos = 0;
                while pos < bs.len() {
                    let bytes_written = self.file.write(&bs[pos..])?;
                    pos += bytes_written;
                }
                self.file.flush()?;
                Ok(())
            }
            _ => Err(Error::expected("bytes")),
        }
    }
}

impl Out for StaticFile {
    fn take(&mut self) -> Result<Item, Error> {
        if self.is_closed() {
            return Err(closed_error(true));
        }
        let mut bs = [0u8; 1024];
        let ct = self.file.read(&mut bs)?;
        if ct == 0 {
            // EOF, no more takes since it's static
            self.closed = true;
        }
        Ok(Item::Bytes(bs[0..ct].to_vec()))
    }
}

impl crate::serialize::Display for StaticFile {
    fn representation(&self) -> Item {
        Item::Assoc(Rc::new(AssociationContent::from([
            (word_key("type"), word("pipe")),
            (word_key("file"), Item::String(self.path.clone())),
        ])))
    }
}

pub fn file_in(i: Item) -> ItemResult {
    let path = String::try_from(i)?;
    Ok(Item::In(Box::new(StaticFile {
        file: File::options()
            .read(true)
            .write(true)
            .create_new(true)
            .open(path.clone())?,
        closed: false,
        path,
    })))
}

pub fn file_out(i: Item) -> ItemResult {
    let path = String::try_from(i)?;
    Ok(Item::Out(Box::new(StaticFile {
        file: File::open(path.clone())?,
        closed: false,
        path,
    })))
}
#+end_src

These are for reading/writing data over tcp/ip sockets.
#+begin_src rust :tangle src/pipes/net.rs
use crate::axiom::ItemResult;
use crate::pipes::{closed_error, Close, In, Out, Readable, Tunnel, Writable};
use crate::types::{word, word_key, wrap, AssociationContent, Int, Item};
use crate::Error;
use std::io::{Read, Write};
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener, TcpStream};
use std::str::FromStr;
use std::rc::Rc;

#[derive(Debug)]
struct Socket {
    pub socket: TcpStream,
    pub addr: SocketAddr,
    pub closed: bool,
}

impl Clone for Socket {
    fn clone(&self) -> Self {
        Socket {
            socket: self.socket.try_clone().unwrap(),
            addr: self.addr.clone(),
            closed: false,
        }
    }
}

impl Close for Socket {
    fn close(&mut self) -> Result<(), Error> {
        Ok(())
    }

    fn is_closed(&self) -> bool {
        self.closed
    }
}

impl Readable for Socket {}
impl Writable for Socket {}

impl crate::serialize::Display for Socket {
    fn representation(&self) -> Item {
        Item::Assoc(Rc::new(AssociationContent::from([
            (word_key("type"), word("tunnel")),
            (word_key("realm"), word("tcp")),
            (word_key("address"), Item::String(self.addr.to_string())),
        ])))
    }
}

impl Out for Socket {
    fn take(&mut self) -> Result<Item, Error> {
        if self.is_closed() {
            return Err(closed_error(true));
        }
        let mut bs = [0u8; 1024];
        let ct = self.socket.read(&mut bs)?;
        if ct == 0 {
            // EOF, no more takes since it's static
            self.closed = true;
        }
        Ok(Item::Bytes(bs[0..ct].to_vec()))
    }
}

impl In for Socket {
    fn put(&mut self, i: Item) -> Result<(), Error> {
        match i {
            Item::Bytes(bs) => {
                let mut pos = 0;
                while pos < bs.len() {
                    let bytes_written = self.socket.write(&bs[pos..])?;
                    pos += bytes_written;
                }
                self.socket.flush()?;
                Ok(())
            }
            _ => Err(Error::expected("bytes")),
        }
    }
}

impl Tunnel for Socket {}

// Server sockets
#[derive(Debug)]
struct ServerSocket {
    pub socket: TcpListener,
    pub closed: bool,
}

impl Clone for ServerSocket {
    fn clone(&self) -> Self {
        ServerSocket {
            socket: self.socket.try_clone().unwrap(),
            closed: false,
        }
    }
}

impl Close for ServerSocket {
    fn close(&mut self) -> Result<(), Error> {
        Ok(())
    }

    fn is_closed(&self) -> bool {
        self.closed
    }
}

impl Readable for ServerSocket {}

impl crate::serialize::Display for ServerSocket {
    fn representation(&self) -> Item {
        Item::Assoc(Rc::new(AssociationContent::from([
            (word_key("type"), word("pipe")),
            (
                word_key("serversocket"),
                Item::String(self.socket.local_addr().unwrap().to_string()),
            ),
        ])))
    }
}

impl Out for ServerSocket {
    fn take(&mut self) -> Result<Item, Error> {
        if self.is_closed() {
            return Err(closed_error(true));
        }
        let (socket, addr) = self.socket.accept()?;

        Ok(Item::Tunnel(Box::new(Socket {
            socket,
            addr,
            closed: false,
        })))
    }
}

pub fn server_socket(i: Item, j: Item) -> ItemResult {
    let addr = Ipv4Addr::from_str(String::try_from(j)?.as_str())?;
    let port = Int::try_from(i)? as u16;
    Ok(Item::Out(Box::new(ServerSocket {
        socket: TcpListener::bind(SocketAddrV4::new(addr, port))?,
        closed: false,
    })))
}

impl From<std::net::AddrParseError> for Error {
    fn from(err: std::net::AddrParseError) -> Error {
        Error::create(wrap(word("addrparse")), &err.to_string())
    }
}
#+end_src
** Issues
*** DONE Serialization treats any tagged literal as byte string
*** DONE Serialization panics on reading invalid data
Should return Result objects from to_item. I don't think it is
necessary for from_item - since we're using a subset of edn, all Items
should be convertible to valid edn. But not all valid edn is
convertible to an Item.
*** DONE Association list and list of equal content don't compare equal
**** Description
Probably need a custom PartialEq impl for Item here that converts the
list to a hash before comparing. Return false if the item doesn't
convert.

The sticky issue here is that when we read a literal like =[[type
foo][value bar] ]=, how do we know whether it should be compared to
something else as a hashmap (that ignores order) or a plain list (that
doesn't). We can probably deduce that if one of the arguments is a
hashmap, then the other should be treated as one. However what if both
are plain lists? It's still possible the intent was hashmap.
**** Hacky Solution
what if you execute =[[a b][c d] ] [[c d][a b] ] == ? It's impossible
to know the intent. I think maybe the best way out is to treat
anything associative-shaped as association, and if the user wants
ordered comparison, let him use a different operator, =ordered== or
something.

So the comparison of two items that are either List or Assoc goes like this:

If either item is Assoc, then convert the other to Assoc (if
necessary) and do straight =.

If they're both List, compare lengths. If not equal, return
false. Otherwise, examine items- If they're all pairs, convert both to
assoc. finally do straight =.
**** Better solution
Add a word =associative=. If that follows a list, it's converted to a
hashmap and then it's easy to compare to another hashmap. The
representation is unchanged of course. But it lets the programmer
specify the intent of how === should behave.

This does reveal a problem with the unit tests that are specified as
examples in the lexicon. Those tests will execute the program and then
compare the representation of the resulting stack, with the
representation given. As we now can see, comparing representations is
insufficient, we need to be able to compare actual implementations.

That means, the unit test's expected value should be calculated and
not just read in. For most tests, no changes will be required (it's
just putting values on the stack and no further calculation needed).

But in the end we'll need to compare actual stack to expected stack,
not a stack to a representation. So the unit test logic will need to
run two environments, the actual and the expected, and then compare them.

The previous solution just isn't going to cut it - when we go to
implement sets it's going to be completely impossible to use a
heuristic to figure out what the intent was. Lists and sets will look
the same. So in the case of sets we'll have to specify the word =set=.

Do we have to be explicit when comparing list to association?  we
could either always return false (they're different types), or we
could compare them as lists or as maps.

The question then is if the two intents don't match, what do we do?  I
can't think of a reasonable answer- does order matter? We have
conflicting answer with no way to resolve it. Maybe it's safest to
just return false.

You can argue maybe even if order matters, maybe the two lists are in
the same order and should therefore compare equal. But associatives
don't have a defined order, so that would be just leaving it up to
chance and it wouldn't even be consistent across time. So that doesn't
seem wise.

So here's the plan: 
Examples:
#+begin_src kcats
[[a b] [c d]] association
[[c d] [a b]] association
=
=> true

[[a b] [c d]]
[[c d] [a b]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]]
=
=> true

[a a b c]
[a b c]
=
=> false

[a b c] set
[a b c]
=
=> false

[a b c] set
[b a c] set
=
=> true
#+end_src
*** DONE Items of equal content don't compare equal
#+begin_src kcats
+ handle [[type error] [asked [consume]] [reason "not enough items on stack"]] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
dictionary [swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
[] environment [dictionary swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

This matches clojure
#+begin_src kcats
1 1.0 =
#+end_src

#+RESULTS:
: 
: [false]

#+begin_src kcats
[] [] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
"foo" bytes "foo" bytes =
#+end_src

#+RESULTS:
: 
: [true]

*** DONE Change unit tests to make the expected take a program and eval it
This is to fix the cases that result in associatives or sets where
order doesn't matter but we don't have a way to declare how the values
should be conmpared. We can't just compare representations, we need to
compare two actual stacks.

So instead of
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]]]]
#+end_src

We should write
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]] association]]
#+end_src

So that the two stacks will compare equal.
*** TODO Interactive mode
run with =kcats -i= for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
*** TODO Install the lexicon in the proper place
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.
*** TODO Package the binary for various platforms
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
*** TODO 'read' on invalid edn consumes the string argument
It should attempt to parse before popping the item off the stack.
*** DONE assign doesn't overwrite a nested value properly
#+begin_src kcats
[[a b] [c d]] association
[a e] "foo!" assign
#+end_src

#+RESULTS:
: 
: [[[c d] [a [[e "foo!"]]]]]

This errors out because =b= isn't an association. But we want it to
overwrite =b= with =[[d "foo!"] ]=.
*** DONE create an environment from data (including an existing stack)
It'd be nice to copy paste the output of one execution and have it pick up again eg
#+begin_src kcats
[[stack [1 2 3]]
 [expression [+]]]
#+end_src

There are potential issues here - such as the representation of an
associative is just a list, so when it's read back in it won't be the same:
#+begin_src kcats
[[stack [[[a b] [c d]]
         [[c d] [a b]]]]
 [expression [=]]]
#+end_src

If the two lists on the stack were actually associatives, they were
equal before but now they won't be.

I don't know that this is such a big problem, it's not possible for
everything in the language to be sensibly round-tripped via
serialization (eg stateful things like pipes).

If it's important to compare as associative, then make that part of
the expression.

What should =environment= take as an argument? Seems like it should
take an association (or assoc-shaped list).

#+begin_src kcats
[] environment
#+end_src

#+RESULTS:
: 
: [[[stack []] [expression []]]]

should give the default env.

#+begin_src kcats
[[expression [1 2 +]]] environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

should give the unexecuted env

#+begin_src kcats
[[expression [+]] [stack [3 2]]] environment evaluate [stack] lookup first
#+end_src

#+RESULTS:
: 
: [5]


should execute env with default dictionary plus whatever we add

#+begin_src kcats
[[dictionary [[foo [[definition [inc +]]
                    [spec [[number] [number]]]]]
              [bar [[definition [foo 5 *]]
                    [spec [[number] [number]]]]]]]
 [expression [1 2 bar]]]

environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [20]] [expression []]]]

should give the default env with the additional dict entries


#+begin_src kcats
[[expression
  [21449

   [] swap 2

   [/ 2 >]
   [ [mod 0 =]
     [clone sink [pack] dipdown / 2]
     [inc]
     if]
   while

   discard pack
  ]]]
environment
advance advance advance advance advance advance
eval-step
#+end_src

#+RESULTS:
: 
: [[[stack [[[mod 0 =] [clone sink [pack] dipdown / 2] [inc] if] [/ 2 >] 2 21449 []]] [expression [swap wrap [shield] join clone dipdown join loop discard pack]]]]


#+begin_src kcats
[[expression [1 2 +]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

#+begin_src kcats
dictionary count
#+end_src

#+RESULTS:
: 
: [118]

*** DONE In-thread error handling
**** DONE Error structs
**** DONE Stop on unrecoverable error
**** DONE Be able to resume execution after an error
***** Notes
#+begin_src  kcats
2 [1 4 0] [[/] [discard 0] recover] map

#+end_src

#+RESULTS:

#+begin_src kcats
2 [1 4 0] [[/] [discard 0] recover] map

[1 0 /] [discard 0] recover
1 [0 /] [discard 0] . recover
1 . snapshot
    [0 /] inject first
    [error?] [discard 0] [] if
    resume
err [error?]  

t r recover
[snapshot] dipdown ;; rec test ss
[inject] dip swap ;; res rec
[first error?] ;; err? res rec
discard execute;; drop the snapshot and run recovery
evert discard ;; use snapshot as stack


; inject the program into a snapshot. If there's an error on top
; afterward, inject the recovery in there too. It'll have access to
; the whole context. If there's no error, evert and drop the ToS.

;; the execution will stop after injecting into the snapshot, so
;; "first" won't even get executed here.

[discard] [discard] recover

;; here we recover from underflow by just dropping the error


[1 0 /] . execute
. 1 0 /
err . [discard 0] execute resume
                        ;; ^ this is in the expression so keep going, actual word doesn't do anything


;; when the ToS is err, how do we know whether to stop?  we can look
;; at the expression to see what's coming. We can't do that at every
;; step of the entire execution but we don't have to. Just when ToS =
;; err. The challenge is to encode this just with the stack/expr and
;; no extra state. We can put a word like "continue" in the expr, but
;; at some point we actually have to have an err on ToS and do
;; something with it. The only place we can put some kind of flag not
;; to abort, is in the expression (or maybe the dictionary).

;; another approach is to explicitly continue unless halt is called,
;; but the error-producer doesn't know whether the error can be
;; handled or not.


;; how to unwind. can we just naively unwind to the next instance of
;; 'recover' in the expression? or will quoted programs mess this up?
;; Let's work through it

;; here the recover is quoted, but by the time an error occurs and we
;; look at the expression, it'll be there:
2 [1 4 0] [[/ 12 +] [discard 0] recover] map

2 err . 12 + resume [error?] [discard 0] if
2 err . [error?] [discard 0] [] if 

;; so the problem is even after we've unwound the expression to
;; 'resume', the error is still on the ToS! Now we want to actually do
;; the recovery, but we've already gotten rid of the flag that tells
;; us we're doing that. Maybe we can modify the error object itself to
;; note that it's been flagged for processing. Maybe [[type error]
;; [detected? true] [message "oops"]]. Or maybe we can convert it from
;; the error object to a richer object that contains the whole
;; stack/expr at the time it happened.

;; maybe we need a primitive here: fail, which will put a new item on
;; ToS which includes the whole env field plus a message field to
;; describe what is wrong.

;; eg

1 0 /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]]

1 0 . "division by zero" capture /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]] . /

;; ok what's the best we got so far?

;; i think it's recover/resume, without requiring nested env. Have the
;; error type with a flag detected?. Eval will do the following: if
;; there's an error on top, and there is no 'detected?' field, unwind
;; the expression to 'resume' (if there is one, otherwise clean the
;; expression). Set the detected field and continue. presumably what's
;; next is the error handler if there's anything left in the
;; expression.

;; ok this is good but it'd be nice to know what the expression was
;; before it gets unwound. For example what if the handler wants to
;; log the error? By the time it can do that, the original word that
;; errored is not in the expression anymore. The error object would
;; have to contain a snapshot (not just of the stack, but the
;; expression too). what about snapshotting the stack and cherry
;; picking the error object before the recovery? How does the recovery
;; distinguish different types of errors (java's catch-by-class is
;; kind of weak)

;;eg

1 "foo" + 0 /

;; there's 2 things wrong here, what if we only want to recover from
;; division by zero? well, we can only wrap / in a recover. ok waht about this

"foo" 0 /

;; this will actually error with type mismatch

;; how are we supposed to serialize these things? This makes me think
;; the rust structs need to be easily representable as kcats. And then
;; what are we supposed to do with error literals (the reader would
;; need to convert them). What would error literals look like,
;; especially user-defined errors?

[[error "oh noes"]]

;; but then how to subtype them? Here we have a sort of pseudoprogram
;; that demonstrates what the interpreter couldn't do. for example [0
;; /] means it can't divide by zero. And then there's a string that
;; just says what the program can't do. eg 'number' is a word that may
;; or may not exist (I suppose it should, to do parseInt type stuff)
;; but the point is it's pseudocode that in many cases will work as
;; real code, but not guaranteed.

[[type error]
 [asked [0 /]]
 [reason "cannot divide by zero"]]

[[type error]
 [asked [number]]
 [reason "not a number"]]

[[type error]
 [asked [consume]]
 [reason "not enough items on stack"]]

[[type error]
 [asked [2 get]]
 [reason "not enough items in the list"]]

[[type error]
 [asked [bloop]]
 [reason "word is not defined"]]
#+end_src

#+begin_src kcats
17
[+]
[discard 5 +]

[[handle] join] dip ;; add handle to the end of test
[snapshot] dipdown ;; rec test ss
sink inject ;; res rec
[first error?] ;; err? res rec
[first swap execute];; drop the snapshot and run recovery
[evert discard] ;; use snapshot as stack
if

#+end_src

#+RESULTS:
: 
: [22]


#+begin_src kcats :results code
5
[1 2 "oh fudge"]
[[+]
 [discard discard]
 recover]
map
#+end_src

#+RESULTS:
#+begin_src kcats

[[6 7 5] 5]
#+end_src

#+begin_src kcats
 [+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
5 handle 

#+end_src

#+RESULTS:
: 
: [5]

**** DONE Errors during recovery are improperly caught
The current implementation cannot tell the difference between an error
that was put on the stack during the "test" program, vs one that was
put there during the recovery. So if the recovery throws an error, it
*should* halt the execution, but it won't. Instead the program will
continue executing and words will be invoked with errors on the stack
that shouldn't be invoked.

I think I have a solution, but it does require modifying the error
object by setting a =handled?= flag (note the plan is for this to be
an implementation detail and from kcats point of view the error object
will not be visibly modified). The recovery program will have a word
=handle= inserted in the first position. The word =handle= will set
the flag on the error to =true=. Then =eval= can stop when a) there's
an error on the stack with no =handled? = true= AND the word =handle=
isn't in the expression. If =handle= *is* in the expression, we need
to unwind the expression up to but not including the =handle= word.

The word =handle= has to be an atomic operation (an axiom word that
sets the flag in one evaluation step, otherwise the progam would halt
before the flag could be set.)

We can delete the word =resume=.

#+begin_src kcats :results code
 discard 1 2 + handle discard 3 4 +
#+end_src

#+RESULTS:
#+begin_src kcats

[7]
#+end_src

#+begin_src kcats
1 [[zero?] [pos?]] [execute] every?
#+end_src

#+RESULTS:
: 
: [false 1]

#+begin_src kcats
1 [[zero?] [positive?]] [execute] any?
#+end_src

#+RESULTS:
: 
: [true 1]

*** INPROGRESS Optimize memory allocation
**** DONE Lists
#+begin_src kcats
[[a b]] [a] lookup
#+end_src

#+RESULTS:
: lookup List([List([Word(0x5831a028e550 : "a"), Word(0x5831a028e860 : "b")])]) 
:  Word(0x5831a028e550 : "a")
: 
: stack: [[[reason "type mismatch"] [type error] [asked [word]]] [] b]
: expression: [++lookup [[]] unwrap [[[swap association?] [something?]] [execute] every?] shield [unpack swap [++lookup] dip [[[swap association?] [something?]] [execute] every?] shield] loop [something?] ["Lookup attempted on non association value" fail] [discard] if]
*** TODO pack and unpack are not inverse
#+begin_src kcats :result code
[1 2 3] unpack pack
#+end_src

#+RESULTS:
: 
: [[2 3 1]]

It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.
*** INPROGRESS true and false are not words?
#+begin_src kcats :results code
[true] unwrap word?
#+end_src

#+RESULTS:
#+begin_src kcats

[[[asked [word?]] [type error] [reason "word is not defined"]] true]
#+end_src

If you didn't know =true= was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).

It's messy because true/false are the only "words" you can put onto
the stack without wrapping.

There are several ways to deal with this:

+ just leave as is (these look like words but don't act like them)

+ Use something else for boolean values, like 0b 1b or something (ugly, no)

+ Revert to allowing bare words (that aren't actions) to go onto the
  stack unwrapped, so that true/false aren't different

Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.
*** TODO Division by zero panics
*** INPROGRESS Implement pipes
**** DONE Write to a file
#+begin_src kcats
[[file "/tmp/bar2"]] pipe-in

["hello world!"
 "Nice to meet you!"
 "My name is kcats"]

["\n" join bytes put]

step
#+end_src

#+RESULTS:
: 
: [[[file "/tmp/bar2"] [type pipe]]]
**** DONE Read from a file
#+begin_src kcats :results code
"" [string join] [[file "/tmp/bar2"]] pipe-out

assemble 
#+end_src

#+RESULTS:
#+begin_src kcats

["hello world!\nNice to meet you!\nMy name is kcats\n"]
#+end_src

#+begin_src kcats :results code
dictionary [assemble spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[type error] [reason "word is not defined"] [asked [fail]]]
 "Lookup attempted on non association value"
 [spec]
 [[definition [swap [take swap] swap pack [dip] join [[closed? not]] dip while discard]]
  [spec [[pipe program] [item]]]]]
#+end_src
**** DONE Close a pipe
#+begin_src kcats :results code
[[file "/tmp/foopytoop"]] pipe-in "foo" bytes put close "bar" bytes put
#+end_src

#+RESULTS:
#+begin_src kcats

[999]
#+end_src
**** DONE Serialize pipes with something sane
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
**** DONE Sockets
***** DONE Server Sockets
#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out take take string
#+end_src

#+RESULTS:
#+begin_src kcats

["hello world!\n" [[realm tcp] [type tunnel] [address "127.0.0.1:52212"]] [[type pipe] [serversocket "127.0.0.1:11211"]]]
#+end_src

#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out ;; server socket
take ;; accept connection by taking a socket out of the pipe
"foo\n" bytes put ;; write a message to the socket
take string ;; get a message from the socket
[discard ;; close the socket
 discard] ;; close the server socket
dip
#+end_src

#+RESULTS:
#+begin_src kcats
["bar\n"]
#+end_src

***** DONE Sockets

*** INPROGRESS Use a single word for all derivation/conversion
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.

Here we use the association shorthand for =[[type bytes]]=
#+begin_src kcats
"foo" [bytes] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [bytes] "foo"]

Here's a typical invocation
#+begin_src kcats
"foo" [[type bytes]] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [[type bytes]] "foo"]

Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
#+begin_src kcats
"foo"
[[bytes]
 [[type aes-key]
  [length 128]]]
[derive]
step
#+end_src

#+RESULTS:
: No spec for derive!
: No spec for derive!
: 
: [[] [[type aes-key] [length 128]] [] [bytes] "foo"]

This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.

The difficulty is how to implement it. A naive way would just make
=derive= a multimethod and add lots of methods. The problem is the
=decide= based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use =decide= internally).

But maybe even that isn't ideal - we could also lookup by =[sourcetype
destinationtype]= pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.

It should be possible to implement the =destinationtype= based lookup
pretty easily. Make =derive= a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).

Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
#+begin_src kcats
[derive]
[[[bytes string] [string]]] association wrap
[float type wrap swap join ;; 1 [string] => [number string]
 lookup execute] join
[definition] swap pack
wrap
inscribe

"foo" bytes [string] 
derive 
#+end_src

#+RESULTS:
: No spec for derive!
: 
: stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
: expression: [lookup execute]


Ok here's the basic impl. Afterward, should change =string= to
=++string= to make them non-public, should use =[string] derive=
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like =derivations=, but that
sticks out as different - it's a data structure and not an action
word.
#+begin_src kcats
;; add some conversions
derivations [[bytes string] [string]] assign
;; the list of conversions
[[[bytes string] [string]]] association

"foo" bytes [string]


;; determine the current type and look up the conversion
[[type] shield wrap] dipdown [join wrap] dip 
swap lookup execute
#+end_src

#+RESULTS:
: 
: ["foo"]
#+begin_src kcats
dictionary [assign spec] lookup 
#+end_src

#+RESULTS:
: 
: [[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]

#+begin_src kcats 
[[[a b] c]] [[a b]] lookup
#+end_src

#+RESULTS:
: 
: [c]

#+begin_src kcats
[[string [foo]]] [string] lookup
#+end_src
#+RESULTS:
: 
: [[foo]]

Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
#+begin_src kcats :results code
[+] unwrap type
#+end_src

#+RESULTS:
#+begin_src kcats

[word]
#+end_src

#+begin_src kcats
[] [] [] [discard [default] unwrap] if
#+end_src

#+RESULTS:
: 
: [default]

#+begin_src kcats
[[bar 12]]
[
[[foo] lookup]
[[bar] lookup]
[5]
[6]
]
swap [nothing?] shield
[[unpack] dip swap execute [nothing?] shield] loop
;;sink discard discard
#+end_src

#+RESULTS:
: 
: [[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]

#+begin_src kcats
[[bar 12]]
[[[foo] lookup]
 [[bar] lookup]]
[execute] any?
#+end_src

#+RESULTS:
: 
: [12 [[bar 12]]]

#+begin_src kcats
1 2 or
#+end_src

#+RESULTS:
: 
: [1]

Now that we have a fairly reliable =type= implementation, we can
dispatch on both =to= and =from= types for =derive=.

#+begin_src 

#+end_src
*** DONE Change boolean operators to retain values
=or= and =and= should return the actual value if it is truthy, instead
of =true=. But neither should ever return =[]=, but use =false=
instead.
#+begin_src kcats
2 []+ or
#+end_src

#+RESULTS:
: 
: [2]

#+begin_src kcats
1 10 inc range unpack swap [*] step
#+end_src

#+RESULTS:
: 
: [3628800]

This does bring up the question of whether the boolean type is really
needed. It may be possible to use =[]= as =false= and anything else as
=true= (=1= for example, or maybe the bare word =true= which then
wouldn't carry any other meaning). Or possible use some other word
than =true=, eg =something=.

Does this make sense when applied to boolean logic?

#+begin_example
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
#+end_example

I think it doesn't make sense.

Maybe yes/no?

#+begin_example
yes or no = yes ?
#+end_example
#+begin_src kcats
5 3 =
#+end_src

#+RESULTS:
: 
: [[]]

#+begin_src kcats
5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide
#+end_src

#+RESULTS:
: 
: ["five" 5]

#+begin_src kcats
[3 5 7] [even?] any? false =
#+end_src

#+RESULTS:
: 
: stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
: expression: [false =]
*** DONE 'recover' is broken
#+begin_src kcats
[+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
[[expression [[+] [3] recover]]] environment advance advance
eval-step
advance
advance
advance
advance
advance
eval-step
advance
advance
advance
#+end_src

#+RESULTS:
: 
: [[[stack [[+ handle] [[3]]]] [expression [dip evert [first error?] [first swap execute] [evert discard] if]]]]
*** TODO Fix handle in nested env
=handle= doesn't work properly in a nested environment. That is
because =eval= has some logic to check for uncaught exceptions, but
the =advance= self-hosted evaluator doesn't.

#+begin_src kcats
1 + handle error?
#+end_src

#+RESULTS:
: { stack: [], expression: [1 + handle error?] }
: { stack: [1], expression: [+ handle error?] }
: { stack: [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1], expression: [handle error?] }
: { stack: [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1], expression: [error?] }
: 
: [true 1]

#+begin_src kcats
+ handle type
#+end_src

#+RESULTS:
: 
: [error]

Looks like the word =error?= is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
=type=, which expects the builtin version of =error?=).

#+begin_src kcats
[[expression [+]]] environment eval-step 
#+end_src

#+RESULTS:
: 
: [[[stack [[[type error] [reason "not enough items on stack"] [asked [consume]]]]] [expression [+]]]]

#+begin_src kcats
[[expression [1 +]]] environment advance advance advance 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [expression [+]]]]

#+begin_src kcats
[[expression [[[3]] [+ handle] dip]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [expression [+_handle [[[3]]] unwrap]]]]

#+begin_src kcats
[[expression [+ handle]]] environment eval-step eval-step
#+end_src

#+RESULTS:
: { stack: [], expression: [[[expression [+ handle]]] environment eval-step eval-step] }
: { stack: [[[expression [+ handle]]]], expression: [environment eval-step eval-step] }
: { stack: [[[stack []] [expression [+ handle]]]], expression: [eval-step eval-step] }
: { stack: [], expression: [+ handle] }
: { stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]], expression: [eval-step] }
: { stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], expression: [+ handle] }
: 
: [[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]]

There is a problem in the design where an error (with no =handle=) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.

A possible solution is to have whatever =eval= we're using halt but
remove the =halt= bit (in the current design it's the =is_handled=
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.

Also for nested envs we need several words to help deal with errors:

+ a word that tells whether the env will halt: that there's an error
  on ToS with halt bit set, and =handle= does not appear in the
  expression. The word can efficiently return =false= if ToS isn't an
  Error.

+ A word that removes the halt bit - as the last thing to do before
  exiting.

So what about the word =advance= that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In =eval= it's pretty obvious if we
halted on error - the expression isn't empty (that's the only other
reason to stop). We could see in =advance= that the expression got
longer, but isn't very obvious in many cases.

Another possibility is letting the expression unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
=recover= is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the expression that will know what to do. But
there may not be, and the end result is a major unwind of the
expression, at least, all the way to the deepest =recover=. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on.

But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong *and*
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.

Maybe another possibility is unwinding the expression **into** the
error object. In other words, whatever expression items we lop off, we
save them in the error object, in a field named, say, =unwound= or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
expression from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
=rewind= or something, that restores the expression from the error on
ToS and clears the halt bit.

I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the expression item that threw the error so
we would still have it to retry. I'm thinking syntax like this:

#+begin_src kcats
[+] [[1 1] dip retry] recover
#+end_src

In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:

#+begin_src kcats
[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [expression [[1 1] dip retry]]]]
#+end_src

So we =dip= the numbers underneath the error, then calling =retry= on
an error will extract the =unwound= field (discarding the rest of the
error) and =execute= it. So then we end up with =1 1 +=.
*** TODO Lots of association-like objects that aren't
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait *and* make the trait object part of the
Item enum.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box<dyn Foo>), Quux(Quux) }
#+end_src

#+RESULTS:

Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar<'a> { Int(i32), Foo(&'a dyn Foo), Quux(&'a Quux) }
#+end_src

#+RESULTS:

Hm this works too, well maybe it will be fine.
*** TODO Implement my own From/TryFrom
Can't implement this on existing types. but there seems to be naming collision even if i don't implement the =std::convert::From= at all:

#+begin_src rust
pub trait SomeOther<T>: Sized {
    fn from(_: T) -> Self;
}

#[derive(Debug)]
pub struct Foo {}

impl SomeOther<String> for Foo {
    fn from(s: String) -> Foo {
        return Foo{}
    }
}



fn main() {
    let x: Foo = SomeOther::from("foo".to_string());
    println!("Foo! {:?}", x);
}

#+end_src

#+RESULTS:
: Foo! Foo

* Notes
** Bootstrapping
+ Builtin words need to exist *before* the derived words are read from
  the lexicon - so that the words in the derivation can be replaced
  with objects that are directly callable.
+ The parser for the lexicon needs to have the prebuilt builtin
  dictionary.

  So bootstrap in 2 stages:
  + read builtins.kcats that contains just specs/docs. Build a
    Dictionary. Populate the function fields with explicit code.
  + parse lexicon.cats, using the dictionary just built, replacing
    builtin words with builtin objects (I see no need to have Builtin
    as a separate struct, just use AxiomWord)

    What about string internment? the strings in builtins file should
    get interned at parse time.
    
* Code Playground
A bunch of code snippets to test things out, org-babel makes this a
piece of cake.

#+RESULTS:
: error: Could not compile `cargoVyY4IO`.

#+begin_src rust
// test swap
use std::collections::VecDeque;
type List = Vec<Item>;

type Stack = VecDeque<i32>;
#[derive(Debug)]
enum Item {
    Int(i32),
    List(List),
}

fn main(){
    use std::mem;
    let mut x = List::new();
    x.push(Item::Int(5));
    let mut y = List::new();
    y.push(Item::Int(6));
    //x.push(Item::List(y));
    mem::swap(&mut x, &mut y);
    y.push(Item::List(x));
    println!("{:?}",y);

    let mut v = Stack::new();
    v.push_front(5);
    v.push_front(6);
    println!("{:?}", v);
}

#+end_src

#+RESULTS:
: [Int(5), List([Int(6)])]
: [6, 5]

Test hash of fn
#+begin_src rust :crates
use std::collections::HashMap;
//use std::boxed::Box;
use std::rc::Rc;

struct Env {
    number: Option<i32>,
    dict: HashMap<String, Rc<dyn Fn(Env) -> Env>>
}

fn inc(i: i32) -> i32 {
    i + 1
}

struct Builtins {
    inc: fn(i32) -> i32
}

fn make_thing(f: fn(i32) -> i32) -> impl Fn(Env) -> Env {
    move | mut e: Env | {
        if let Some(n) = e.number {
            e.number = Some(f(n));
            e
        } else { e }
        
    }
}

fn main () {
    let mut dict = HashMap::<String, Rc<dyn Fn(Env) -> Env>>::new();
    let i = make_thing(inc);
    let builtins = Builtins { inc: inc };
    dict.insert("inc".to_string(), Rc::new(i));
    let mut env = Env { number: Some(12), dict: dict };
    let f = env.dict.get(&"inc".to_string()).unwrap().clone();
    println!("{}", f(env).number.unwrap());
}
#+end_src

#+RESULTS:
: 13

#+begin_src rust
use std::boxed::Box;
struct Environment {
    stack: Vec<Box<dyn Item>>
}

struct Inc {}

trait Item {
    fn onto_stack(self, env: Environment);
}

impl Item for i32 {
    fn onto_stack(self, mut env: Environment){
        env.stack.push(Box::new(self));
    }
}

impl Item for Inc {
    fn onto_stack(self, mut env: Environment) {
        
    }
    
}
  
#+end_src

destructuring
#+begin_src rust
let a = [];
let [x, y @ ..] = a;

println!("{:?}", y);
#+end_src

#+begin_src rust
use std::collections::VecDeque;

let x = VecDeque::from(vec![1, 2, 3]);
let y = &x[0..1];

println!("{}", y);

#+end_src

#+RESULTS:
: error: Could not compile `cargoewKZ71`.

experiment with single vecdeque

#+begin_src rust
use std::collections::VecDeque;

pub struct Plus {}
pub struct Inc {}

#[derive(Debug)]
pub enum Item {
    Number(i32),
    Plus,
    Inc
}
#[derive(Debug)]
pub struct Stack {
    stack: VecDeque<Item>,
    tos: usize
}

// move from expr to stack
fn push(v: &mut Stack) {
    v.stack.rotate_left(1);
    v.tos -= 1  
}
    
fn exec2(v: &mut Stack) {

    let i = v.stack.pop_back().unwrap();
    let j = v.stack.pop_back().unwrap();
    v.stack.pop_front();
    println!("exec {:?} {:?}", i, j);
    if let (Item::Number(i), Item::Number(j)) = (i, j) {
        let res = i + j;
        v.stack.push_front(Item::Number(res));
        v.tos -= 1;
    }
}
    

fn main(){
    let mut env = Stack { stack: VecDeque::new(),
                          tos: 0 };
    // load the program
    env.stack.extend(vec![Item::Number(1), Item::Number(2), Item::Number(3), Item::Plus]);
    env.tos = 4;
    //buf.push_front(Item::Plus);

    //
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    exec2(&mut env);
    println!("{:?}", env);
    println!("{:?}", env.stack.front());
    

}


#+end_src

#+RESULTS:
: Stack { stack: [Number(1), Number(2), Number(3), Plus], tos: 4 }
: Stack { stack: [Number(2), Number(3), Plus, Number(1)], tos: 3 }
: Stack { stack: [Number(3), Plus, Number(1), Number(2)], tos: 2 }
: Stack { stack: [Plus, Number(1), Number(2), Number(3)], tos: 1 }
: exec Number(3) Number(2)
: Stack { stack: [Number(5), Number(1)], tos: 0 }
: Some(Number(5))

experiment with stackexpr trait
#+begin_src rust
use std::collections::VecDeque;
pub enum Item {
    Int(i32),
    Plus,
    Inc
}

pub struct Environment {
    stack: VecDeque<Item>,
}

trait StackExpr {
    fn tos(self) -> Option<&'static Item>;
    fn toe(self) -> Option<&'static Item>;
    fn pop_stack(self) -> Option<Item>;
    fn pop_expression(self) -> Option<Item>;
    fn prepend_expression(self, l: List);
    fn append_expression(self, l: List);
    fn onto_stack(self);
}

impl StackExpr for VecDeque<T> {
    fn tos(self) -> Option<&'static Item> {
        self.as_slices().
    }
    fn toe(self) -> Option<&'static Item> {
        self.stack.front()
    }
    fn pop_stack(self) -> Option<Item> {
        self.stack.pop_back()
    }
    fn pop_expression(self) -> Option<Item> {
        let item = self.stack.pop_front();
        
    }
    fn prepend_expression(self, l: List);
    fn append_expression(self, l: List);
    fn onto_stack(self);

}
#+end_src

#+RESULTS:

#+begin_src rust
use std::collections::VecDeque;

let mut vector = VecDeque::new();

vector.push_back(0);
vector.push_back(1);
vector.push_back(2);

assert_eq!(vector.as_slices(), (&[0, 1, 2][..], &[][..]));

vector.push_front(10);
vector.push_front(9);

assert_eq!(vector.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));

let mut v = VecDeque::new();
v.push_back(1);
assert_eq!(v.as_slices(), (&[1][..], &[][..]));

#+end_src

#+RESULTS:

vec to hashmap
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;

impl<K, V> TryFrom<dyn Iterator<Item = dyn Eq>> for HashMap<K, V>
where K: Eq + Hash,
    
{
    type Error = ();

    fn try_from(v: dyn Iterator<Item = dyn Eq>) -> Result<Self, Self::Error> {
        
        HashMap::from_iter(v.map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {Err()}
        }))
    }
}

fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    let vec = vec![a, b];
    let h: HashMap<i32, i32> = HashMap::from_iter(
        vec.iter().map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {(0,0)}
        })
    );
    println!("{:?}", h);
}


#+end_src

#+RESULTS:
: error: Could not compile `cargo8MBNov`.

from reddit:
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;
#[derive(Debug)]
struct NotPairsError;

fn to_hashmap<T>(v: Vec<Vec<T>>) -> Result<HashMap<T, T>,NotPairsError>
    where T: Eq + Hash,
{
    v.iter().map(|v| match (v.get(0), v.get(1), v.get(2)) {
        (Some(k), Some(v), None) => Ok((k, v)),
        _ => Err(NotPairsError),
    }).collect()
}


fn main() {
    
    let a = vec![vec!["a", "b"], vec!["c", "d"], vec![]];

    
    println!("{:?}", to_hashmap(a));
}

#+end_src

#+RESULTS:
: error: Could not compile `cargorhVTIG`.

from reddit:

#+begin_src rust :crates '((itertools . "0.10.0"))
use itertools::Itertools;

use std::collections::HashMap;

fn into_hm<I, T, V>(iter: I) -> Result<HashMap<V, V>, String>
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    
}

trait IntoHashMap<T> {
    fn into_hashmap(self) -> Result<HashMap<T, T>, String>;
}

impl<I, T, V> IntoHashMap<V> for I
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    fn into_hashmap(self) -> Result<HashMap<V, V>, String> {
        into_hm(self.into_iter())
    }
}

fn main() {
    let v = vec![vec!["k1", "v1"], vec!["k2", "v2"]];
    println!("{:#?}", v.into_hashmap());
}
#+end_src



#+RESULTS:
: error: Could not compile `cargoTmcGbz`.

edn comment bug - doesn't parse correctly when 2nd line comment in multiline
comment is at beginning of line
#+begin_src rust :crates '((edn-format . "3.2.2"))
extern crate edn_format;

fn main() {
    println!("{:?}", edn_format::parse_str(";; abc\n;; def \n\n ced"));
}
#+end_src

#+RESULTS:
: Err(ParserErrorWithContext { context: [], row: 1, col: 2, error: UnexpectedCharacter(';') })

#+begin_src rust
use std::hash::Hash;
fn into_entry<T, K, V>(k: T, v: V) -> Result<(K, V), String>
where K: Eq + Hash
{
    match k {
        
    }
}
#+end_src

#+RESULTS:

#+begin_src rust
#[derive(Debug)]
enum Value {
    Int(i32),
    Float(f32),
    String(String)
}

#[derive(Debug)]
enum Key {
    Int(i32),
    String(String)
}

fn entry(mut l: Vec<Value>) -> Result<(Key, Value), String> {
    let v = l.pop();
    let k = l.pop();
    let e = l.pop();
    match (k, v, e) {
        (Some(k), Some(v), None) => {
            match (k) {
                Value::Int(k) => { Ok((Key::Int(k), v)) }
                _ => {Err("Key is wrong type".to_string())}
            }
            
        },
        _ => { Err("Entry must be a duple".to_string()) }
    }
}
fn main(){

    let v = vec![Value::Float(1.2), Value::Float(3.12)];
    println!("{:?}", entry(v));
    
}
#+end_src

#+RESULTS:
: Err("Key is wrong type")

testing type checking dynamic?
#+begin_src rust
use std::ops::Range;
let r = Range { start: 0, end: 5 };
let x: Vec<i32> = r.into_iter().map(|i| i+1).collect();

println!("{:?}", x)
    
#+end_src

#+RESULTS:
: [1, 2, 3, 4, 5]

#+begin_src rust
use std::any::Any;

fn main(){
    let x: [&dyn Any] = [&1, ""];
}
#+end_src

#+RESULTS:
: error: Could not compile `cargo7Clegh`.

#+begin_src kcats
[[expression [1 1 +]]] environment [[expression [1 1 +] stack
#+end_src
