#+TITLE: The kcats Programming Language (Production Implementation)
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Production implementation
** Base Language
We will use Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
** Status
Unstable
** Using
*** Dependencies
- rustc
- cargo
*** Build
Run =cargo build=, the binary will be placed in =./target/debug= by
default.
*** Run
Execute the binary: =./target/debug/kcats=. It will read a program
from stdin and execute it, then print the resulting stack.

** Project File
#+begin_src toml :tangle Cargo.toml
  [package]
  name = "kcats"
  version = "0.1.2"
  edition = "2021"

  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

  [dependencies]
  # serialization
  edn-format = "3.2.3"
  base64 = "0.13.0"

  # String literals
  internment = "0.6.0" 
  lazy_static = "1.4.0"

  num-integer = "0.1.44"

  # crypto stuff
  ed25519-dalek = {version="1", features=["batch_deterministic", "std", "rand"]}
  sha2 = "0.10.6"
  rand_core = "0.5.1" # careful here, having 2 versions present will make weird compile errors

  # multithreading
  futures = "0.3"
  tokio = { version = "1", features = ["full"] }
  # multiple-consumer channels
  #crossbeam-channel = "0.5" # doesn't support async send/recv
  #async-channel = "1.8.0"
  flume = "0.10.14"

  [dev-dependencies]
  test-case = "2.0.0"
#+end_src
** Internal data types
*** Basic internal types
We'll start by defining the basic data structures that kcats will use
internally, to keep track of things like the stack, expression, lists etc.
#+begin_src rust :tangle src/types.rs
  use crate::pipes::{In, Out, Tunnel};
  use crate::types::associative as assoc;
  use crate::types::collection as coll;
  use crate::types::dictionary as dict;
  use crate::types::environment as env;
  use crate::types::error::Error;
  use internment::Intern;
  use lazy_static::lazy_static;
  use std::collections::{HashMap, VecDeque};
  use std::fmt;
  use std::hash::Hash;
  use std::marker::Sync;
  use std::pin::Pin;
  use std::sync::Arc;

  pub mod associative;
  pub mod collection;
  pub mod dictionary;
  pub mod environment;
  pub mod error;

  pub type Word = Intern<String>;

  pub type ListContent = VecDeque<Item>;

  pub type List = Arc<ListContent>;

  pub type KeyList = VecDeque<KeyItem>;

  pub type Stack = List;

  pub type Bytes = Vec<u8>;

  pub type Int = i64;

  pub type Float = f64;

  pub type AssociationContent = HashMap<KeyItem, Item>;

  pub type Association = Arc<AssociationContent>;

  lazy_static! {
      pub static ref S_ASSOC: Intern<String> = Intern::new("association".to_string());
      pub static ref S_BOOLEAN: Intern<String> = Intern::new("boolean".to_string());
      pub static ref S_BYTES: Intern<String> = Intern::new("bytes".to_string());
      pub static ref S_ENVIRONMENT: Intern<String> = Intern::new("environment".to_string());
      pub static ref S_ERROR: Intern<String> = Intern::new("error".to_string());
      pub static ref S_FLOAT: Intern<String> = Intern::new("float".to_string());
      pub static ref S_INTEGER: Intern<String> = Intern::new("integer".to_string());
      pub static ref S_ITEM: Intern<String> = Intern::new("item".to_string());
      pub static ref S_LIST: Intern<String> = Intern::new("list".to_string());
      pub static ref S_NUMBER: Intern<String> = Intern::new("number".to_string());
      pub static ref S_PIPE: Intern<String> = Intern::new("pipe".to_string());
      pub static ref S_PROGRAM: Intern<String> = Intern::new("program".to_string());
      pub static ref S_STRING: Intern<String> = Intern::new("string".to_string());
      pub static ref S_WORD: Intern<String> = Intern::new("word".to_string());
  }

  // #[derive(Debug, Clone)]
  // pub enum Sequence {
  //     Assoc(Associative),
  //     List(ListContent),
  //     Nothing,
  // }

  #[derive(Debug, Clone)]
  pub enum Item {
      Int(Int),
      Float(Float),
      Bytes(Bytes),
      String(String),
      Word(Word),
      Assoc(assoc::Associative),
      //Seq(Sequence),
      List(List),
      Collection(coll::Collection),
      Env(env::Environment),
      Entry(dict::Entry),
      Dictionary(dict::Dictionary),
      Error(Error),
      In(In),
      Out(Out),
      Tunnel(Tunnel),
      Nothing,
  }

  #[derive(Debug, Clone, Eq, PartialEq, Hash)]
  pub enum KeyItem {
      Int(Int),
      Bytes(Bytes),
      String(String),
      Word(Word),
      List(VecDeque<KeyItem>),
      Nothing,
  }

  pub type Future<T> = Pin<Box<dyn std::future::Future<Output = T> + Send>>;
  pub type StepFn = dyn Fn(env::Environment) -> Future<env::Environment> + Sync + Send;

  impl PartialEq for Item {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              // same types, just use their own eq
              (Item::Int(a), Item::Int(b)) => a == b,
              (Item::Float(a), Item::Float(b)) => a == b,
              (Item::Bytes(a), Item::Bytes(b)) => a == b,
              (Item::String(a), Item::String(b)) => a == b,
              (Item::Word(a), Item::Word(b)) => a == b,
              (Item::Assoc(a), Item::Assoc(b)) => a == b,
              (Item::List(a), Item::List(b)) => a == b,
              //TODO: (Item::Collection(a), Item::Collection(b)) => a == b,
              (Item::Env(a), Item::Env(b)) => a == b,
              (Item::Entry(a), Item::Entry(b)) => a == b,
              (Item::Dictionary(a), Item::Dictionary(b)) => a == b,
              (Item::Error(a), Item::Error(b)) => a == b,
              //TODO:
              //(Item::In(a), Item::In(b)) => a == b,
              //(Item::Out(a), Item::Out(b)) => a == b,
              //(Item::Tunnel(a), Item::Tunnel(b)) => a == b,
              (Item::Nothing, Item::Nothing) => true,
              // different types, but can be converted to the same type
              (Item::Nothing, Item::List(l)) => l.is_empty(),
              (Item::List(l), Item::Nothing) => l.is_empty(),

              (Item::Nothing, Item::Assoc(l)) => l.is_empty(),
              (Item::Assoc(l), Item::Nothing) => l.is_empty(),

              (Item::Nothing, Item::Collection(l)) => l.is_empty(),
              (Item::Collection(l), Item::Nothing) => l.is_empty(),

              (Item::List(l), Item::Assoc(a)) => l.is_empty() && a.is_empty(),
              (Item::Assoc(a), Item::List(l)) => l.is_empty() && a.is_empty(),
              //(Item::Error(i), Item::Assoc(j)) => (*i).data == *j,
              //(Item::Assoc(i), Item::Error(j)) => (*j).data == *i,

              //TODO Definition, Associative etc
              _ => false,
          }
      }
  }

  pub fn wrap(i: Item) -> List {
      Arc::new(ListContent::from_iter([i]))
  }

  impl TryFrom<Item> for List {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::List(l) => Ok(l),
              //Item::Assoc(a) => List::try_from(Associative::Assoc(a)),
              //Item::Error(e) => List::try_from(Item::Assoc(e.data)),
              // 'Nothing' is equivalent to an empty list
              Item::Nothing => Ok(Arc::new(ListContent::new())),
              _ => Err(Error::expected("list")),
          }
      }
  }

  impl TryFrom<Item> for Int {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          if let Item::Int(i) = i {
              Ok(i)
          } else {
              Err(Error::expected("integer"))
          }
      }
  }

  impl TryFrom<Item> for Float {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          if let Item::Float(f) = i {
              Ok(f)
          } else {
              Err(Error::expected("float"))
          }
      }
  }

  impl TryFrom<Item> for String {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          if let Item::String(i) = i {
              Ok(i)
          } else {
              Err(Error::expected("string"))
          }
      }
  }

  impl TryFrom<Item> for Word {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          if let Item::Word(i) = i {
              Ok(i)
          } else {
              Err(Error::expected("word"))
          }
      }
  }

  impl TryFrom<Item> for Bytes {
      type Error = Error;
      fn try_from(b: Item) -> Result<Self, Self::Error> {
          if let Item::Bytes(b) = b {
              Ok(b)
          } else {
              Err(Error::expected("bytes"))
          }
      }
  }

  // impl TryFrom<Item> for Association {
  //     type Error = Error;
  //     fn try_from(i: Item) -> Result<Self, Self::Error> {
  //         match i {
  //             Item::Assoc(a) => Ok(a),
  //             Item::List(l) => Ok(to_hash(l)?),
  //             Item::Nothing => Ok(Arc::new(AssociationContent::new())),
  //             Item::DerivedDef(d) => Ok(Association::from(d)),
  //             Item::AxiomDef(a) => Ok(Association::from(a)),
  //             Item::Env(e) => Ok(Association::from(e)),
  //             Item::Error(e) => Ok(Association::from(e)),
  //             _ => Err(Error::expected("association")),
  //         }
  //     }
  // }

  impl TryFrom<Item> for In {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          if let Item::In(i) = i {
              Ok(i)
          } else {
              Err(Error::expected("pipe"))
          }
      }
  }

  impl TryFrom<Item> for Out {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Out(o) => Ok(o),
              _ => Err(Error::expected("pipe")),
          }
      }
  }

  impl TryFrom<KeyItem> for Word {
      type Error = Error;
      fn try_from(k: KeyItem) -> Result<Self, Self::Error> {
          match k {
              KeyItem::Word(w) => Ok(w.clone()),
              _ => Err(Error::expected("word")),
          }
      }
  }

  // As there are no real booleans, we use the word 'true' but literally
  // any value except the empty list is truthy. If we read a value
  // 'false' in edn, that's not actually a boolean, it's just the
  // symbol/word false.
  impl From<bool> for Item {
      fn from(b: bool) -> Item {
          if b {
              "true".into()
          } else {
              Item::Nothing
          }
      }
  }

  // impl From<Environment> for Association {
  //     fn from(env: Environment) -> Association {
  //         let mut a = AssociationContent::new();
  //         a.insert(word_key("stack"), Item::List(env.stack.clone()));
  //         a.insert(word_key("expression"), Item::List(env.expression.clone()));
  //         a.insert(word_key("dictionary"), Item::Assoc(env.dictionary.clone()));
  //         Arc::new(a)
  //     }
  // }

  impl From<std::io::Error> for Error {
      fn from(err: std::io::Error) -> Error {
          Error::create(wrap("io".into()), &err.to_string())
      }
  }

  impl TryFrom<Item> for KeyItem {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Error> {
          match i {
              Item::Int(i) => Ok(KeyItem::Int(i)),
              Item::String(i) => Ok(KeyItem::String(i)),
              Item::List(l) => Ok(KeyItem::List(
                  l.iter()
                      .map(|i| KeyItem::try_from(i.clone()))
                      .collect::<Result<KeyList, Error>>()?,
              )),
              Item::Word(w) => Ok(KeyItem::Word(w)),
              Item::Bytes(bs) => Ok(KeyItem::Bytes(bs)),
              Item::Nothing => Ok(KeyItem::Nothing),
              _ => Err(Error::expected("KeyItem")),
          }
      }
  }

  impl From<KeyItem> for Item {
      fn from(i: KeyItem) -> Self {
          match i {
              KeyItem::Int(i) => Item::Int(i),
              KeyItem::String(i) => Item::String(i),
              KeyItem::List(l) => Item::List(Arc::new(
                  l.iter()
                      .map(|i| Item::from(i.clone()))
                      .collect::<ListContent>(),
              )),
              KeyItem::Word(w) => Item::Word(w),
              KeyItem::Bytes(bs) => Item::Bytes(bs),
              KeyItem::Nothing => Item::Nothing,
          }
      }
  }

  impl From<&str> for KeyItem {
      fn from(i: &str) -> Self {
          KeyItem::Word(Word::from(i))
      }
  }

  impl From<&str> for Item {
      fn from(i: &str) -> Self {
          Item::Word(Word::from(i))
      }
  }

  pub fn rc_inner<T: Clone>(r: &Arc<T>) -> T {
      Arc::try_unwrap(r.clone()).unwrap_or_else(|rc| (*rc).clone())
  }
#+end_src
*** Collection types
#+begin_src rust :tangle src/types/collection.rs
  use crate::types::associative as assoc;
  use crate::types::*;

  #[derive(Debug, Clone)]
  pub enum Collection {
      Associative(assoc::Associative),
      List(List),
      //Set(Set)
      Nothing,
  }

  impl Collection {
      pub fn is_empty(&self) -> bool {
          match self {
              Collection::Associative(a) => a.is_empty(),
              Collection::List(l) => l.is_empty(),
              Collection::Nothing => true,
          }
      }
  }

  pub enum CollIntoIter {
      //TODO add other struct types
      Assoc(assoc::AssocIntoIter),
      List(std::collections::vec_deque::IntoIter<Item>),
  }

  impl Iterator for CollIntoIter {
      type Item = Item;

      fn next(&mut self) -> Option<Self::Item> {
          match self {
              CollIntoIter::Assoc(iter) => iter.next().and_then(|x| Some(x.into())),
              CollIntoIter::List(iter) => iter.next(),
          }
      }
  }

  impl IntoIterator for Collection {
      type Item = Item;
      type IntoIter = CollIntoIter;

      fn into_iter<'a>(self) -> CollIntoIter {
          match self {
              Collection::Associative(a) => CollIntoIter::Assoc(a.into_iter()),
              Collection::List(l) => CollIntoIter::List(rc_inner(&l).into_iter()),
              _ => panic!("can't iterate"),
          }
      }
  }
#+end_src
*** Associative types
#+begin_src rust :tangle src/types/associative.rs
  use crate::types::dictionary as dict;
  use crate::types::environment as env;
  use crate::types::*;

  type MapEntry = (KeyItem, Item);

  #[derive(Debug, Clone)]
  pub enum Associative {
      Assoc(Association),
      DictEntry(dict::Entry),
      Env(env::Environment),
      Error(Error),
      Dictionary(dict::Dictionary),
      Nothing,
  }

  impl PartialEq for Associative {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (Associative::Assoc(a), Associative::Assoc(b)) => a == b,
              (Associative::DictEntry(a), Associative::DictEntry(b)) => a == b,
              (Associative::Env(a), Associative::Env(b)) => a == b,
              (Associative::Error(a), Associative::Error(b)) => a == b,
              (Associative::Dictionary(a), Associative::Dictionary(b)) => a == b,
              (Associative::Nothing, Associative::Nothing) => true,
              //(Associative::Assoc(a), b) => Association::from(a) == Association::from(b),
              //(a, Associative::Assoc(b)) => Association::from(a) == Association::from(b),
              _ => false,
          }
      }
  }

  impl Associative {
      pub fn is_empty(&self) -> bool {
          match self {
              Associative::Assoc(a) => a.is_empty(),
              _ => false,
          }
      }

      pub fn insert(self, k: KeyItem, v: Item) -> (Associative, Option<Item>) {
          match self {
              Associative::Assoc(mut a) => {
                  let am = Arc::make_mut(&mut a);
                  let e = am.insert(k, v);
                  (Associative::Assoc(a), e)
              }
              Associative::Dictionary(mut d) => match (k, v) {
                  (KeyItem::Word(w), e) => {
                      let e2 = e.clone();
                      if let Ok(e) = dict::Entry::try_from(e) {
                          let dm = Arc::make_mut(&mut d);
                          let e = dm.insert(w, e).and_then(|e| Some(Item::Entry(e)));
                          (Associative::Dictionary(d), e)
                      } else {
                          // TODO silently failing to insert here is bad
                          println!("Warning, failed to insert into dictionary: {:?}", e2);
                          (Associative::Dictionary(d), None)
                      }
                  }
                  _ => (Associative::Dictionary(d), None),
              },
              _ => (Associative::Nothing, None),
          }
      }

      pub fn join(self, other: Associative) -> Associative {
          match (self, other) {
              // same type means 2nd one wins.
              //TODO: a little more complex for types that can be extended
              (Associative::DictEntry(_), Associative::DictEntry(other)) => {
                  Associative::DictEntry(other)
              }
              (Associative::Dictionary(mut this), Associative::Dictionary(other)) => {
                  let thism = Arc::make_mut(&mut this);
                  thism.extend(rc_inner(&other).into_iter());
                  Associative::Dictionary(this)
              }
              (Associative::Error(_), Associative::Error(other)) => Associative::Error(other),
              (Associative::Env(_), Associative::Env(other)) => Associative::Env(other),
              (Associative::Nothing, Associative::Nothing) => Associative::Nothing,
              (Associative::Assoc(mut this), other) => {
                  let thism = Arc::make_mut(&mut this);
                  thism.extend(other.into_iter());
                  Associative::Assoc(this)
              }
              (this, other) => {
                  let thisa: Association = this.into();
                  (Associative::Assoc(thisa)).join(other)
              }
          }
      }

      pub fn get(&self, k: &KeyItem) -> Option<Item> {
          match self {
              Associative::Assoc(a) => a.get(k).and_then(|x| Some(x.clone())),
              Associative::Error(e) => e.data.get(k).and_then(|x| Some(x.clone())),
              Associative::Env(e) => match k {
                  KeyItem::Word(s) => match s.as_str() {
                      "stack" => Some(Item::List(e.stack.clone())),
                      "expression" => Some(Item::List(e.expression.clone())),
                      "dictionary" => Some(Item::Dictionary(e.dictionary.clone())),
                      _ => None,
                  },
                  _ => None,
              },
              Associative::DictEntry(d) => match k {
                  KeyItem::Word(s) => match s.as_str() {
                      "spec" => d.spec.clone().and_then(|x| Some(Item::List(x))),
                      "examples" => d.examples.clone().and_then(|x| Some(Item::List(x))),
                      "definition" => Some(match d.definition.clone() {
                          dict::Definition::Axiom(_) => "builtin".into(),
                          dict::Definition::Derived(d) => Item::List(d),
                      }),
                      _ => None,
                  },
                  _ => None,
              },
              Associative::Dictionary(d) => match k {
                  KeyItem::Word(w) => d.get(w).and_then(|x| Some(Item::Entry(x.clone()))),
                  _ => None,
              },
              _ => None,
          }
      }

      //TODO remove
      pub fn remove(self, k: &KeyItem) -> (Associative, Option<Item>) {
          match self {
              Associative::Assoc(mut a) => {
                  let am = Arc::make_mut(&mut a);
                  let v = am.remove(k);
                  (Associative::Assoc(a), v)
              }
              _ => (Associative::Nothing, None),
          }
      }
  }

  impl TryFrom<Item> for MapEntry {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Error> {
          match i {
              Item::List(mut l) => {
                  if l.len() != 2 {
                      Err(Error::expected("List[2]"))
                  } else {
                      let lm = Arc::make_mut(&mut l);
                      let v = lm.pop_back();
                      let k = lm.pop_back();
                      let e = lm.pop_back();
                      match (k, v, e) {
                          (Some(k), Some(v), None) => Ok((KeyItem::try_from(k)?, v)),
                          _ => Err(Error::expected("List[2]")),
                      }
                  }
              }
              _ => Err(Error::expected("list")),
          }
      }
  }

  pub enum AssocIntoIter {
      //TODO add other struct types
      Assoc(std::collections::hash_map::IntoIter<KeyItem, Item>),
      DictEntry(std::vec::IntoIter<MapEntry>),
      Dictionary(
          std::iter::Map<
              std::collections::hash_map::IntoIter<Word, dict::Entry>,
              fn((Word, dict::Entry)) -> MapEntry,
          >,
      ),
  }

  impl Iterator for AssocIntoIter {
      type Item = MapEntry;

      fn next(&mut self) -> Option<Self::Item> {
          match self {
              AssocIntoIter::Assoc(iter) => iter.next(),
              AssocIntoIter::DictEntry(iter) => iter.next(),
              AssocIntoIter::Dictionary(iter) => iter.next(),
          }
      }
  }

  impl IntoIterator for Associative {
      type Item = MapEntry;
      type IntoIter = AssocIntoIter;

      fn into_iter<'a>(self) -> AssocIntoIter {
          match self {
              Associative::Assoc(a) => AssocIntoIter::Assoc(rc_inner(&a).into_iter()),
              Associative::DictEntry(e) => {
                  let mut v: Vec<MapEntry> = vec![("definition".into(), {
                      match e.definition {
                          dict::Definition::Derived(l) => Item::List(l),
                          dict::Definition::Axiom(_) => "builtin-function".into(),
                      }
                  })];
                  if let Some(e) = e.examples {
                      v.push(("examples".into(), Item::List(e)));
                  }
                  if let Some(s) = e.spec {
                      v.push(("spec".into(), Item::List(s)))
                  }
                  AssocIntoIter::DictEntry(v.into_iter())
              }
              Associative::Dictionary(d) => AssocIntoIter::Dictionary(
                  rc_inner(&d)
                      .into_iter()
                      .map(|(w, e)| (KeyItem::Word(w), Item::Entry(e))),
              ),
              _ => panic!("can't iterate"),
          }
      }
  }

  impl TryFrom<Associative> for List {
      type Error = Error;
      fn try_from(a: Associative) -> Result<Self, Self::Error> {
          Ok(Arc::new(
              a.into_iter().map(|x| x.into()).collect::<ListContent>(),
          ))
      }
  }

  impl TryFrom<Item> for Associative {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Error> {
          match i {
              Item::Assoc(a) => Ok(a),
              Item::Error(e) => Ok(Associative::Error(e)),
              Item::List(l) => Ok(Associative::Assoc(Arc::new(
                  rc_inner(&l)
                      .into_iter()
                      .map(|i| i.try_into())
                      .collect::<Result<HashMap<KeyItem, Item>, Error>>()?,
              ))),
              Item::Env(e) => Ok(Associative::Env(e)),
              Item::Entry(e) => Ok(Associative::DictEntry(e)),
              Item::Dictionary(d) => Ok(Associative::Dictionary(d)),
              i => Err(Error::expected(
                  format!("association (unfinished tryfrom impl) {:?}", i).as_str(),
              )),
          }
      }
  }

  impl TryFrom<List> for Associative {
      type Error = Error;
      fn try_from(l: List) -> Result<Self, Error> {
          Ok(Associative::Assoc(Arc::new(
              l.iter()
                  .map(|i| MapEntry::try_from(i.clone()))
                  .collect::<Result<HashMap<KeyItem, Item>, Error>>()?,
          )))
      }
  }

  impl From<(KeyItem, Item)> for Item {
      fn from((k, v): (KeyItem, Item)) -> Item {
          Item::List(Arc::new(ListContent::from(vec![
              Item::from(k.clone()),
              Item::from(v.clone()),
          ])))
      }
  }

  impl From<Associative> for Association {
      fn from(a: Associative) -> Association {
          match a {
              Associative::Assoc(a) => a,
              a => Arc::new(AssociationContent::from_iter(a.into_iter())),
          }
      }
  }
#+end_src
*** Error types
#+begin_src rust :tangle src/types/error.rs
  use crate::types;
  use crate::types::associative as assoc;
  use crate::types::{Association, Int, Item, KeyItem, List, ListContent, Word};
  use std::collections::HashMap;
  use std::sync::Arc;

  #[derive(Clone, PartialEq)]
  pub struct Error {
      pub data: Association,
      pub is_handled: bool,
  }

  impl Error {
      pub fn create(asked: List, reason: &str) -> Error {
          Error {
              is_handled: false,
              data: Arc::new(HashMap::from([
                  ("type".into(), "error".into()),
                  ("asked".into(), Item::List(asked)),
                  ("reason".into(), Item::String(reason.to_string())),
              ])),
          }
      }

      pub fn stack_underflow() -> Error {
          Error::create(types::wrap("consume".into()), "not enough items on stack")
      }

      pub fn undefined(w: Word) -> Error {
          Error::create(types::wrap(Item::Word(w)), "word is not defined")
      }

      pub fn type_mismatch(asked: List) -> Error {
          Error::create(asked, "type mismatch")
      }

      pub fn division_by_zero() -> Error {
          Error::create(types::wrap("/".into()), "division by zero")
      }

      pub fn expected(typestr: &str) -> Error {
          Error::type_mismatch(types::wrap(typestr.into()))
      }

      pub fn short_list(expected: Int) -> Error {
          Error::create(
              Arc::new(ListContent::from_iter([
                  "count".into(),
                  Item::Int(expected),
                  ">=".into(),
              ])),
              "list had too few items",
          )
      }

      pub fn list_count(expected: Int) -> Error {
          Error::create(
              Arc::new(ListContent::from_iter([
                  "count".into(),
                  Item::Int(expected),
                  "=".into(),
              ])),
              "list had wrong number of items",
          )
      }

      pub fn parse(reason: &str) -> Error {
          Error::create(types::wrap("read".into()), reason)
      }

      pub fn test_assertion(program: List, expected: List, actual: List) -> Error {
          let mut e = Error::create(program, "assertion failed");
          let d = Arc::make_mut(&mut e.data);
          d.insert("expected".into(), Item::List(expected));
          d.insert("actual".into(), Item::List(actual));
          return e;
      }
  }

  impl From<Error> for Association {
      fn from(e: Error) -> Association {
          e.data
      }
  }

  impl TryFrom<Item> for Error {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::List(l) => Item::Assoc(assoc::Associative::try_from(l)?).try_into(),
              Item::Error(e) => Ok(e),
              Item::Assoc(a) => a.try_into(),
              _ => Err(Error::expected("error")),
          }
      }
  }

  impl TryFrom<assoc::Associative> for Error {
      type Error = Error;
      fn try_from(a: assoc::Associative) -> Result<Self, Self::Error> {
          match a {
              assoc::Associative::Error(e) => Ok(e),
              assoc::Associative::Assoc(a) => {
                  if a.get(&KeyItem::from("type")) != Some(&Item::from("error")) {
                      Err(Error::expected("error"))
                  } else {
                      Ok(Error {
                          data: a.clone(),
                          is_handled: true,
                      })
                  }
              }
              _ => Err(Error::expected("error")),
          }
      }
  }
#+end_src
*** Dictionary types
#+begin_src rust :tangle src/types/dictionary.rs
  use crate::types::associative as assoc;
  use crate::types::associative::Associative;
  use crate::types::*;

  #[derive(Debug, Clone)]
  pub struct Entry {
      pub examples: Option<List>,
      pub spec: Option<List>,
      pub definition: Definition,
  }

  pub type Dictionary = Arc<HashMap<Word, Entry>>;

  #[derive(Clone)]
  pub enum Definition {
      Axiom(&'static StepFn),
      Derived(List),
  }

  impl PartialEq for Definition {
      fn eq(&self, _: &Self) -> bool {
          // TODO actually implement this
          true
      }
  }

  // dictionary entries are equal if they have the same function reference,
  // no need to compare the function values
  impl PartialEq for Entry {
      fn eq(&self, other: &Self) -> bool {
          self.definition == other.definition
              && self.examples == other.examples
              && self.spec == other.spec
      }
  }

  impl fmt::Debug for Definition {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          match self {
              Definition::Axiom(_) => f.write_str("Builtin"),
              Definition::Derived(d) => {
                  let mut ds = f.debug_list();
                  ds.entries(d.iter());
                  ds.finish()
              }
          }
      }
  }

  impl TryFrom<Item> for Entry {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Entry(e) => Ok(e),
              Item::Assoc(a) => a.try_into(),
              Item::List(l) => Associative::try_from(l).and_then(|a| a.try_into()),
              e => Err(Error::expected(format!("Definition, got {:?}", e).as_str())),
          }
      }
  }

  impl From<Entry> for Associative {
      fn from(d: Entry) -> Associative {
          let mut a = AssociationContent::new();
          d.examples
              .and_then(|l| a.insert("examples".into(), Item::List(l.clone())));
          d.spec
              .and_then(|l| a.insert("spec".into(), Item::List(l.clone())));
          match d.definition {
              Definition::Derived(d) => {
                  a.insert("definition".into(), Item::List(d.clone()));
              }
              _ => {}
          }
          Associative::Assoc(Arc::new(a))
      }
  }

  impl TryFrom<Associative> for Entry {
      type Error = Error;
      fn try_from(d: Associative) -> Result<Self, Error> {
          // TODO: This should handle cases where there's no def present
          // and return error
          let (d, def) = d.remove(&"definition".into());
          let (d, examples) = d.remove(&"examples".into());
          let (_, spec) = d.remove(&"spec".into());

          Ok(Entry {
              definition: if let Some(d) = def {
                  Definition::Derived(List::try_from(d).unwrap())
              } else {
                  //Err(Error::expected("definition field"))?  use a
                  // dummy value, presumably if this is during
                  // bootstrap,the definition will be replaced later.
                  Definition::Derived(Arc::new(ListContent::new()))
              },

              // {Box::leak(Box::new(move |env: Environment| {
              //    env.push(Item::Error(Error::undefined(w)))
              //}))}
              examples: examples.and_then(|i| List::try_from(i).ok()),
              spec: spec.and_then(|i| List::try_from(i).ok()),
          })
      }
  }

  impl TryFrom<List> for Entry {
      type Error = Error;
      fn try_from(l: List) -> Result<Self, Error> {
          let a: Associative = l.try_into()?;
          a.try_into()
      }
  }

  impl TryFrom<assoc::Associative> for Dictionary {
      type Error = Error;
      fn try_from(a: assoc::Associative) -> Result<Self, Self::Error> {
          match a {
              assoc::Associative::Dictionary(e) => Ok(e),
              assoc::Associative::Assoc(a) => {
                  let h = rc_inner(&a)
                      .into_iter()
                      .map(|(k, v)| {
                          let e: (Word, Entry) = (k.try_into()?, v.try_into()?);
                          Ok(e)
                      })
                      .collect::<Result<HashMap<Word, Entry>, Error>>()?;
                  Ok(Arc::new(h))
              }
              _ => Err(Error::expected("dictionary")),
          }
      }
  }

  impl From<Dictionary> for assoc::Associative {
      fn from(d: Dictionary) -> Self {
          Associative::Assoc(Arc::new(
              rc_inner(&d)
                  .into_iter()
                  .map(|(k, v)| (KeyItem::Word(k), Item::Entry(v)))
                  .collect(),
          ))
      }
  }

  impl TryFrom<Item> for Dictionary {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Dictionary(d) => Ok(d),
              Item::Assoc(a) => a.try_into(),
              Item::List(l) => Associative::try_from(l).and_then(|a| a.try_into()),
              _ => Err(Error::expected("dictionary")),
          }
      }
  }
#+end_src
*** Environment types
#+begin_src rust :tangle src/types/environment.rs
  use crate::axiom;
  use crate::types::associative::Associative;
  use crate::types::dictionary as dict;
  use crate::types::*;
  use std::future;

  #[derive(Clone, PartialEq)]
  pub struct Environment {
      pub stack: Stack,
      pub expression: Stack,
      pub dictionary: dict::Dictionary,
  }

  impl Environment {
      pub fn push(mut self, i: Item) -> Environment {
          Arc::make_mut(&mut self.stack).push_front(i);
          self
      }

      pub fn pop(&mut self) -> Item {
          Arc::make_mut(&mut self.stack).pop_front().unwrap()
      }

      pub fn push_expr(mut self, i: Item) -> Environment {
          Arc::make_mut(&mut self.expression).push_front(i);
          self
      }

      pub fn pop_expr(&mut self) -> Item {
          Arc::make_mut(&mut self.expression).pop_front().unwrap()
      }

      pub fn append_expression(mut self, items: List) -> Environment {
          let expr = Arc::make_mut(&mut self.expression);
          let ct = expr.len();
          expr.append(Arc::make_mut(&mut items.clone()));
          expr.rotate_left(ct);
          self
      }

      pub fn tos<'a>(&'a self) -> Option<&'a Item> {
          self.stack.front()
      }
  }

  impl From<Associative> for Environment {
      fn from(envm: Associative) -> Self {
          let (envm, stack) = envm.remove(&"stack".into());
          let (envm, expression) = envm.remove(&"expression".into());
          let (_, dictionary) = envm.remove(&"dictionary".into());
          let stack = stack
              .and_then(|s| List::try_from(s).ok())
              .or(Some(List::new(ListContent::new())));
          let expression = expression
              .and_then(|s| List::try_from(s).ok())
              .or(Some(List::new(ListContent::new())));
          let dictionary = dictionary.and_then(|d| {
              Associative::try_from(d)
                  .and_then(|d| dict::Dictionary::try_from(d))
                  .ok()
          });
          let mut env = axiom::standard_env(expression, stack);
          if let Some(d) = dictionary {
              let edmut = Arc::make_mut(&mut env.dictionary);
              edmut.extend(rc_inner(&d).into_iter());
          }
          env
      }
  }

  impl TryFrom<Item> for Environment {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Env(e) => Ok(e),
              Item::List(l) => {
                  let a: Associative = l.try_into()?;
                  Ok(a.into())
              }
              Item::Assoc(a) => Ok(a.into()),
              _ => Err(Error::expected("environment")),
          }
      }
  }

  impl From<Environment> for Item {
      fn from(env: Environment) -> Item {
          Item::Env(Environment::from(env))
      }
  }

  impl From<Environment> for Future<Environment> {
      fn from(env: Environment) -> Future<Environment> {
          Box::pin(future::ready(env))
      }
  }
#+end_src
*** Cryptographic primitives
We'll implement certain cryptography functions in rust and make kcats
words for them (hashing, encryption, signing)
#+begin_src rust :tangle src/crypto.rs
  use crate::axiom::ItemResult;
  use crate::types::{associative::Associative, error::Error, AssociationContent, Bytes, Item};
  use core::ops::Deref;
  use ed25519_dalek as signing;
  use ed25519_dalek::{Signer, Verifier};
  use rand_core;
  use rand_core::{CryptoRng, RngCore};
  use sha2::{self, Digest};
  use std::sync::Arc;

  pub fn hash(i: Item) -> ItemResult {
      let b = Bytes::try_from(i).unwrap();
      Ok(Item::Bytes(sha2::Sha256::digest(b).deref().to_vec()))
  }

  type Value = Vec<u8>;

  pub struct SeededRNG {
      seed: Value,
      salt: Value,
  }

  impl SeededRNG {
      // Hash of seed|value
      fn hash(&self) -> Vec<u8> {
          let mut v = self.seed.clone();
          v.extend(self.salt.clone());
          sha2::Sha256::digest(v.as_slice()).deref().to_vec()
      }
  }

  impl RngCore for SeededRNG {
      fn next_u32(&mut self) -> u32 {
          rand_core::impls::next_u32_via_fill(self)
      }

      fn next_u64(&mut self) -> u64 {
          rand_core::impls::next_u64_via_fill(self)
      }

      fn fill_bytes(&mut self, dest: &mut [u8]) {
          let l = dest.len();
          dest.copy_from_slice(&self.hash()[..l]);
      }

      fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
          self.fill_bytes(dest);
          Ok(())
      }
  }

  impl CryptoRng for SeededRNG {}

  pub fn key(seed: Item) -> ItemResult {
      let sbs: Bytes = seed.try_into()?;
      let kp = signing::Keypair::generate(&mut SeededRNG {
          seed: vec![],
          salt: sbs,
      });
      let mut keypair = AssociationContent::new();
      keypair.insert("type".into(), "elliptic-curve-key".into());
      keypair.insert("secret".into(), Item::Bytes(kp.secret.as_ref().to_vec()));
      keypair.insert("public".into(), Item::Bytes(kp.public.as_ref().to_vec()));
      Ok(Item::Assoc(Associative::Assoc(Arc::new(keypair))))
  }

  impl TryFrom<Item> for signing::Keypair {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let sk: signing::SecretKey = i.try_into()?;
          let pk: signing::PublicKey = (&sk).into();
          Ok(signing::Keypair {
              secret: sk,
              public: pk,
          })
      }
  }

  impl TryFrom<Item> for signing::SecretKey {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Assoc(a) => {
                  if a.get(&"type".into()) == Some("elliptic-curve-key".into()) {
                      let sk = signing::SecretKey::from_bytes(
                          &Bytes::try_from(
                              a.get(&"secret".into())
                                  .ok_or_else(|| Error::expected("secret"))?,
                          )?[..],
                      )
                      .map_err(|_e| Error::expected("valid-secret-key"))?;
                      Ok(sk)
                  } else {
                      Err(Error::expected("keypair"))
                  }
              }
              _ => Err(Error::expected("keypair")),
          }
      }
  }

  impl TryFrom<Item> for signing::PublicKey {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Assoc(a) => {
                  if a.get(&"type".into()) == Some("elliptic-curve-key".into()) {
                      let pk = signing::PublicKey::from_bytes(
                          &Bytes::try_from(
                              a.get(&"public".into())
                                  .ok_or_else(|| Error::expected("public"))?,
                          )?[..],
                      )
                      .map_err(|_e| Error::expected("valid-public-key"))?;
                      Ok(pk)
                  } else {
                      Err(Error::expected("public-key"))
                  }
              }
              _ => Err(Error::expected("public-key")),
          }
      }
  }
  //TODO: we can only call sign from a keypair, so we may want to assume
  // that we have either the kp, or just the secret key.
  pub fn sign(k: Item, m: Item) -> ItemResult {
      let kp: signing::Keypair = k.try_into()?;
      let message: Bytes = m.try_into()?;
      let signature: signing::Signature = kp.sign(&message);
      Ok(Item::Bytes(signature.as_ref().to_vec()))
  }

  pub fn verify(k: Item, m: Item, s: Item) -> ItemResult {
      let pk: signing::PublicKey = k.try_into()?;
      let mbs: Bytes = m.try_into()?;
      let sbs: Bytes = s.try_into()?;
      let sig = signing::Signature::from_bytes(&sbs).map_err(|_e| Error::expected("signature"))?;
      pk.verify(&mbs, &sig)
          .and(Ok(Item::from(true)))
          .or(Ok(Item::Nothing))
  }
#+end_src
** Serialization
We'll define how kcats data structure are parsed and written (for
example, in order to read/write to/from disk).
#+begin_src rust :tangle src/serialize.rs
  extern crate edn_format;
  use crate::types::associative::Associative;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::*;
  use base64;
  use std::collections::VecDeque;
  use std::fmt;
  use std::sync::Arc;

  pub trait Display {
      fn representation(&self) -> Item;
  }

  const BYTE_TAG: &str = "b64";

  fn to_item(item: &edn_format::Value) -> Result<Item, Error> {
      //println!("to item {:?}", item);
      match item {
          edn_format::Value::Integer(i) => Ok(Item::Int(*i)),
          edn_format::Value::Vector(v) => Ok(Item::List(Arc::new(
              v.iter()
                  .map(|i| to_item(i))
                  .collect::<Result<VecDeque<Item>, Error>>()?,
          ))),
          edn_format::Value::Symbol(s) => Ok(Item::Word(s.to_string().into())),
          // we don't have booleans in kcats, so if we see 'false' that
          // is the word false which is not defined in the base
          // language, but might be user-defined later.
          edn_format::Value::Boolean(b) => Ok(if *b { "true".into() } else { "false".into() }),
          edn_format::Value::String(s) => Ok(Item::String(s.to_string())),
          edn_format::Value::Float(f) => Ok(Item::Float(f.into_inner())),
          edn_format::Value::TaggedElement(tag, e) => {
              if *tag == edn_format::Symbol::from_name(BYTE_TAG) {
                  if let edn_format::Value::String(s) = &**e {
                      Ok(Item::Bytes(base64::decode(s).unwrap()))
                  } else {
                      Err(Error::parse("Invalid tag datatype for byte literal"))
                  }
              } else {
                  Err(Error::parse("Unsupported tag"))
              }
          }
          _ => Err(Error::parse("Unsupported data literal")),
      }
  }

  pub fn vectorize(a: Associative) -> Vec<edn_format::Value> {
      a.into_iter()
          .map(|(k, v)| {
              edn_format::Value::Vector(vec![from_item(&Item::from(k.clone())), from_item(&v)])
          })
          .collect()
  }

  pub fn from_item(item: &Item) -> edn_format::Value {
      match item {
          Item::Int(i) => edn_format::Value::Integer(*i),
          Item::List(v) => edn_format::Value::Vector(
              v.iter()
                  .map(|i| from_item(i))
                  .collect::<Vec<edn_format::Value>>(),
          ),

          Item::Collection(v) => edn_format::Value::Vector(
              v.clone()
                  .into_iter()
                  .map(|i| from_item(&i))
                  .collect::<Vec<edn_format::Value>>(),
          ),
          Item::Word(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
          //Item::Entry(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(&w.word)),
          Item::String(s) => edn_format::Value::String(s.to_string()),
          Item::Float(f) => edn_format::Value::from(*f),
          Item::Bytes(bs) => edn_format::Value::TaggedElement(
              edn_format::Symbol::from_name("b64"),
              Box::new(edn_format::Value::String(base64::encode(bs))),
          ),
          Item::Assoc(h) => edn_format::Value::Vector(vectorize(h.clone())),
          Item::Error(err) => {
              edn_format::Value::Vector(vectorize(Associative::Assoc(err.data.clone())))
          }
          Item::Env(e) => edn_format::Value::Vector(vec![
              edn_format::Value::Vector(vec![
                  from_item(&"stack".into()),
                  from_item(&Item::List(e.stack.clone())),
              ]),
              edn_format::Value::Vector(vec![
                  from_item(&"expression".into()),
                  from_item(&Item::List(e.expression.clone())),
              ]),
              // TODO emit the non-builtin words of the dictionary
          ]),
          Item::Nothing => edn_format::Value::Vector(Vec::new()),
          Item::Dictionary(d) => from_item(&Item::Assoc(Associative::from(d.clone()))),
          Item::Entry(d) => {
              let a: Associative = (*d).clone().into();
              from_item(&Item::Assoc(a))
          }
          Item::In(i) => from_item(&i.representation()),
          Item::Out(i) => from_item(&i.representation()),
          Item::Tunnel(i) => from_item(&i.representation()),
      }
  }

  pub fn parse(s: String) -> Result<List, Error> {
      let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
      Ok(Arc::new(
          parser
              .map(move |r| match r {
                  Ok(expr) => Ok(to_item(&expr)?),
                  Err(_) => Err(Error::parse("Invalid edn")),
              })
              .collect::<Result<ListContent, Error>>()?,
      ))
  }

  pub fn to_list(s: &str) -> List {
      parse(s.to_string()).unwrap()
  }

  pub fn emit(item: &Item) -> String {
      edn_format::emit_str(&from_item(item))
  }

  pub fn emit_all(items: &VecDeque<Item>) -> String {
      let mut s: String = String::new();
      for i in items {
          s.push_str(&emit(&i));
          s.push_str(" ".into());
      }
      s.pop();
      return s;
  }

  // print out envs in error messages
  impl fmt::Debug for Environment {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(
              f,
              "{{ stack: {}, expression: {} }}",
              emit(&Item::List(self.stack.clone())),
              emit(&Item::List(self.expression.clone())),
          )
      }
  }

  impl fmt::Debug for Error {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(
              f,
              "{}",
              emit(&Item::Assoc(Associative::Assoc(self.data.clone())))
          )
      }
  }
#+end_src
** Builtin words
We'll define some words as axioms (not in terms of other words, only defined in Rust). 
#+begin_src rust :tangle src/axiom.rs
  use super::serialize;
  use crate::types::associative::Associative;
  use crate::types::collection as coll;
  use crate::types::dictionary as dict;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::*;

  use futures::future::FutureExt;
  use num_integer::Roots;
  use std::collections::HashMap;
  use std::collections::VecDeque;
  use std::fs;
  //use std::future::Future;
  use std::mem;
  use std::ops::Range;
  use std::sync::Arc;

  pub type ItemResult = Result<Item, Error>;

  impl From<ItemResult> for Item {
      fn from(i: ItemResult) -> Self {
          match i {
              Ok(i) => i,
              Err(e) => Item::Error(e),
          }
      }
  }

  fn f_stack1(f: fn(Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          env.push(Item::from(f(x))).into()
      }
  }

  fn f_stack2(f: fn(Item, Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          env.push(Item::from(f(y, x))).into()
      }
  }

  fn f_stack3(f: fn(Item, Item, Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          let z = env.pop();
          env.push(Item::from(f(z, y, x))).into()
      }
  }

  fn f_stack1_async(
      f: fn(Item) -> Future<ItemResult>,
  ) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          Box::pin(f(x).map(|r| env.push(Item::from(r))))
      }
  }

  fn f_stack2_async(
      f: fn(Item, Item) -> Future<ItemResult>,
  ) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          Box::pin(f(x, y).map(|r| env.push(Item::from(r))))
      }
  }

  fn update_axiom_entries(
      mut d: dict::Dictionary,
      updates: Vec<(&str, &'static StepFn)>,
  ) -> dict::Dictionary {
      let dm = Arc::make_mut(&mut d);
      for (w, f) in updates {
          dm.entry(Word::from(w)).and_modify(|e| {
              e.definition = dict::Definition::Axiom(f);
          });
      }
      d
  }

  pub fn add_builtins(d: dict::Dictionary) -> dict::Dictionary {
      update_axiom_entries(
          d,
          vec![
              ("*", Box::leak(Box::new(f_stack2(mult)))),
              ("+", Box::leak(Box::new(f_stack2(plus)))),
              ("++lookup", Box::leak(Box::new(f_stack2(lookup)))),
              ("-", Box::leak(Box::new(f_stack2(minus)))),
              ("/", Box::leak(Box::new(f_stack2(div)))),
              ("<", Box::leak(Box::new(f_stack2(lt)))),
              ("<=", Box::leak(Box::new(f_stack2(lte)))),
              ("=", Box::leak(Box::new(f_stack2(eq)))),
              (">", Box::leak(Box::new(f_stack2(gt)))),
              (">=", Box::leak(Box::new(f_stack2(gte)))),
              ("abs", Box::leak(Box::new(f_stack1(abs)))),
              ("and", Box::leak(Box::new(f_stack2(and)))),
              ("animate", Box::leak(Box::new(animate))),
              ("assign", Box::leak(Box::new(f_stack3(assign)))),
              ("association", Box::leak(Box::new(f_stack1(association)))),
              (
                  "association?",
                  Box::leak(Box::new(f_stack1(is_association))),
              ),
              ("branch", Box::leak(Box::new(branch))),
              ("bytes", Box::leak(Box::new(f_stack1(bytes)))),
              ("bytes?", Box::leak(Box::new(f_stack1(is_bytes)))),
              ("clone", Box::leak(Box::new(clone))),
              (
                  "close",
                  Box::leak(Box::new(f_stack1_async(crate::pipes::close))),
              ),
              ("ceil", Box::leak(Box::new(f_stack1(ceil)))),
              (
                  "closed?",
                  Box::leak(Box::new(f_stack1_async(crate::pipes::is_closed))),
              ),
              ("count", Box::leak(Box::new(f_stack1(count)))),
              ("dec", Box::leak(Box::new(f_stack1(dec)))),
              ("decide", Box::leak(Box::new(decide))),
              ("dip", Box::leak(Box::new(dip))),
              ("dictionary", Box::leak(Box::new(dictionary))),
              ("dipdown", Box::leak(Box::new(dipdown))),
              ("discard", Box::leak(Box::new(discard))),
              ("environment", Box::leak(Box::new(f_stack1(environment)))),
              ("error?", Box::leak(Box::new(f_stack1(is_error)))),
              ("eval-step", Box::leak(Box::new(eval_step_outer))),
              ("evaluate", Box::leak(Box::new(evaluate))),
              ("even?", Box::leak(Box::new(f_stack1(is_even)))),
              ("evert", Box::leak(Box::new(evert))),
              ("execute", Box::leak(Box::new(execute))),
              ("fail", Box::leak(Box::new(f_stack1(fail)))),
              (
                  "file-in",
                  Box::leak(Box::new(f_stack1(crate::pipes::fs::file_in))),
              ),
              (
                  "file-out",
                  Box::leak(Box::new(f_stack1(crate::pipes::fs::file_out))),
              ),
              ("filled", Box::leak(Box::new(crate::pipes::channel::filled))),
              ("first", Box::leak(Box::new(f_stack1(first)))),
              ("float", Box::leak(Box::new(float))),
              ("handle", Box::leak(Box::new(f_stack1(handle)))),
              (
                  "handoff",
                  Box::leak(Box::new(crate::pipes::channel::handoff)),
              ),
              ("hash", Box::leak(Box::new(f_stack1(crate::crypto::hash)))),
              ("inc", Box::leak(Box::new(f_stack1(inc)))),
              ("join", Box::leak(Box::new(f_stack2(join)))),
              ("key", Box::leak(Box::new(f_stack1(crate::crypto::key)))),
              ("list?", Box::leak(Box::new(f_stack1(is_list)))),
              ("loop", Box::leak(Box::new(loop_))),
              ("mod", Box::leak(Box::new(f_stack2(mod_)))),
              ("not", Box::leak(Box::new(f_stack1(not)))),
              ("number?", Box::leak(Box::new(f_stack1(is_number)))),
              ("odd?", Box::leak(Box::new(f_stack1(is_odd)))),
              ("or", Box::leak(Box::new(f_stack2(or)))),
              ("pack", Box::leak(Box::new(f_stack2(pack)))),
              ("pipe?", Box::leak(Box::new(f_stack1(is_pipe)))),
              ("put", Box::leak(Box::new(crate::pipes::put_))),
              ("range", Box::leak(Box::new(range))),
              ("read", Box::leak(Box::new(read))),
              ("recur", Box::leak(Box::new(recur))),
              ("redefine", Box::leak(Box::new(redefine))),
              ("rest", Box::leak(Box::new(f_stack1(rest)))),
              ("resume", Box::leak(Box::new(identity))),
              ("reverse", Box::leak(Box::new(f_stack1(reverse)))),
              ("second", Box::leak(Box::new(f_stack1(second)))),
              (
                  "serversocket",
                  Box::leak(Box::new(f_stack2_async(crate::pipes::net::server_socket))),
              ),
              ("sign", Box::leak(Box::new(f_stack2(crate::crypto::sign)))),
              ("sink", Box::leak(Box::new(sink))),
              ("sqrt", Box::leak(Box::new(f_stack1(sqrt)))),
              ("step", Box::leak(Box::new(step))),
              ("string", Box::leak(Box::new(f_stack1(string)))),
              ("string?", Box::leak(Box::new(f_stack1(is_string)))),
              ("swap", Box::leak(Box::new(swap))),
              ("swapdown", Box::leak(Box::new(swapdown))),
              ("take", Box::leak(Box::new(crate::pipes::take_))),
              ("true", Box::leak(Box::new(true_))),
              ("unassign", Box::leak(Box::new(f_stack2(unassign)))),
              ("unpack", Box::leak(Box::new(unpack))),
              ("unwrap", Box::leak(Box::new(unwrap))),
              (
                  "verify",
                  Box::leak(Box::new(f_stack3(crate::crypto::verify))),
              ),
              ("word?", Box::leak(Box::new(f_stack1(is_word)))),
              ("wrap", Box::leak(Box::new(wrap))),
              ("zero?", Box::leak(Box::new(f_stack1(is_zero)))),
          ],
      )
  }

  pub fn read_lexicon_file(filename: &str, mut env: Environment) -> Environment {
      match fs::read_to_string(filename) {
          Ok(s) => {
              let items = serialize::parse(s).unwrap();
              let vitems: Associative = List::from(items).try_into().unwrap();
              //println!("Items {:?}", vitems);

              //let vitemsmut = Arc::make_mut(&mut vitems);
              for (k, def) in vitems.into_iter() {
                  //println!("Reading {:?}", k);
                  let h: Associative = List::try_from(def.clone()).unwrap().try_into().unwrap();
                  let word: Word = k.try_into().unwrap();
                  let newdef = to_lexicon_entry(word, h);
                  let newdef2 = newdef.clone();
                  let dict = Arc::make_mut(&mut env.dictionary);
                  dict.entry(word)
                      .and_modify(|e| {
                          e.examples = newdef.examples;
                          e.spec = newdef.spec;
                          e.definition = newdef.definition;
                      })
                      .or_insert(newdef2);
              }
              env
          }
          Err(_) => env.push(Item::Error(Error::undefined(Word::from("lexicon")))),
      }
  }

  fn add_derivations(mut env: Environment) -> Environment {
      let d = Arc::make_mut(&mut env.dictionary);
      d.insert(
          Word::from("derivations"),
          dict::Entry {
              definition: dict::Definition::Derived(Arc::new(ListContent::from_iter([
                  //Item::Word(*S_LIST),
                  Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::new()))),
              ]))),
              examples: None,
              spec: None,
          },
      );
      env
  }

  pub fn add_standard_dictionary(env: Environment) -> Environment {
      // read builtins
      let mut env = read_lexicon_file("src/kcats/builtins.kcats", env);
      //println!("with builtins {:?}", env.dictionary);
      env.dictionary = add_builtins(env.dictionary);
      env = add_derivations(env);
      read_lexicon_file("src/kcats/lexicon.kcats", env)
  }

  pub fn invalid_type_error(asked: List) -> ItemResult {
      Err(Error::type_mismatch(asked))
  }

  fn number_type_error() -> ItemResult {
      invalid_type_error(crate::types::wrap(Item::Word(*S_NUMBER)))
  }

  pub fn plus(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i + j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i + j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float + j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i + j as Float)),
          _ => number_type_error(),
      }
  }

  pub fn minus(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i - j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i - j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float - j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i - j as Float)),
          _ => number_type_error(),
      }
  }

  pub fn mult(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i * j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i * j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float * j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i * j as Float)),
          _ => number_type_error(),
      }
  }

  fn divide(i: Float, j: Float) -> ItemResult {
      let q = i / j;
      if q.is_nan() {
          Err(Error::division_by_zero())
      } else {
          Ok(Item::Float(q))
      }
  }

  pub fn div(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => i
              .checked_div(j)
              .ok_or_else(|| Error::division_by_zero())
              .and_then(|i| Ok(Item::Int(i))),

          (Item::Float(i), Item::Float(j)) => divide(i, j),
          (Item::Int(i), Item::Float(j)) => divide(i as Float, j),
          (Item::Float(i), Item::Int(j)) => divide(i, j as Float),
          _ => number_type_error(),
      }
  }

  pub fn mod_(i: Item, j: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      let j = Int::try_from(j)?;
      Ok(Item::Int(i % j))
  }

  pub fn inc(i: Item) -> ItemResult {
      Ok(Item::Int(Int::try_from(i)? + 1))
  }

  pub fn dec(i: Item) -> ItemResult {
      Ok(Item::Int(Int::try_from(i)? - 1))
  }

  pub fn is_zero(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::from(i == 0)),
          Item::Float(i) => Ok(Item::from(i == 0.0)),
          _ => number_type_error(),
      }
  }

  pub fn gt(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i > j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i > j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float > j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i > j as Float)),

          _ => number_type_error(),
      }
  }

  pub fn lt(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i < j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i < j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float) < j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i < j as Float)),

          _ => number_type_error(),
      }
  }

  pub fn gte(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i >= j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i >= j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float >= j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i >= j as Float)),

          _ => number_type_error(),
      }
  }

  pub fn lte(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i <= j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i <= j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float).le(&j))),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i <= j as Float)),

          _ => number_type_error(),
      }
  }

  pub fn join(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::List(mut i), Item::List(mut j)) => {
              let imut = Arc::make_mut(&mut i);

              imut.append(Arc::make_mut(&mut j));
              Ok(Item::List(i))
          }
          (Item::Dictionary(i), Item::Assoc(j)) => match (Associative::Dictionary(i)).join(j) {
              Associative::Dictionary(d) => Ok(Item::Dictionary(d)),
              a => Ok(Item::Assoc(a)),
          },
          (Item::String(mut i), Item::String(j)) => {
              i.push_str(&j);
              Ok(Item::String(i))
          }
          (Item::Bytes(mut i), Item::Bytes(mut j)) => {
              i.append(&mut j);
              Ok(Item::Bytes(i))
          }
          (Item::Assoc(i), Item::Assoc(j)) => Ok(Item::Assoc(i.join(j))),
          _ => invalid_type_error(serialize::to_list("[[list?] [string?]] [execute] any?")),
      }
  }

  pub fn pack(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Bytes(mut i), Item::Int(j)) => {
              i.extend([j as u8]);
              Ok(Item::Bytes(i))
          }
          (Item::List(mut l), j) => {
              //let mut l = List::try_from(i)?;
              Arc::make_mut(&mut l).push_back(j);
              Ok(Item::List(l))
          }
          _ => Err(Error::expected("list")),
      }
  }

  pub fn clone(env: Environment) -> Future<Environment> {
      let clone = env.stack.front().unwrap().clone();
      env.push(clone).into()
  }

  fn swap2(mut env: Environment, offset: usize) -> Future<Environment> {
      Arc::make_mut(&mut env.stack).swap(offset, offset + 1);
      env.into()
  }

  pub fn swap(env: Environment) -> Future<Environment> {
      swap2(env, 0)
  }

  pub fn swapdown(env: Environment) -> Future<Environment> {
      swap2(env, 1)
  }

  pub fn sink(mut env: Environment) -> Future<Environment> {
      let s = Arc::make_mut(&mut env.stack);
      s.swap(0, 2);
      s.swap(0, 1);
      env.into()
  }

  pub fn float(mut env: Environment) -> Future<Environment> {
      let s = Arc::make_mut(&mut env.stack);
      s.swap(0, 2);
      s.swap(1, 2);
      env.into()
  }

  pub fn discard(mut env: Environment) -> Future<Environment> {
      env.pop();
      env.into()
  }

  pub fn eq(i: Item, j: Item) -> ItemResult {
      Ok(Item::from(i == j))
  }

  pub fn count(i: Item) -> ItemResult {
      Ok(Item::Int(List::try_from(i)?.len().try_into().unwrap()))
  }

  pub fn is_string(i: Item) -> ItemResult {
      Ok(Item::from(if let Item::String(_) = i {
          true
      } else {
          false
      }))
  }

  pub fn is_bytes(i: Item) -> ItemResult {
      Ok(Item::from(if let Item::Bytes(_) = i {
          true
      } else {
          false
      }))
  }

  pub fn is_error(i: Item) -> ItemResult {
      Ok(Item::from(if let Item::Error(_) = i {
          true
      } else {
          false
      }))
  }

  pub fn is_word(i: Item) -> ItemResult {
      Ok(Item::from(match i {
          Item::Word(_) => true,
          Item::Entry(_) => true,
          // TODO maybe also check if it's an associative that looks like a Def?
          _ => false,
      }))
  }

  pub fn is_pipe(i: Item) -> ItemResult {
      Ok(Item::from(match i {
          Item::In(_) => true,
          Item::Out(_) => true,
          _ => false,
      }))
  }
  pub fn is_number(i: Item) -> ItemResult {
      Ok(Item::from(if let Item::Int(_) | Item::Float(_) = i {
          true
      } else {
          false
      }))
  }

  pub fn is_list(i: Item) -> ItemResult {
      Ok(Item::from(
          if let Item::List(_)
          | Item::Collection(_)
          | Item::Nothing
          | Item::Assoc(_)
          | Item::Env(_)
          | Item::Error(_)
          | Item::Dictionary(_)
          | Item::Entry(_) = i
          {
              true
          } else {
              false
          },
      ))
  }

  pub fn first(i: Item) -> ItemResult {
      let l = List::try_from(i)?;
      Ok(if let Some(i) = l.front() {
          i.clone()
      } else {
          Item::Nothing
      })
  }

  pub fn second(i: Item) -> ItemResult {
      let l = List::try_from(i)?;
      Ok(if let Some(i) = l.get(1) {
          i.clone()
      } else {
          Item::Nothing
      })
  }

  pub fn loop_(mut env: Environment) -> Future<Environment> {
      let p = List::try_from(env.pop());
      match p {
          Ok(mut p) => {
              let f = env.pop();
              if is_truthy(&f) {
                  let p2 = p.clone();
                  let pm = Arc::make_mut(&mut p);
                  pm.push_back(Item::List(p2));
                  pm.push_back("loop".into());
                  env.append_expression(p)
              } else {
                  env
              }
          }
          Err(e) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn execute(mut env: Environment) -> Future<Environment> {
      match List::try_from(env.pop()) {
          Ok(program) => env.append_expression(program),
          Err(e) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn wrap(mut env: Environment) -> Future<Environment> {
      let item = env.pop();
      let mut lc = ListContent::new();
      lc.push_front(item);
      env.push(Item::List(Arc::new(lc))).into()
  }

  pub fn unwrap(mut env: Environment) -> Future<Environment> {
      match List::try_from(env.pop()) {
          Ok(l) => {
              let len = l.len();
              let l2 = (0..len).map(move |i| l[i].clone());
              for i in l2 {
                  env = env.push(i);
              }
              env
          }
          Err(e) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn dip(mut env: Environment) -> Future<Environment> {
      match List::try_from(env.pop()) {
          Ok(program) => {
              let item = env.pop();
              let mut lc = ListContent::new();
              lc.push_front(item);
              let v = Arc::new(lc);
              let expr = Arc::make_mut(&mut env.expression);
              expr.push_front("unwrap".into());
              expr.push_front(Item::List(v));
              env.append_expression(program)
          }
          Err(e) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn dipdown(mut env: Environment) -> Future<Environment> {
      match List::try_from(env.pop()) {
          Ok(program) => {
              let item1 = env.pop();
              let item2 = env.pop();
              let mut lc = ListContent::new();
              lc.push_front(item1);
              lc.push_front(item2);
              let v = Arc::new(lc);
              let expr = Arc::make_mut(&mut env.expression);
              expr.push_front("unwrap".into());
              expr.push_front(Item::List(v));
              env.append_expression(program)
          }
          Err(e) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn unpack(mut env: Environment) -> Future<Environment> {
      // TODO: handle Nothing case
      let stack = Arc::make_mut(&mut env.stack);
      let i = if let Some(s) = stack.front_mut() {
          if let Item::List(ref mut l) = s {
              if let Some(i) = Arc::make_mut(l).pop_front() {
                  i
              } else {
                  Item::Nothing
              }
          } else {
              Item::from(invalid_type_error(Arc::new(ListContent::from_iter([
                  Item::Word(*S_LIST),
              ]))))
          }
      } else {
          Item::Error(Error::stack_underflow())
      };
      stack.push_front(i);
      env.into()
  }

  fn is_truthy(i: &Item) -> bool {
      match i {
          Item::Nothing => false,
          Item::List(l) => !l.is_empty(),
          Item::Assoc(a) => !a.is_empty(),
          _ => true,
      }
  }

  // fn boolean_value(b: bool) -> Item {
  //     if b {
  //         "true".into()
  //     } else {
  //         Item::Nothing
  //     }
  // }

  pub fn branch(mut env: Environment) -> Future<Environment> {
      match (List::try_from(env.pop()), List::try_from(env.pop())) {
          (Ok(false_branch), Ok(true_branch)) => {
              let b = env.pop();

              env.append_expression(if is_truthy(&b) {
                  true_branch
              } else {
                  false_branch
              })
          }
          (Err(e), _) => env.push(Item::Error(e)),
          (_, Err(e)) => env.push(Item::Error(e)),
      }
      .into()
  }

  pub fn step(mut env: Environment) -> Future<Environment> {
      let p = List::try_from(env.pop()).unwrap();
      let mut l = List::try_from(env.pop()).unwrap();
      let lm = Arc::make_mut(&mut l);
      if let Some(litem) = lm.pop_front() {
          let expr = Arc::make_mut(&mut env.expression);
          if !l.is_empty() {
              expr.push_front("step".into());
              expr.push_front(Item::List(p.clone()));
              expr.push_front(Item::List(l));
          }
          expr.push_front("execute".into());
          env.push(litem).push(Item::List(p)).into()
      } else {
          env.into()
      }
  }

  pub fn range(mut env: Environment) -> Future<Environment> {
      let stepby = Int::try_from(env.pop()).unwrap();
      let to = Int::try_from(env.pop()).unwrap();
      let from = Int::try_from(env.pop()).unwrap();
      env.push(Item::List(Arc::new(
          (from..to)
              .step_by(stepby as usize)
              .map(|i| Item::Int(i))
              .collect::<VecDeque<Item>>(),
      )))
      .into()
  }

  // (effect [rec2 rec1 then pred]
  //                   ['[if]
  //[(concat rec1
  //         [[pred then rec1 rec2 'recur]] rec2)
  // then pred]])

  pub fn recur(mut env: Environment) -> Future<Environment> {
      let mut rec2 = List::try_from(env.pop()).unwrap();
      let mut rec1 = List::try_from(env.pop()).unwrap();
      let then = List::try_from(env.pop()).unwrap();
      let pred = List::try_from(env.pop()).unwrap();
      env = env.push_expr("if".into());
      let r = Item::List(Arc::new(ListContent::from([
          Item::List(pred.clone()),
          Item::List(then.clone()),
          Item::List(rec1.clone()),
          Item::List(rec2.clone()),
          "recur".into(),
      ])));
      let mut e = ListContent::new();
      e.extend(Arc::make_mut(&mut rec1).drain(..));
      e.push_back(r);
      e.extend(Arc::make_mut(&mut rec2).drain(..));

      env.push(Item::List(pred))
          .push(Item::List(then))
          .push(Item::List(Arc::new(e)))
          .into()
  }

  //(fn [{[l & others] 'stack :as env}]
  //            (assoc env 'stack (apply list (vec others) l)))

  pub fn evert(mut env: Environment) -> Future<Environment> {
      let mut l = List::try_from(env.pop()).unwrap();
      mem::swap(&mut env.stack, &mut l);
      env.push(Item::List(l)).into()
  }

  fn to_lexicon_entry(w: Word, def: Associative) -> dict::Entry {
      let (def, _) = def.insert("word".into(), Item::Word(w));
      def.try_into().unwrap()
  }

  fn assoc_in(i: Item, ks: &[KeyItem], v: Item) -> Result<Item, Error> {
      if let [k, ks @ ..] = ks {
          if ks.is_empty() {
              match (i, k) {
                  (Item::List(mut l), KeyItem::Int(k)) => {
                      // vector set by index
                      let lm = Arc::make_mut(&mut l);
                      let idx = *k as usize;
                      // extend the size of the vector to be big enough to set
                      // the given index, pad with 'nothing' values.
                      if lm.len() <= idx {
                          lm.resize(idx + 1, Item::Nothing);
                      }
                      lm[*k as usize] = v;
                      Ok(Item::List(l))
                  }
                  (i, k) => {
                      let a = Associative::try_from(i)?;
                      Ok(Item::Assoc(a.insert(k.clone(), v).0))
                  }
              }
              //hm.insert(k.clone(), v);
          } else {
              match (i, k) {
                  (Item::List(mut l), KeyItem::Int(k)) => {
                      let lm = Arc::make_mut(&mut l);
                      let idx = *k as usize;
                      // extend the size of the vector to be big enough to set
                      // the given index, pad with 'nothing' values.
                      if lm.len() <= idx {
                          lm.resize(idx + 1, Item::Nothing);
                      }
                      let inner = &lm[idx];

                      lm[*k as usize] = if let [nextk, ..] = ks {
                          let i = match (inner, nextk) {
                              (Item::List(l), KeyItem::Int(_)) => Item::List(l.clone()),
                              (_, KeyItem::Int(_)) => Item::List(Arc::new(ListContent::new())),
                              _ => {
                                  Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::new())))
                              }
                          };
                          assoc_in(i, ks, v)?
                      } else {
                          v
                      };

                      //if the inner value isn't a list, overwrite it
                      Ok(Item::List(l))
                  }
                  (i, k) => {
                      let a = Associative::try_from(i)?;
                      let inner = a.get(&k).unwrap_or(Item::Nothing).clone();
                      // if the inner value isn't a map, we're just overwriting whatever it
                      // is with a new map.

                      let i = match inner {
                          Item::Assoc(inner) => Item::Assoc(inner),
                          Item::List(inner) => Item::List(inner),
                          // TODO: other associative types
                          _ => Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::new()))),
                      };
                      Ok(Item::Assoc(a.insert(k.clone(), assoc_in(i, ks, v)?).0))
                  }
              }
          }
      } else {
          Ok(i)
      }
  }

  pub fn assign(m: Item, ks: Item, v: Item) -> ItemResult {
      let mut kit = List::try_from(ks).unwrap();
      let ks = Arc::make_mut(&mut kit).drain(..);
      let mut ksvec = ks
          .into_iter()
          .map(|k| KeyItem::try_from(k))
          .collect::<Result<KeyList, Error>>()?;
      ksvec.make_contiguous();
      let (ks, _) = ksvec.as_slices();
      Ok(assoc_in(m, ks, v)?)
  }

  //TODO: this should really take a keylist like assign and lookup
  pub fn unassign(m: Item, k: Item) -> ItemResult {
      let m = Associative::try_from(m).unwrap();
      let k = KeyItem::try_from(k)?;
      let (nm, _) = m.remove(&k);
      Ok(Item::Assoc(nm))
  }

  pub fn association(m: Item) -> ItemResult {
      match Associative::try_from(m) {
          Ok(m) => Ok(Item::Assoc(m)),
          Err(e) => Err(e),
      }
  }

  pub fn lookup(i: Item, k: Item) -> ItemResult {
      //println!("lookup {:?} \n {:?}", m, k);
      let k = KeyItem::try_from(k)?;
      match (i, k) {
          (Item::List(l), KeyItem::Int(k)) => Ok(l
              .get(k as usize)
              .and_then(|x| Some(x.clone()))
              .unwrap_or(Item::Nothing)),
          (i, k) => {
              let m = Associative::try_from(i)?;
              Ok(m.get(&k).unwrap_or(Item::Nothing).clone())
          }
      }
  }

  pub fn or(i: Item, j: Item) -> ItemResult {
      Ok(if is_truthy(&i) {
          i
      } else {
          if is_truthy(&j) {
              j
          } else {
              Item::Nothing
          }
      })
      //Ok(Item::from(is_truthy(i) || is_truthy(j)))
  }

  pub fn and(i: Item, j: Item) -> ItemResult {
      Ok(if is_truthy(&i) && is_truthy(&j) {
          j
      } else {
          Item::Nothing
      })
  }

  pub fn not(i: Item) -> ItemResult {
      Ok(Item::from(!is_truthy(&i)))
  }

  pub fn is_association(i: Item) -> ItemResult {
      Ok(Item::from(match i {
          Item::Assoc(_) => true,
          Item::Nothing => true,
          Item::Env(_) => true,
          Item::Error(_) => true,
          Item::Entry(_) => true,
          Item::Dictionary(_) => true,
          Item::Collection(i) => match i {
              coll::Collection::Associative(_) => true,
              coll::Collection::List(l) => Associative::try_from(Item::List(l)).is_ok(),
              coll::Collection::Nothing => true,
          },
          Item::List(l) => Associative::try_from(Item::List(l)).is_ok(),
          _ => false,
      }))
  }

  pub fn is_odd(i: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      Ok(Item::from(i & 1 == 1))
  }

  pub fn is_even(i: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      Ok(Item::from(i & 1 == 0))
  }

  pub fn decide(mut env: Environment) -> Future<Environment> {
      let mut clauses = List::try_from(env.pop()).unwrap();
      let clauses_data = Arc::make_mut(&mut clauses);
      let clause = clauses_data.pop_front();

      if let Some(clause) = clause {
          if let Item::List(mut clause) = clause {
              if clause.len() != 2 {
                  env.push(Item::Error(Error::list_count(2))).into()
              } else {
                  let clause_data = Arc::make_mut(&mut clause);
                  let test = clause_data.pop_front().unwrap();
                  let expr = clause_data.pop_front().unwrap();

                  match (test, expr) {
                      (Item::List(test), Item::List(expr)) => {
                          // construct if
                          let testp =
                              Arc::new(ListContent::from(vec![Item::List(test), "shield".into()]));
                          let elsep = Arc::new(ListContent::from(vec![
                              Item::List(clauses),
                              "decide".into(),
                          ]));
                          let newexpr = Arc::new(ListContent::from(vec![
                              Item::List(testp),
                              Item::List(expr),
                              Item::List(elsep),
                              "if".into(),
                          ]));
                          env.append_expression(newexpr).into()
                      }
                      _ => env
                          .push(Item::from(invalid_type_error(serialize::to_list(
                              "[list?] both",
                          ))))
                          .into(),
                  }
              }
          } else {
              env.push(Item::Error(Error::expected("list"))).into()
          }
      } else {
          // clauses empty, return nothing
          env.push(Item::Nothing).into()
      }
  }

  pub fn read(mut env: Environment) -> Future<Environment> {
      let s = String::try_from(env.pop()).unwrap();
      let parsed = serialize::parse(s);
      env.push(match parsed {
          Ok(l) => Item::List(l),
          Err(e) => Item::Error(e),
      })
      .into()
  }

  fn check_type(i: &Item, w: Word) -> Result<(), Error> {
      match i {
          Item::Int(_) => {
              if w == *S_INTEGER || w == *S_NUMBER || w == *S_ITEM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::List(_) => {
              if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_PROGRAM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Collection(_) => {
              if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_PROGRAM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Float(_) => {
              if w == *S_FLOAT || w == *S_NUMBER || w == *S_ITEM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Bytes(_) => {
              if w == *S_BYTES || w == *S_ITEM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::String(_) => {
              if w == *S_STRING || w == *S_ITEM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Word(_) => {
              if w == *S_WORD || w == *S_ITEM || w == *S_BOOLEAN {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Entry(_) => {
              if w == *S_WORD || w == *S_ITEM || w == *S_ASSOC {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Dictionary(_) => {
              if w == *S_ITEM || w == *S_ASSOC || w == *S_LIST {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Assoc(_) => {
              if w == *S_ASSOC || w == *S_LIST || w == *S_ITEM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Env(_) => {
              if w == *S_ASSOC || w == *S_LIST || w == *S_ITEM || w == *S_ENVIRONMENT {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Nothing => {
              if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_BOOLEAN || w == *S_PROGRAM {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Error(_) => {
              if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_ERROR {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::In(_) => {
              if w == *S_ITEM || w == *S_PIPE {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Out(_) => {
              if w == *S_ITEM || w == *S_PIPE {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
          Item::Tunnel(_) => {
              if w == *S_ITEM || w == *S_PIPE {
                  Ok(())
              } else {
                  Err(Error::expected(&w))
              }
          }
      }
  }

  fn check_stack_depth(env: &Environment, min_depth: usize) -> Result<(), Error> {
      //println!("Checking stack has at least {} items", min_depth);
      if env.stack.len() < min_depth {
          Err(Error::stack_underflow())
      } else {
          Ok(())
      }
  }

  fn check_input_spec(spec: &List, env: &Environment) -> Result<(), Error> {
      let input_spec = spec.front().unwrap();
      if let Item::List(specs) = input_spec {
          check_stack_depth(env, specs.len())?;
          let indexes = Range {
              start: 0,
              end: specs.len(),
          };

          indexes
              .into_iter()
              .map(|i| {
                  let item = env.stack.get(i).unwrap();
                  let spec = specs.get(i).unwrap();
                  match spec {
                      Item::List(named) => {
                          if let Item::Word(w) = named.get(0).unwrap() {
                              check_type(item, *w)
                          } else {
                              Err(Error::expected("list"))
                          }
                      }
                      Item::Word(w) => check_type(item, *w),
                      // the type might happen to also be a defined
                      // word, like 'association'
                      _ => Err(Error::expected("list")),
                  }
              })
              .collect::<Result<(), Error>>()
      } else {
          Err(Error::expected("list"))
      }
  }

  pub fn eval_step(mut env: Environment) -> Future<Environment> {
      //println!("{:?}", env);
      let next_item = env.expression.front();

      if let Some(val) = next_item {
          match val {
              Item::Word(word) => {
                  if let Some(dfn) = env.dictionary.get(word) {
                      {
                          if let Some(spec) = &dfn.spec {
                              if let Err(e) = check_input_spec(&spec, &env) {
                                  env = env.push(Item::Error(e));
                                  return env.into();
                              }
                          } else {
                              println!("No spec for {}!", word);
                          }
                          let expr = Arc::make_mut(&mut env.expression);
                          expr.pop_front();

                          match &dfn.definition {
                              dict::Definition::Axiom(a) => {
                                  // we can't keep borrowing the env, so we
                                  // clone the axiom def to release it and then
                                  // we can pass the env to the axiom def fn
                                  let f = a.clone();
                                  (f)(env)
                              }
                              dict::Definition::Derived(d) => {
                                  let items = d.clone();
                                  env.append_expression(items).into()
                              }
                          }
                      }
                  } else {
                      let w = *word;
                      env.push(Item::Error(Error::undefined(w))).into()
                  }
              }
              Item::Entry(entry) => {
                  if let Some(spec) = &entry.spec {
                      if let Err(e) = check_input_spec(&spec, &env) {
                          env = env.push(Item::Error(e));
                          return env.into();
                      }
                  }
                  let expr = Arc::make_mut(&mut env.expression);
                  let i = expr.pop_front().unwrap();
                  if let Item::Entry(e) = i {
                      match e.definition {
                          dict::Definition::Axiom(builtin) => {
                              //let b = dict::Axiom::try_from(env.pop_expr()).unwrap();
                              (builtin)(env)
                          }
                          dict::Definition::Derived(d) => {
                              let d = d.clone();
                              env.append_expression(d).into()
                          }
                      }
                  } else {
                      // Should not ever reach here, we already know the item is an Entry
                      env.into()
                  }
              }
              _ => {
                  // not a word, just push onto stack
                  let i = env.pop_expr();
                  env.push(i).into()
              }
          }
      } else {
          env.push(Item::Error(Error::short_list(1))).into()
      }
  }

  fn reverse(i: Item) -> ItemResult {
      let mut l = List::try_from(i).unwrap();
      //l.make_contiguous().reverse();
      let lmut = Arc::make_mut(&mut l);
      Ok(Item::List(Arc::new(lmut.drain(..).rev().collect())))
  }

  fn bytes(i: Item) -> ItemResult {
      match i {
          Item::String(s) => Ok(Item::Bytes(Bytes::from(s.as_bytes()))),
          i => Ok(Item::Bytes(Bytes::from(serialize::emit(&i)))),
      }
  }

  fn string(i: Item) -> ItemResult {
      match i {
          Item::Bytes(b) => Ok(Item::String(std::str::from_utf8(&b).unwrap().to_string())),
          i => Ok(Item::String(serialize::emit(&i))),
      }
  }

  fn rest(i: Item) -> ItemResult {
      let mut l = List::try_from(i).unwrap();
      let ld = Arc::make_mut(&mut l);
      ld.pop_front();
      Ok(Item::List(l))
  }

  fn get_error(env: &Environment) -> Option<&Error> {
      if let Some(i) = env.stack.front() {
          if let Item::Error(e) = i {
              return Some(e);
          }
      }
      return None;
  }

  fn unwind(mut env: Environment) -> Environment {
      let err = env.pop();
      let w: &Item = &"handle".into();

      let err = match err {
          Item::Error(mut e) => {
              let mut next = env.expression.front();
              let mut unwound = ListContent::new();
              while next.is_some() && next.unwrap() != w {
                  let i = env.pop_expr();
                  unwound.push_back(i);
                  next = env.expression.front();
              }
              if next.is_some() {
                  env.pop_expr();
              }
              // set the is_handled bit
              e.is_handled = true;
              let em = Arc::make_mut(&mut e.data);
              em.insert("unwound".into(), Item::List(Arc::new(unwound)));
              Item::Error(e)
          }
          i => i,
      };
      env = env.push(err);
      return env;
  }

  pub async fn eval(mut env: Environment) -> Environment {
      loop {
          if let Some(err) = get_error(&env) {
              if !err.is_handled {
                  env = unwind(env); // TODO: this should be done in eval_step
              };
          }
          if !env.expression.is_empty() {
              env = eval_step(env).await;
          } else {
              break;
          }
      }
      env
  }

  pub fn standard_env(program: Option<List>, stack: Option<List>) -> Environment {
      let prog_expr = match program {
          Some(p) => Stack::from(p),
          _ => Stack::new(ListContent::new()),
      };

      let env = Environment {
          stack: stack.unwrap_or(Stack::new(ListContent::new())),
          expression: prog_expr,
          dictionary: Arc::new(HashMap::<Word, dict::Entry>::new()),
      };
      add_standard_dictionary(env)
  }

  fn environment(p: Item) -> ItemResult {
      Ok(Item::Env(p.try_into()?))
  }

  pub fn eval_step_outer(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      match inner_env {
          Ok(inner) => Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),
          Err(e) => env.push(Item::Error(e)).into(),
      }
  }

  pub fn evaluate(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      match inner_env {
          Ok(inner) => Box::pin(eval(inner).map(|inner_done| env.push(Item::Env(inner_done)))),
          Err(e) => env.push(Item::Error(e)).into(),
      }
  }

  pub fn identity(env: Environment) -> Future<Environment> {
      env.into()
  }

  pub fn dictionary(env: Environment) -> Future<Environment> {
      let d = env.dictionary.clone();
      env.push(Item::Dictionary(d)).into()
  }

  fn ceil(i: Item) -> ItemResult {
      let f = Float::try_from(i)?;
      Ok(Item::Float(f.ceil()))
  }

  fn sqrt(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::Int(i.sqrt())),
          Item::Float(f) => Ok(Item::Float(f.sqrt())),
          _ => Err(Error::expected("number")),
      }
  }

  fn abs(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::Int(i.abs())),
          Item::Float(f) => Ok(Item::Float(f.abs())),
          _ => Err(Error::expected("number")),
      }
  }

  fn handle(i: Item) -> ItemResult {
      match i {
          Item::Error(mut e) => Ok(Item::Error({
              e.is_handled = true;
              e
          })),
          i => Ok(i),
      }
  }

  // fn inscription(env: &mut Environment) -> Result<(Word, dict::Entry), Error> {
  //     let d = env.pop();
  //     let mut wl = List::try_from(env.pop())?;
  //     let w1 = Arc::make_mut(&mut wl).pop_front();
  //     let x = w1.ok_or(Error::short_list(1))?;
  //     let w = Word::try_from(x.clone())?;
  //     Ok((w, dict::Entry::try_from(d)?))
  // }

  // pub fn inscribe(mut env: Environment) -> Environment {
  //     let r = inscription(&mut env);
  //     match r {
  //         Ok((w, def)) => {
  //             let d = Arc::make_mut(&mut env.dictionary);
  //             d.insert(KeyItem::Word(w), Item::Entry(def));
  //             env
  //         }
  //         Err(e) => env.push(Item::Error(e)),
  //     }
  // }

  // make 'true' a word that doesn't have to be quoted, just pushes
  // itself onto the stack.
  pub fn true_(env: Environment) -> Future<Environment> {
      env.push("true".into()).into()
  }

  pub fn fail(e: Item) -> ItemResult {
      let mut e: Error = e.try_into().unwrap();
      e.is_handled = false;
      Err(e)
  }

  // fn normalize_dictionary(mut d: dict::Dictionary) -> Result<dict::Dictionary, Error> {
  //     let dm = Arc::make_mut(&mut d);
  //     for (k, v) in dm.iter_mut() {
  //         match v {
  //             Item::Assoc(a) => {
  //                 let aa = a.clone();
  //                 let (aa, _) = aa.insert("word".into(), Item::try_from(k.clone()).unwrap());
  //                 *v = Item::Entry(aa.try_into()?)
  //             }
  //             Item::List(l) => {
  //                 let a: Associative = l.clone().try_into()?;
  //                 let (a, _) = a.insert("word".into(), Item::try_from(k.clone()).unwrap());
  //                 *v = Item::Entry(a.try_into()?)
  //             }
  //             Item::Entry(_) => {}
  //             _ => {
  //                 return Err(Error::expected("dictionary"));
  //             }
  //         }
  //     }
  //     Ok(d)
  // }

  pub fn redefine(mut env: Environment) -> Future<Environment> {
      let d = dict::Dictionary::try_from(env.pop());
      match d {
          Ok(d) => {
              env.dictionary = d;
              env
          }
          Err(e) => {
              env = env.push(Item::Error(e));
              env
          }
      }
      .into()
  }

  // Takes an inner environment from the top of the stack, and spawns a
  // tokio task to evaluate that environment.
  pub fn animate(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      match inner_env {
          Ok(inner) => {
              tokio::spawn(async move { eval(inner).await });
              env.into()
          }
          Err(e) => env.push(Item::Error(e)).into(),
      }
  }
#+end_src
** Top level execution
We'll define the main module which reads input for the kcats
interpreter process, and prints output.

We'll also define how to run unit tests.
#+begin_src rust :tangle src/main.rs
  mod axiom;
  mod crypto;
  mod pipes;
  mod serialize;
  mod types;

  use crate::types::environment::Environment;
  use crate::types::error;
  use crate::types::*;
  use std::io;
  use std::io::{BufRead, Read};
  use std::sync::Arc;
  use tokio;

  fn print_result(env: Environment) {
      if env.expression.is_empty() {
          println!("{}", serialize::emit_all(&env.stack));
      } else {
          println!(
              "stack: {}\nexpression: {}",
              serialize::emit(&Item::List(env.stack)),
              serialize::emit(&Item::List(env.expression))
          )
      }
  }

  fn get_stdin() -> String {
      let mut buf = String::new();
      for line in io::stdin().lock().lines() {
          buf.push_str(&line.unwrap());
          buf.push('\n');
      }
      buf
  }

  // A function that takes a handle to stdin. It reads a length from
  // stdin, then reads that many bytes and returns a string.
  async fn read_input() -> Option<String> {
      //spawn a thread to read from stdin
      //println!("Reading input");
      tokio::spawn(async move {
          let mut stdin = io::stdin().lock();
          let mut buf = String::new();
          if let Err(e) = stdin.read_line(&mut buf) {
              println!("Error reading content length {:?}", e);
              return None;
          }
          // parse an integer from buf
          let read_len = buf.trim();
          //println!("Read length {}", read_len);
          let len = read_len.parse::<usize>().unwrap_or(0 as usize);
          if len == 0 {
              return None;
          }
          // read len bytes from stdin
          let mut buf = vec![0; len];
          stdin.read_exact(&mut buf).unwrap();

          // convert the bytes to a string
          Some(String::from_utf8(buf).unwrap())
      })
      .await
      .unwrap()
  }

  async fn print(env: &Environment) {
      let result = serialize::emit_all(&env.stack);
      // first print the length of the result
      println!("{}\n{}", result.len(), result);
  }

  // a function that takes an env, and an input string. Parses the
  // string, if it parses, returns the env with the input added to the
  // expression. Otherwise returns Error.
  fn parse_input(mut env: Environment, input: String) -> Result<Environment, error::Error> {
      let mut parsed = serialize::parse(input)?;
      let expr = Arc::make_mut(&mut env.expression);
      expr.extend(Arc::make_mut(&mut parsed).drain(..));
      Ok(env)
  }

  //It converts the bytes to a
  // string, and then evaluates that string as a kcats program. It then
  // prints the length of the result, and then the result itself.
  async fn interactive_mode() {
      let mut env = axiom::standard_env(None, None);

      loop {
          if let Some(program) = read_input().await {
              if let Ok(parsed_env) = parse_input(env, program) {
                  //env = parsed_env;
                  env = axiom::eval(parsed_env).await;
                  print(&env).await;
              } else {
                  println!("Could not parse input");
                  break;
              }
          } else {
              //println!("Blank input received, exiting");
              continue;
          }
      }
  }

  #[tokio::main]
  async fn main() {
      // read command line options, to look for -i switch
      let args: Vec<String> = std::env::args().collect();
      // if args contains "-i", read via handle_stdin
      if args.contains(&"-i".to_string()) {
          interactive_mode().await;
      } else {
          // otherwise, read from stdin
          match parse_input(axiom::standard_env(None, None), get_stdin()) {
              Ok(env) => {
                  print_result(axiom::eval(env).await);
              }
              Err(e) => {
                  println!("Error parsing input: {:?}", e);
              }
          }
      }
  }

  #[cfg(test)]
  mod tests {
      // Note this useful idiom: importing names from outer (for mod tests) scope.
      use super::error::Error;
      use super::*;
      use internment::Intern;
      use std::borrow::Borrow;
      use test_case::test_case;
      use tokio;

      pub fn get_item(i: Item, index: usize) -> Option<Item> {
          if let Item::List(l) = i {
              match l.get(index) {
                  Some(x) => Some(x.clone()),
                  None => None,
              }
          } else {
              None
          }
      }

      #[tokio::main]
      async fn test_example(
          mut prog_env: Environment,
          program: List,
          expected: List,
      ) -> Option<Error> {
          let mut exp_env = prog_env.clone();
          prog_env = prog_env.append_expression(program.clone());
          exp_env = exp_env.append_expression(expected.clone());

          let p_fut = tokio::spawn(async move { axiom::eval(prog_env).await });

          let exp_fut = tokio::spawn(async move { axiom::eval(exp_env).await });
          let (prog_env, exp_env) = tokio::join!(p_fut, exp_fut);
          let prog_env = prog_env.unwrap();
          let exp_env = exp_env.unwrap();

          if prog_env.stack == exp_env.stack {
              println!(
                  "Nice expected {} got {}",
                  serialize::emit_all(exp_env.stack.borrow()),
                  serialize::emit_all(prog_env.stack.borrow())
              );
              None
          } else {
              println!(
                  "uh oh expected {} got {}",
                  serialize::emit_all(exp_env.stack.borrow()),
                  serialize::emit_all(prog_env.stack.borrow())
              );
              Some(Error::test_assertion(program, expected, prog_env.stack))
          }
      }

      fn test_word(standard_env: Environment, w: Word) -> Vec<Error> {
          if let Some(d) = standard_env.dictionary.get(&w) {
              d.examples
                  .clone()
                  .unwrap()
                  .iter()
                  .filter_map(|ex| {
                      match (
                          get_item(ex.clone(), 0).unwrap(),
                          get_item(ex.clone(), 1).unwrap(),
                      ) {
                          (Item::List(p), Item::List(exp)) => {
                              test_example(standard_env.clone(), p.clone(), exp.clone())
                          }
                          _ => Some(Error::expected("list")),
                      }
                  })
                  .collect::<Vec<Error>>()
          } else {
              println!("Empty!");
              Vec::new()
          }
      }

      #[test_case("+" ; "plus")]
      #[test_case("-" ; "minus")]
      #[test_case("=" ; "eq")]
      #[test_case(">" ; "gt")]
      #[test_case(">=" ; "gte")]
      #[test_case("<" ; "lt")]
      #[test_case("<=" ; "lte")]
      #[test_case("*" ; "mult")]
      #[test_case("/" ; "divide")]
      #[test_case("abs")]
      #[test_case("and")]
      #[test_case("any?" ; "is_any")]
      #[test_case("assign")]
      #[test_case("association")]
      #[test_case("association?" ; "is_association")]
      #[test_case("both?" ; "is_both")]
      #[test_case("branch")]
      #[test_case("bytes")]
      #[test_case("bytes?" ; "is_bytes")]
      #[test_case("ceil")]
      #[test_case("clone")]
      #[test_case("count")]
      #[test_case("dec")]
      #[test_case("decide")]
      #[test_case("dip")]
      #[test_case("dipdown")]
      #[test_case("discard")]
      #[test_case("environment")]
      #[test_case("evaluate")]
      #[test_case("eval_step")]
      #[test_case("even?" ; "is_even")]
      #[test_case("evert")]
      #[test_case("every?" ; "is_every")]
      #[test_case("execute")]
      #[test_case("filter")]
      #[test_case("first")]
      #[test_case("float")]
      #[test_case("future")]
      #[test_case("if")]
      #[test_case("inc")]
      #[test_case("inject")]
      #[test_case("inscribe")]
      #[test_case("join")]
      #[test_case("let")]
      #[test_case("lingo")]
      #[test_case("list?" ; "is_list")]
      #[test_case("lookup")]
      #[test_case("loop")]
      #[test_case("map")]
      #[test_case("max")]
      #[test_case("min")]
      #[test_case("mod")]
      #[test_case("not")]
      #[test_case("nothing?" ; "is_nothing")]
      #[test_case("number?" ; "is_number")]
      #[test_case("odd?" ; "is_odd")]
      #[test_case("or")]
      #[test_case("pack")]
      #[test_case("prepend")]
      #[test_case("primrec")]
      #[test_case("range")]
      #[test_case("recover")]
      #[test_case("recur")]
      #[test_case("rest")]
      #[test_case("retry")]
      #[test_case("reverse")]
      #[test_case("shield")]
      #[test_case("shielddown")]
      #[test_case("shielddowndown")]
      #[test_case("sink")]
      #[test_case("snapshot")]
      #[test_case("something?" ; "is_something")]
      #[test_case("sqrt")]
      #[test_case("step")]
      #[test_case("string")]
      #[test_case("string?" ; "is_string")]
      #[test_case("swap")]
      #[test_case("swapdown")]
      #[test_case("take")]
      #[test_case("times")]
      #[test_case("type")]
      #[test_case("unassign")]
      #[test_case("unpack")]
      #[test_case("unwrap")]
      #[test_case("update")]
      #[test_case("value")]
      #[test_case("while")]
      #[test_case("within?" ; "is_within")]
      #[test_case("word?")]
      #[test_case("wrap")]
      #[test_case("zero?" ; "is_zero")]
      #[test_case("zip")]
      fn test_lexicon(word: &str) {
          let e = axiom::standard_env(None, None);

          let r = test_word(e.clone(), Intern::new(word.to_string()));
          assert!(r.is_empty(), "{:?}", r);
      }
  }

  // if let (Item::List(program), Item::List(expected)) = (program, expected) {

  //     } else {
  //         Err(Error::from("Example should be a pair"))
  //     }

  // for ex in d.examples().iter() {
  //             let e = List::try_from(*ex).ok().unwrap();
  //             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
  //             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

  //             test_example(axiom::standard_env.clone(), w, p,exp)
  //         }.retain(|i| i.is_some()).collect::<Vec<Error>>()
#+end_src
** Pipes (input/output)
Kcats will confine all i/o to pipes. You can put values into pipes and
they emerge elsewhere. Words that act on pipes are the only ones that
can be impure. Everything else is a value.
**** Basic Types
The basic pipe contracts.
#+begin_src rust :tangle src/pipes.rs
  use crate::axiom::ItemResult;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::{self, Item};
  use crate::ListContent;
  use std::future;
  use std::sync::Arc;
  use tokio::sync::RwLock;

  use futures::executor;
  use futures::future::FutureExt;
  pub mod channel;
  pub mod fs;
  pub mod net;

  #[derive(Debug, Clone)]
  pub enum In {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      Handoff(channel::Handoff<Item>),
  }

  #[derive(Debug, Clone)]
  pub enum Out {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      ServerSocket(Arc<RwLock<net::ServerSocket>>),
      Handoff(channel::Handoff<Item>),
      Filled(channel::Filled),
  }

  #[derive(Debug, Clone)]
  pub enum Tunnel {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      Handoff(channel::Handoff<Item>),
  }

  impl From<Tunnel> for Out {
      fn from(t: Tunnel) -> Self {
          match t {
              Tunnel::StaticFile(f) => Out::StaticFile(f),
              Tunnel::Socket(s) => Out::Socket(s),
              Tunnel::Handoff(h) => Out::Handoff(h),
          }
      }
  }

  impl From<Tunnel> for In {
      fn from(t: Tunnel) -> Self {
          match t {
              Tunnel::StaticFile(f) => In::StaticFile(f),
              Tunnel::Socket(s) => In::Socket(s),
              Tunnel::Handoff(h) => In::Handoff(h),
          }
      }
  }

  impl In {
      fn put(self, i: Item) -> types::Future<Result<(), Error>> {
          match self {
              In::StaticFile(f) => Box::pin(async move { f.write().await.put(i).await }),
              In::Socket(f) => Box::pin(async move { f.write().await.put(i).await }),
              In::Handoff(f) => Box::pin(f.put(i)), //_ => Err(Error::expected("foo")),
          }
      }
      fn close(self) -> types::Future<Result<(), Error>> {
          match self {
              In::StaticFile(f) => Box::pin(async move { f.write().await.close() }),
              In::Socket(_) => Box::pin(async move { Ok(()) }),
              In::Handoff(_) => Box::pin(async move { Ok(()) }),
          }
      }
      fn is_closed(self) -> types::Future<bool> {
          match self {
              In::StaticFile(f) => Box::pin(async move { f.read().await.is_closed() }),
              In::Socket(_) => Box::pin(async move { false }), //TODO: actual impls
              In::Handoff(_) => Box::pin(async move { false }),
          }
      }
  }

  impl Tunnel {
      fn is_closed(self) -> types::Future<bool> {
          match self {
              Tunnel::StaticFile(f) => Box::pin(async move { f.read().await.is_closed() }),
              Tunnel::Socket(_) => Box::pin(async move { false }),
              Tunnel::Handoff(_) => Box::pin(async move { false }),
          }
      }
  }

  impl Out {
      fn take(self) -> types::Future<ItemResult> {
          match self {
              Out::StaticFile(f) => Box::pin(async move { f.write().await.take().await }),
              Out::Socket(f) => Box::pin(async move { f.write().await.take().await }),
              Out::ServerSocket(f) => Box::pin(async move { f.write().await.take().await }),
              Out::Handoff(h) => Box::pin(h.take()),
              Out::Filled(f) => Box::pin(f.take()),
          }
      }
      fn close(self) -> types::Future<Result<(), Error>> {
          match self {
              Out::StaticFile(f) => Box::pin(async move { f.write().await.close() }),
              Out::Socket(f) => Box::pin(async move { f.write().await.close() }),
              Out::ServerSocket(f) => Box::pin(async move { f.write().await.close() }),
              Out::Handoff(_) => Box::pin(future::ready(Ok(()))),
              Out::Filled(_) => Box::pin(future::ready(Ok(()))),
          }
      }
      fn is_closed(self) -> types::Future<bool> {
          match self {
              Out::StaticFile(f) => Box::pin(async move { f.read().await.is_closed() }),
              Out::Socket(f) => Box::pin(async move { f.read().await.is_closed() }),
              Out::ServerSocket(f) => Box::pin(async move { f.read().await.is_closed() }),
              Out::Handoff(_) => Box::pin(future::ready(false)),
              Out::Filled(_) => Box::pin(future::ready(false)),
          }
      }
  }

  impl crate::serialize::Display for In {
      fn representation(&self) -> Item {
          match self {
              In::StaticFile(f) => executor::block_on(async move { f.read().await.representation() }),
              In::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              In::Handoff(h) => h.representation(),
          }
      }
  }

  impl crate::serialize::Display for Out {
      fn representation(&self) -> Item {
          match self {
              Out::StaticFile(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Out::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              Out::ServerSocket(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Out::Handoff(h) => h.representation(),
              Out::Filled(f) => f.representation(),
          }
      }
  }

  impl crate::serialize::Display for Tunnel {
      fn representation(&self) -> Item {
          match self {
              Tunnel::StaticFile(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Tunnel::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              Tunnel::Handoff(h) => h.representation(),
          }
      }
  }
  /* Pipes can be "closed", from either end to signal that either the
   ,* putter or taker has gone away. Sometimes the type of pipe
   ,* may not really support this concept but an implementation is
   ,* required.  For example, files. When you open a file for writing and
   ,* then "close" it, that doesn't really do anything. Rust doesn't have
   ,* an explicit file close. You have to drop the reference to it, which
   ,* in kcats you can do by popping the pipe off the stack. Rust will
   ,* clean up automatically, other impls might have to reference count.
   ,*
   ,* The contract here is as follows:
   ,* 1. After calling close, put on the pipe returns an error
   ,*
   ,* 2. After calling close, take on the pipe will return still-buffered
   ,* items (if the pipe has a buffer), but once buffer is exhausted it
   ,* will return error.
   ,*
   ,* 2. Errors cannot be put into a pipe (the taker can't distinguish
   ,* between io error and an error value). To work around this, wrap the
   ,* error value in a list to quote it. Putting error into a pipe will
   ,* return an io error.
   ,*
   ,* 3. Once closed pipes cannot be ever be put into again. closed? will always
   ,* return true thereafter.
   ,*
   ,* One use case that has to be handled specially is a file we've fully
   ,* read but later someone else might write more bytes to the end. Does
   ,* the pipe close when we reach EOF? I think we might need to support
   ,* both types (a type that closes when hitting eof and one that
   ,* doesn't). The former is the "normal" use case, which will be the
   ,* default.
   ,*
   ,* These two types are basically static vs dynamic content. Either all
   ,* the content is known now, or it isn't.
   ,*
  ,*/

  fn closed_error(on_take: bool) -> Error {
      Error::create(
          Arc::new(ListContent::from_iter([
              "close".into(),
              if on_take { "take" } else { "put" }.into(),
          ])),
          "attempt to use closed pipe",
      )
  }

  pub fn put_(mut env: Environment) -> types::Future<Environment> {
      let item = env.pop();
      let pipe = env.pop();
      let p2 = pipe.clone();

      Box::pin(
          match pipe {
              Item::In(p) => p.put(item),
              Item::Tunnel(t) => In::from(t).put(item),
              //TODO: put the pipe back
              _ => return env.push(Item::Error(Error::expected("pipe"))).into(),
          }
          .map(move |r| match r {
              Ok(_) => env.push(p2),
              Err(e) => env.push(p2).push(Item::Error(e)),
          }),
      )
  }

  pub fn take_(mut env: Environment) -> types::Future<Environment> {
      let pipe = env.pop();
      let p2 = pipe.clone();
      Box::pin(
          match pipe {
              Item::Out(p) => p.take(),
              Item::Tunnel(t) => Out::from(t).take(),
              _ => return env.push(Item::Error(Error::expected("pipe"))).into(),
          }
          .map(move |r| match r {
              Ok(i) => env.push(p2).push(i),
              Err(e) => env.push(p2).push(Item::Error(e)),
          }),
      )
  }

  pub fn is_closed(i: Item) -> types::Future<ItemResult> {
      match i {
          Item::In(p) => Box::pin(async move { Ok(Item::from(p.is_closed().await)) }),
          Item::Out(p) => Box::pin(async move { Ok(Item::from(p.is_closed().await)) }),
          Item::Tunnel(t) => Box::pin(async move { Ok(Item::from(t.is_closed().await)) }),
          _ => Box::pin(future::ready(Err(Error::expected("pipe")))),
      }
  }

  pub fn close(i: Item) -> types::Future<ItemResult> {
      match i {
          Item::In(p) => Box::pin(async move {
              Ok({
                  p.clone().close().await.unwrap();
                  Item::In(p)
              })
          }),
          Item::Out(p) => Box::pin(async move {
              Ok({
                  p.clone().close().await.unwrap();
                  Item::Out(p)
              })
          }),
          _ => Box::pin(future::ready(Err(Error::expected("pipe")))),
      }
  }
#+end_src
**** Files
How to interact with files on disk
#+begin_src rust :tangle src/pipes/fs.rs
  use crate::axiom::ItemResult;
  use crate::pipes::closed_error;
  use crate::types::associative::Associative;
  use crate::types::error::Error;
  use crate::types::{AssociationContent, Item};
  use std::future;
  use std::pin::Pin;
  use std::sync::Arc;
  use tokio::fs::File;
  use tokio::io::{AsyncReadExt, AsyncWriteExt};
  use tokio::sync::RwLock;

  #[derive(Debug)]
  pub struct StaticFile {
      pub file: File,
      pub closed: bool,
      pub path: String,
  }

  impl StaticFile {
      pub fn close(&mut self) -> Result<(), Error> {
          self.closed = true;
          Ok(())
      }

      pub fn is_closed(&self) -> bool {
          self.closed
      }

      pub fn put<'a>(
          &'a mut self,
          i: Item,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<(), Error>> + Send + 'a>> {
          match i {
              Item::Bytes(bs) => {
                  Box::pin(async move { self.file.write_all(&bs).await.map_err(|e| e.into()) })
              }
              _ => Box::pin(future::ready(Err(Error::expected("bytes")))),
          }
      }

      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = ItemResult> + Send + 'a>> {
          if self.is_closed() {
              return Box::pin(future::ready(Err(closed_error(true))));
          }
          let mut bs = [0u8; 1024];
          Box::pin(async move {
              let ct = self.file.read(&mut bs).await?;
              if ct == 0 {
                  // EOF, no more takes since it's static
                  self.closed = true;
              }
              Ok(Item::Bytes(bs[0..ct].to_vec()))
          })
      }
  }

  impl crate::serialize::Display for StaticFile {
      fn representation(&self) -> Item {
          Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::from([
              ("type".into(), "pipe".into()),
              ("file".into(), Item::String(self.path.clone())),
          ]))))
      }
  }

  pub fn file_in(i: Item) -> ItemResult {
      let path = String::try_from(i)?;
      let file = std::fs::File::options()
          .read(true)
          .write(true)
          .create_new(true)
          .open(path.clone())?;
      Ok(Item::In(super::In::StaticFile(Arc::new(RwLock::new(
          StaticFile {
              file: File::from_std(file),
              closed: false,
              path,
          },
      )))))
  }

  pub fn file_out(i: Item) -> ItemResult {
      let path = String::try_from(i)?;
      let file = std::fs::File::open(path.clone())?;
      Ok(Item::Out(super::Out::StaticFile(Arc::new(RwLock::new(
          StaticFile {
              file: File::from_std(file),
              closed: false,
              path,
          },
      )))))
  }
#+end_src
**** Network
How to interact with the network (TCP/IP sockets)
#+begin_src rust :tangle src/pipes/net.rs
  use crate::axiom::ItemResult;
  use crate::pipes::closed_error;
  use crate::types::associative::Associative;
  use crate::types::error::Error;
  use crate::types::{self, wrap, AssociationContent, Int, Item};
  use futures::future::FutureExt;
  use std::future::{self};
  use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
  use std::pin::Pin;
  use std::str::FromStr;
  use std::sync::Arc;
  use tokio::io::{AsyncReadExt, AsyncWriteExt};
  use tokio::net::{TcpListener, TcpStream};
  use tokio::sync::RwLock;

  #[derive(Debug)]
  pub struct Socket {
      pub socket: TcpStream,
      pub addr: SocketAddr,
      pub closed: bool,
  }

  impl Socket {
      pub fn close(&mut self) -> Result<(), Error> {
          Ok(())
      }

      pub fn is_closed(&self) -> bool {
          self.closed
      }

      pub fn put<'a>(
          &'a mut self,
          i: Item,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<(), Error>> + Send + 'a>> {
          match i {
              Item::Bytes(bs) => {
                  //let mut socket = self.socket.clone();
                  Box::pin(async move { self.socket.write_all(&bs).await.map_err(|e| e.into()) })
              }
              _ => Box::pin(future::ready(Err(Error::expected("bytes")))),
          }
      }

      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = ItemResult> + Send + 'a>> {
          if self.is_closed() {
              return Box::pin(future::ready(Err(closed_error(true))));
          }
          let mut bs = [0u8; 1024];
          Box::pin(async move {
              let n = self.socket.read(&mut bs).await?;
              if n == 0 {
                  self.closed = true;
              }
              Ok(Item::Bytes(bs[..n].to_vec()))
          })
      }
  }

  impl crate::serialize::Display for Socket {
      fn representation(&self) -> Item {
          Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::from([
              ("type".into(), "tunnel".into()),
              ("realm".into(), "tcp".into()),
              ("address".into(), Item::String(self.addr.to_string())),
          ]))))
      }
  }

  // Server sockets
  #[derive(Debug)]
  pub struct ServerSocket {
      pub socket: TcpListener,
      pub closed: bool,
  }

  impl ServerSocket {
      pub fn close(&mut self) -> Result<(), Error> {
          Ok(())
      }

      pub fn is_closed(&self) -> bool {
          self.closed
      }

      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = ItemResult> + Send + 'a>> {
          if self.is_closed() {
              return Box::pin(future::ready(Err(closed_error(true))));
          }
          Box::pin(async move {
              let (socket, addr) = self.socket.accept().await?;

              Ok(Item::Tunnel(super::Tunnel::Socket(Arc::new(RwLock::new(
                  Socket {
                      socket,
                      addr,
                      closed: false,
                  },
              )))))
          })
      }
  }

  impl crate::serialize::Display for ServerSocket {
      fn representation(&self) -> Item {
          Item::Assoc(Associative::Assoc(Arc::new(AssociationContent::from([
              ("type".into(), "pipe".into()),
              (
                  "serversocket".into(),
                  "todo: fix serversocket local addr async issue".into(), //Item::String(self.socket.lock().await.local_addr().unwrap().to_string()),
              ),
          ]))))
      }
  }

  fn socket_addr(i: Item, j: Item) -> Result<SocketAddrV4, Error> {
      println!("socket: {:?} {:?}", i, j);
      let addr = Ipv4Addr::from_str(String::try_from(j)?.as_str())?;
      let port = Int::try_from(i)? as u16;
      Ok(SocketAddrV4::new(addr, port))
  }

  pub fn server_socket(i: Item, j: Item) -> types::Future<ItemResult> {
      match socket_addr(i, j) {
          Ok(addr) => Box::pin(TcpListener::bind(addr).map(|l| {
              Ok(Item::Out(super::Out::ServerSocket(Arc::new(RwLock::new(
                  ServerSocket {
                      socket: l.unwrap(),
                      closed: false,
                  },
              )))))
          })),
          Err(e) => Box::pin(future::ready(Err(e))),
      }
  }

  // pub fn server_socket(env: Environment) -> environment::Future {
  //     let addr = env.pop();

  //     let inner_env = Environment::try_from(tos);
  //     match inner_env {
  //         Ok(inner) => Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),
  //         Err(e) => env.push(Item::Error(e)).into(),
  //     }
  // }

  impl From<std::net::AddrParseError> for Error {
      fn from(err: std::net::AddrParseError) -> Error {
          Error::create(wrap("addrparse".into()), &err.to_string())
      }
  }
#+end_src
**** Channels
Implement the =handoff= type
#+begin_src rust :tangle src/pipes/channel.rs
  use crate::associative::Associative;
  use crate::axiom::ItemResult;
  use crate::pipes;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::{self, Item};
  use flume;
  use std::future;
  use std::sync::Arc;

  #[derive(Debug, Clone)]
  pub struct Handoff<T>(flume::Sender<T>, flume::Receiver<T>);

  #[derive(Debug, Clone)]
  pub struct Filled {
      contents: types::List,
  }

  impl Handoff<Item> {
      pub fn new() -> Handoff<Item> {
          let (in_, out) = flume::bounded::<Item>(0);
          Handoff(in_, out)
      }

      pub fn put(self, i: Item) -> types::Future<Result<(), Error>> {
          Box::pin(async move {
              self.0
                  .send_async(i)
                  .await
                  .map_err(|_| pipes::closed_error(false))
          })
      }

      pub fn take(self) -> types::Future<ItemResult> {
          Box::pin(async move {
              self.1
                  .recv_async()
                  .await
                  .map_err(|_| pipes::closed_error(true))
          })
      }
  }

  impl Filled {
      pub fn new(l: types::List) -> Filled {
          Filled { contents: l }
      }

      pub fn take(mut self) -> types::Future<ItemResult> {
          let l = Arc::make_mut(&mut self.contents);
          Box::pin(future::ready(
              l.pop_front().ok_or(pipes::closed_error(true)),
          ))
      }
  }

  impl crate::serialize::Display for Handoff<Item> {
      fn representation(&self) -> Item {
          Item::Assoc(Associative::Assoc(Arc::new(
              types::AssociationContent::from([
                  ("type".into(), "pipe".into()),
                  ("handoff".into(), "todo: id-or-hash here".into()),
              ]),
          )))
      }
  }

  impl crate::serialize::Display for Filled {
      fn representation(&self) -> Item {
          Item::Assoc(Associative::Assoc(Arc::new(
              types::AssociationContent::from([
                  ("type".into(), "pipe".into()),
                  ("filled".into(), "todo: id-or-hash here".into()),
              ]),
          )))
      }
  }

  pub fn handoff(env: Environment) -> types::Future<Environment> {
      env.push(Item::Tunnel(pipes::Tunnel::Handoff(Handoff::new())))
          .into()
  }

  pub fn filled(mut env: Environment) -> types::Future<Environment> {
      let l = types::List::try_from(env.pop()).unwrap();
      env.push(Item::Out(pipes::Out::Filled(Filled::new(l))))
          .into()
  }
#+end_src
** Issues
*** TODO Interactive mode
run with =kcats -i= for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
*** TODO Install the lexicon in the proper place
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.
*** TODO Package the binary for various platforms
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
*** TODO 'read' on invalid edn consumes the string argument
It should attempt to parse before popping the item off the stack.
*** DONE Optimize memory allocation
**** DONE Lists
#+begin_src kcats
[[a b]] [a] lookup
#+end_src

#+RESULTS:
: b
*** TODO pack and unpack are not inverse
#+begin_src kcats :result code
[1 2 3] unpack pack
#+end_src

#+RESULTS:
: 
: [[2 3 1]]

It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.
*** TODO pipe as list-like thing
Are both words =put= and =pack= needed (similarly =take= and =unpack=)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).

Also take in other langs takes a number arg (how many to take). You
could do this as =[take] 5 times=, but that's less efficient. Could
maybe create a new word like =split= or =unload= or something.

The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. There should be a nonblocking version
*** DONE true and false are not words?
#+begin_src kcats :results code
[true] unwrap word?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

If you didn't know =true= was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).

It's messy because true/false are the only "words" you can put onto
the stack without wrapping.

There are several ways to deal with this:

+ just leave as is (these look like words but don't act like them)

+ Use something else for boolean values, like 0b 1b or something (ugly, no)

+ Revert to allowing bare words (that aren't actions) to go onto the
  stack unwrapped, so that true/false aren't different

Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.
*** DONE Division by zero panics
*** INPROGRESS Implement pipes
**** DONE Write to a file
#+begin_src kcats
  [[file "/tmp/bar4"]] pipe-in

  ["hello world!"
   "Nice to meet you!"
   "My name is kcats"]

  ["\n" join bytes put]

  step
#+end_src

#+RESULTS:
: [[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-in

  "hello world!"

  bytes put

#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar101r7"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-out

  take

  string

#+end_src

#+RESULTS:
: "hello world!" [[type pipe] [file "/tmp/bar101r7"]]

**** DONE Read from a file
#+begin_src kcats :results code
"" [string join] [[file "/tmp/bar2"]] pipe-out

assemble 
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [pipe]] [type error]] [[file "/tmp/bar2"] [type pipe]] ""]
expression: [swap [string join] dip [closed? not] shield [take swap [string join] dip [closed? not] shield] loop discard]
#+end_src

#+begin_src kcats :results code
dictionary [assemble spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[type error] [reason "word is not defined"] [asked [fail]]]
 "Lookup attempted on non association value"
 [spec]
 [[definition [swap [take swap] swap pack [dip] join [[closed? not]] dip while discard]]
  [spec [[pipe program] [item]]]]]
#+end_src
**** DONE Close a pipe
#+begin_src kcats :results code
[[file "/tmp/foopytoop"]] pipe-in "foo" bytes put close "bar" bytes put
#+end_src

#+RESULTS:
#+begin_src kcats
[[type pipe] [file "/tmp/foopytoop"]]
#+end_src
**** DONE Serialize pipes with something sane
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
**** DONE Sockets
***** DONE Server Sockets
#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(11211) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
  "127.0.0.1" 12345 serversocket 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(12345) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out ;; server socket
take ;; accept connection by taking a socket out of the pipe
"foo\n" bytes put ;; write a message to the socket
take string ;; get a message from the socket
[discard ;; close the socket
 discard] ;; close the server socket
dip
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [string]] [unwound [take "foo\n" bytes put take string [discard discard] dip]] [type error] [reason "type mismatch"]]
#+end_src

***** DONE Sockets

***** INPROGRESS Assemble is broken when reading files
I think it's because =closed?= is broken.

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out assemble
#+end_src

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out take discard take discard closed? 
#+end_src

#+RESULTS:
#+begin_src kcats
checking file closed false
Got 3 bytes
checking file closed false
Got 0 bytes
Closing!
checking file closed false
[] [string join] ""
#+end_src

I see the problem. When we clone the pipe, we also clone the =closed=
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc<Mutex> and not just the
file field. And when we modify the boolean, we shouldn't 
**** DONE Convert In/Out traits to enums in pipes modules
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.

I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.

**** TODO Composable transforms
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.

I suppose pump could take an optional transducer-like thing, and *those*
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.

Maybe the first thing to do is implement transducers?

**** INPROGRESS Filled pipes
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.

#+begin_src kcats
[1 2 3] filled take
#+end_src

#+RESULTS:
: 1 [[type pipe] [filled todo: id-or-hash here]]

*** DONE 'Fail' is not defined
We need to be able to throw our own errors (eg lookup tries to do this)

#+begin_src kcats
1 2 [1 "two" +] [fail] recover 3 4 
#+end_src

#+RESULTS:
: converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
: [[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1

*** DONE 'dictionary' doesn't allow access to the data inside definitions
The definition is just shown as the word itself and we can't access
spec, definition etc.

#+begin_src kcats :results code
dictionary [swap spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item a] [item b]] [[item b] [item a]]]
#+end_src

*** INPROGRESS Use a single word for all derivation/conversion
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.

Here we use the association shorthand for =[[type bytes]]=
#+begin_src kcats
"foo" [bytes] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [bytes] "foo"]

Here's a typical invocation
#+begin_src kcats
"foo" [[type bytes]] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [[type bytes]] "foo"]

Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
#+begin_src kcats
"foo"
[[bytes]
 [[type aes-key]
  [length 128]]]
[derive]
step
#+end_src

#+RESULTS:
: No spec for derive!
: No spec for derive!
: 
: [[] [[type aes-key] [length 128]] [] [bytes] "foo"]

This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.

The difficulty is how to implement it. A naive way would just make
=derive= a multimethod and add lots of methods. The problem is the
=decide= based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use =decide= internally).

But maybe even that isn't ideal - we could also lookup by =[sourcetype
destinationtype]= pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.

It should be possible to implement the =destinationtype= based lookup
pretty easily. Make =derive= a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).

Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
#+begin_src kcats
[derive]
[[[bytes string] [string]]] association wrap
[float type wrap swap join ;; 1 [string] => [number string]
 lookup execute] join
[definition] swap pack
wrap
inscribe

"foo" bytes [string] 
derive 
#+end_src

#+RESULTS:
: No spec for derive!
: 
: stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
: expression: [lookup execute]


Ok here's the basic impl. Afterward, should change =string= to
=++string= to make them non-public, should use =[string] derive=
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like =derivations=, but that
sticks out as different - it's a data structure and not an action
word.
#+begin_src kcats
;; add some conversions
derivations [[bytes string] [string]] assign
;; the list of conversions
[[[bytes string] [string]]] association

"foo" bytes [string]


;; determine the current type and look up the conversion
[[type] shield wrap] dipdown [join wrap] dip 
swap lookup execute
#+end_src

#+RESULTS:
: 
: ["foo"]
#+begin_src kcats
dictionary [assign spec] lookup 
#+end_src

#+RESULTS:
: 
: [[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]

#+begin_src kcats 
[[[a b] c]] [[a b]] lookup
#+end_src

#+RESULTS:
: 
: [c]

#+begin_src kcats
[[string [foo]]] [string] lookup
#+end_src
#+RESULTS:
: 
: [[foo]]

Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
#+begin_src kcats :results code
[+] unwrap type
#+end_src

#+RESULTS:
#+begin_src kcats

[[[reason "type mismatch"] [type error] [unwound [count 1 = [[+]] unwrap evert first [[[first [type] unwrap =] [first second] [first first] if] [[]]] unwrap branch [[[[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] +]] unwrap evert first swap discard [[[[association] unwrap]]] unwrap swap [[]] unwrap or [[[[nothing?] shield] dip swap [or] shielddown] [] [[unpack swap [[execute] shielddown] dip swap] dip or] [execute] recur] execute swap discard swap discard]] [asked [list]]] +]
#+end_src

#+begin_src kcats
[] [] [] [discard [default] unwrap] if
#+end_src

#+RESULTS:
: 
: [default]

#+begin_src kcats
[[bar 12]]
[
[[foo] lookup]
[[bar] lookup]
[5]
[6]
]
swap [nothing?] shield
[[unpack] dip swap execute [nothing?] shield] loop
;;sink discard discard
#+end_src

#+RESULTS:
: 
: [[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]

#+begin_src kcats
[[bar 12]]
[[[foo] lookup]
 [[bar] lookup]]
[execute] any?
#+end_src

#+RESULTS:
: 
: [12 [[bar 12]]]

#+begin_src kcats
1 2 or
#+end_src

#+RESULTS:
: 
: [1]

Now that we have a fairly reliable =type= implementation, we can
dispatch on both =to= and =from= types for =derive=.

#+begin_src 

#+end_src
*** DONE Change boolean operators to retain values
=or= and =and= should return the actual value if it is truthy, instead
of =true=. But neither should ever return =[]=, but use =false=
instead.
#+begin_src kcats
2 [] or
#+end_src

#+RESULTS:
: 2

#+begin_src kcats
1 10 inc 1 range unpack swap [*] step
#+end_src

#+RESULTS:
: 3628800

This does bring up the question of whether the boolean type is really
needed. It may be possible to use =[]= as =false= and anything else as
=true= (=1= for example, or maybe the bare word =true= which then
wouldn't carry any other meaning). Or possible use some other word
than =true=, eg =something=.

Does this make sense when applied to boolean logic?

#+begin_example
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
#+end_example

I think it doesn't make sense.

Maybe yes/no?

#+begin_example
yes or no = yes ?
#+end_example
#+begin_src kcats
5 3 =
#+end_src

#+RESULTS:
: 
: [[]]

#+begin_src kcats
5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide
#+end_src

#+RESULTS:
: 
: ["five" 5]

#+begin_src kcats
[3 5 7] [even?] any? false =
#+end_src

#+RESULTS:
: 
: stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
: expression: [false =]
*** DONE 'recover' is broken
#+begin_src kcats
[+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
[[expression [[+] [3] recover]]] environment advance advance
eval-step
advance
advance
advance
advance
advance
eval-step
advance
advance
advance
#+end_src

#+RESULTS:
: Env: [List([List([])]), Word(0x5a56c7a6c3c0 : "unwrap"), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield"), List([Entry(Entry { word: 0x5a56c7a7ddf0 : "unpack", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a7ddf0 : "unpack")]), List([List([String("b"), String("c")]), String("a")])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([Entry(Entry { word: 0x5a56c7a73c80 : "++lookup", examples: None, spec: Some([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x5a56c7a668b0 : "dip", examples: Some([List([List([Int(1), Int(8), List([Word(0x5a56c7a570f0 : "inc")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(2), Int(8)])]), List([List([Int(1), Int(2), List([Word(0x5a56c7a621b0 : "dec")]), Word(0x5a56c7a6c3c0 : "unwrap"), List([Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(3), Word(0x5a56c7a621b0 : "dec")])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program"), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield")]), Word(0x5a56c7a79bd0 : "loop"), List([Word(0x5a56c7a65c40 : "something?")]), List([String("Lookup attempted on non association value"), Entry(Entry { word: 0x5a56c7a55850 : "fail", examples: None, spec: Some([List([Word(0x5a56c7a66340 : "string")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: [] })]), List([Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a89c10 : "if"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Env({ stack: [], expression: [[+] [3] recover] })])]), Word(0x5a56c7a6c3c0 : "unwrap"), Entry(Entry { word: 0x5a56c7a7bf60 : "evert", examples: Some([List([List([Int(1), Int(2), Int(3), List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a7bf60 : "evert")]), List([Int(6), Int(5), Int(4), List([Int(3), Int(2), Int(1)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list"), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a88e20 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a88e20 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
: handle is Word(0x5a56c7a5eab0 : "handle") Word(0x5a56c7a5eab0 : "handle")
: expr contains handle? false
: unhandled err!
: 
: stack: [[[type error] [asked [association (unfinished tryfrom impl)]] [reason "type mismatch"]]]
: expression: [[[]] unwrap [[[swap association?] [something?]] [execute] every?] shield [unpack swap [++lookup] dip [[[swap association?] [something?]] [execute] every?] shield] loop [something?] ["Lookup attempted on non association value" fail] [discard] if count [[[[stack []] [expression [[+] [3] recover]]]]] unwrap evert first swap [[[[expression] lookup count [[positive?] [<=]] [execute] every?] [[errored?] shield not]] [execute] every?] [eval-step] while swap discard advance eval-step advance advance advance advance advance eval-step advance advance advance]
*** DONE Fix handle in nested env
=handle= doesn't work properly in a nested environment. That is
because =eval= has some logic to check for uncaught exceptions, but
the =advance= self-hosted evaluator doesn't.

#+begin_src kcats
1 + handle error?
#+end_src

#+RESULTS:
: Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
: handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
: expr contains handle? true
: Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")
: 
: [true 1]

#+begin_src kcats
+ handle type
#+end_src

#+RESULTS:
#+begin_example
Env: [Word(0x577eb3e95b00 : "handle"), Entry(Entry { word: 0x577eb3ea5000 : "type", examples: Some([List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Int(1)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Float(1.0)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([])]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo"), Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo")]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20780 : "attr"), String("blah")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3f20570 : "attr1"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20640 : "attr2"), String("blah")])]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3f202d0 : "url")]), List([Word(0x577eb3edb6e0 : "value"), String("http://foo.com")])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3f202d0 : "url")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? true
Word(0x577eb3e95b00 : "handle") vs Word(0x577eb3e95b00 : "handle")
Env: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? false
unhandled err!

stack: [[[reason "not enough items on stack"] [asked [consume]] [type error]]]
expression: [[[[nothing?] [[nothing] unwrap]] [[association?] [[[[type] lookup] [[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[association] unwrap]] [execute] any?]] [[list?] [[list] unwrap]] [[number?] [[number] unwrap]] [[word?] [[word] unwrap]] [[bytes?] [[bytes] unwrap]] [[string?] [[string] unwrap]] [[pipe?] [[pipe] unwrap]] [[error?] [[error] unwrap]]] decide swap discard]
#+end_example

Looks like the word =error?= is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
=type=, which expects the builtin version of =error?=).

#+begin_src kcats
[[expression [+]]] environment eval-step 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [expression []]]]

#+begin_src kcats
[[expression [1 +]]] environment advance advance advance 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [expression [+]]]]

#+begin_src kcats
[[expression [[[3]] [+ handle] dip]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [expression [+_handle [[[3]]] unwrap]]]]

#+begin_src kcats
[[expression [+ handle]]] environment eval-step eval-step
#+end_src

#+RESULTS:
: { stack: [], expression: [[[expression [+ handle]]] environment eval-step eval-step] }
: { stack: [[[expression [+ handle]]]], expression: [environment eval-step eval-step] }
: { stack: [[[stack []] [expression [+ handle]]]], expression: [eval-step eval-step] }
: { stack: [], expression: [+ handle] }
: { stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]], expression: [eval-step] }
: { stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], expression: [+ handle] }
: 
: [[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]]

There is a problem in the design where an error (with no =handle=) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.

A possible solution is to have whatever =eval= we're using halt but
remove the =halt= bit (in the current design it's the =is_handled=
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.

Also for nested envs we need several words to help deal with errors:

+ a word that tells whether the env will halt: that there's an error
  on ToS with halt bit set, and =handle= does not appear in the
  expression. The word can efficiently return =false= if ToS isn't an
  Error.

+ A word that removes the halt bit - as the last thing to do before
  exiting.

So what about the word =advance= that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In =eval= it's pretty obvious if we
halted on error - the expression isn't empty (that's the only other
reason to stop). We could see in =advance= that the expression got
longer, but isn't very obvious in many cases.

Another possibility is letting the expression unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
=recover= is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the expression that will know what to do. But
there may not be, and the end result is a major unwind of the
expression, at least, all the way to the deepest =recover=. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 

But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong *and*
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.

Maybe another possibility is unwinding the expression **into** the
error object. In other words, whatever expression items we lop off, we
save them in the error object, in a field named, say, =unwound= or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
expression from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
=rewind= or something, that restores the expression from the error on
ToS and clears the halt bit.

I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the expression item that threw the error so
we would still have it to retry. I'm thinking syntax like this:

#+begin_src kcats
[+] [[1 1] dip retry] recover
#+end_src

In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:

#+begin_src kcats
[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [expression [[1 1] dip retry]]]]
#+end_src

So we =dip= the numbers underneath the error, then calling =retry= on
an error will extract the =unwound= field (discarding the rest of the
error) and =execute= it. So then we end up with =1 1 +=.

Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.

#+begin_src kcats
  ;; there needs to be 3 numbers here to add/mult but we forgot!
  + * 1 2 3
  handle ;; catch the error here, stack is empty except the error
  [5 6 7] dip ;; put numbers underneath
  retry ;; rerun what failed before
#+end_src

#+RESULTS:
: 
: [3 2 1 65]

Now put it together using the higher-level =recover=

#+begin_src kcats
  [+ *] [[5 6 7] dip retry] recover
#+end_src

#+RESULTS:
: 
: [65]

*** DONE Lots of association-like objects that aren't
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait *and* make the trait object part of the
Item enum.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box<dyn Foo>), Quux(Quux) }
#+end_src

#+RESULTS:

Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar<'a> { Int(i32), Foo(&'a dyn Foo), Quux(&'a Quux) }
#+end_src

#+RESULTS:


#+begin_src kcats :results code
  dictionary [advance definition] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[[expression] lookup count] shield swap [[expression] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap discard]]
#+end_src

#+begin_src kcats :results code
  [[expression [1 1 +]]] environment eval-step [stack] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[1]]
#+end_src

#+begin_src kcats :results code
[] environment association?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats
dictionary [fail] lookup
#+end_src

#+RESULTS:
: [[spec [[string] [*]]] [definition []]]

*** DONE scoping of dictionary entries
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
=inscribe= (to add words) etc.

However I think a better design would be something like this:

#+begin_src kcats
  [[add1 [1 +]]] [3 add1] augment
#+end_src

Where the word =augment= takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.

It would be possible to nest calls to =augment= (where the program has
its own call to =augment=).

As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with =augment=.

There is some overlap in functionality here, between =decide= and
=augment= - both are designed to provide context. Maybe =decide= provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And =augment= provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where =join=
is just a common use case. In that case, maybe =augment= isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like =babel= - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like =lingo=.

#+begin_src kcats
  [[clone *] [square] assign] ;; operate on the dictionary - add word 'square'
  [3 square]
  lingo
#+end_src

would print 9.

The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.

Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting *that* word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. =update= should help.
**** What to call this word
+ learn (but unlearn after?)
+ specialize
+ extend
+ adapt
+ augment 
+ refine
+ supplement
+ babel
+ lingo <= front runner.
**** Implementation
It seems viable that we could use the stack to hold dictionary changes.

We'd have to retain a copy of the original dictionary to restore later.

An axiom word like =definitions= or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.

it'd be something like:

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float ;; d p n
  swapdown ;; d n p
  [redefine ;; p
   execute]
  dip ;; d
  redefine
#+end_src

#+RESULTS:
: 81

A few problems remaining above:
- [X] Need to specify the word inside the definition.
- [X] Need to explicitly convert the definition to an association.

But I think this proves the concept.

Probably want to eventually make a rust implementation.

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float
  swapdown
  [redefine] dip dictionary [square] lookup
 
#+end_src

#+begin_src kcats :results code 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  lingo 
#+end_src

#+begin_src kcats
  dictionary [square] [[definition [clone *]]
                       [spec [[number] [number]]]] assign
  [square] lookup
#+end_src

#+RESULTS:
: Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
: []

*** DONE Move environment stuff into own module
#+begin_src kcats :results code
  [[expression [1 2 3]]] environment 
#+end_src

#+RESULTS:
#+begin_src kcats
{ stack: [], expression: [[[expression [1 2 3]]] environment] }
{ stack: [[[expression [1 2 3]]]], expression: [environment] }

[[[stack []] [expression [1 2 3]]]]
#+end_src

#+begin_src kcats
1 2 +
#+end_src

#+RESULTS:
: 
: [3]

*** DONE When printing results, don't wrap the stack
Evaling =1 1 += should print =2=, not =[2]=. We don't have to wrap the
input, so why wrap the output.

*** DONE Update pipes to use enums instead of traits
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.

Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.

*** CANCELED Recover clears the stack built up in the try program
#+begin_src kcats :results code
 [2 3 "four" * +] [] recover
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [unwound [* +]] [type error] [asked [number]]]
#+end_src

Apparently this was my design. I am not so sure about it now, that we
have =retry=. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of =retry= because the recovery
can't pick up where the program left off.

Maybe =recover= and =retry= are mutually exclusive.

We could also use =retry= with =handle=:

#+begin_src kcats
2 3 "four" * + handle [discard 4] dip retry
#+end_src

#+RESULTS:
: 14

To make this work you have to know which item is the potential problem.

Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.

#+begin_src kcats
[2 3 ["four" 4] alternates * +] retry 
#+end_src

*** DONE List access and update by index
I think re-using =lookup= and =assign= for lists, using their index, makes sense here:
#+begin_src kcats
  [5 10 15 20] [1] lookup
#+end_src
should print 10.

#+begin_src kcats
  [5 10 15 20] [1] 30 assign
#+end_src

#+RESULTS:
: [5 30 15 20]

 would leave =[5 30 15 20]=.

 The problem here is that this is ambiguous:

#+begin_src kcats
  [[a b] [c d]] [0] [d e] assign

  ;; is it (assigned as a hashmap by key)
  ;;[[a b] [c d] [0 [d e]]]

  ;; or is it (assigned as a vector by index)
  ;;[[d e] [c d]]
#+end_src

#+RESULTS:
: [[d e] [c d]]

We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify =association=
first.

lets check some corner cases - creating nested lists
#+begin_src kcats
  [1 2 3] [1 0 0] "foo" assign
;; should be [1 [[foo]] 3]
#+end_src

#+RESULTS:
: [1 [["foo"]] 3]

What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with =Nothing=, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.

#+begin_src kcats
  [1 2 3] [1 2] "foo" assign
#+end_src

#+RESULTS:
: [1 [[] [] "foo"] 3]

Now let's test mixed list/assoc

#+begin_src kcats
  [1 2 3] [1 foo baz 0] "bar" assign
#+end_src

#+RESULTS:
: [1 [[foo [[baz [[0 "bar"]]]]]] 3]

Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.

Now check the changes for =lookup=

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] lookup
#+end_src

#+RESULTS:
: 45

make sure update works too

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] [inc] update
#+end_src

#+RESULTS:
: [1 4 [34 6 46] 99 23]

#+begin_src kcats
true not
#+end_src

#+RESULTS:
: []

*** DONE write 'let'
#+begin_src kcats :results code
  [[a [1 1 1]]
   [b [6 7 *]]]
  [a b +]
  [wrap
   [[[1] [shield
          wrap
          [[[spec [[] [item]]]]
           [definition]] dip
          assign] ;; build a full entry
     update]
    map association join]
   join] dip
  lingo
#+end_src

#+RESULTS:
#+begin_src kcats
43
#+end_src

i am not sure if just taking the top value is correct here.


#+begin_src kcats :results code
  dictionary
  [[a [1 1 1]]
   [b [6 7 *]]]
  [[1] [shield] update] map association join
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [type error] [unwound [lingo]] [asked [program]]] [a b +] [[- [[examples [[[2 1 -] [1]] [[1.1 2.2 -] [-1.1]] [[2.2 1 -] [1.2]]]] [spec [[number number] [number]]]]] [read [[spec [[string] [item]]] [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]] [first [[spec [[list] [item]]] [examples [[[[4 5 6] first] [4]]]]]] [close [[spec [[[pipe p]] [[pipe p]]]]]] [if [[definition [[shield] dipdown branch]] [spec [[[program false-branch] [program true-branch] [program condition]] [*]]] [examples [[[5 [5 =] [3 *] [4 +] if] [15]] [[6 [5 =] [3 *] [4 +] if] [10]]]]]] [assemble [[definition [swap [take swap] swap pack [dip] join [[closed? not]] dip while discard]] [spec [[pipe program] [item]]]]] [dip [[examples [[[1 8 [inc] dip] [2 8]] [[1 2 [dec] unwrap [+] dip] [3 dec]]]] [spec [[program [item a]] [[item a] *]]]]] [nothing? [[examples [[[[] nothing?] [true]] [[1 nothing?] [false]] [[false nothing?] [false]]]] [spec [[item] [boolean]]] [definition [[] =]]]] [sqrt [[spec [[number] [number]]]]] [lookup [[examples [[[[[a b] [c d]] [a] lookup] [[b] unwrap]] [[[[a b] [c d]] [e] lookup] [[]]] [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] unwrap]]]] [spec [[[list keys] list] [item]]] [definition [[[[swap list?] [something?]] [execute] every?] [unpack swap [++lookup] dip] while [something?] [[[type error] [asked [association]] [reason "Lookup attempted on non-associative value"]] fail] [discard] if]]]] [filled [[spec [[list] [pipe]]] [definition []]]] [assign [[spec [[[item value] [list keys] association] [association]]] [examples [[[[[a b] [c d]] [a] 5 assign] [[[a 5] [c d]] association]] [[[[a b] [c d]] [e] 5 assign] [[[a b] [c d] [e 5]] association]] [[[[a b] [c [[d e]]]] [c d] 5 assign] [[[a b] [c [[d 5]]]] association]] [[[[a b] [c [[d e]]]] [1 0] 5 assign] [[[a b] [c [5]]]]] [[[1 2 3] [1 0 0] "foo" assign] [[1 [["foo"]] 3]]] [[[1 2 3] [1 2] "foo" assign] [[1 [[] [] "foo"] 3]]] [[[1 2 3] [1 foo baz 0] "bar" assign] [[1 [[foo [[baz [[0 "bar"]]]]]] 3]]]]]]] [pipe-out [[spec [[item] [pipe]]] [definition [[[[type [file] unwrap =] [value file-out]] [[type [ip-port] unwrap =] [clone [address] lookup [[port] lookup] dip serversocket]] [[list?] [+kcats.pipe/->filled]]] decide]]]] [association [[spec [[item] [association]]] [examples [[[[[a b] [c d]] association [[c d] [a b]] association =] [true]] [[[[a b] [c d]] [[c d] [a b]] association =] [false]] [[[[a b] [c d]] [[a b] [c d]] association =] [false]]]]]] [shield [[definition [[snapshot] dip inject first]] [examples [[[1 2 3 [=] shield] [1 2 3 false]]]] [spec [[program] [item]]]]] [< [[spec [[number number] [boolean]]]]] [pair [[examples [[[1 2 pair] [[1 2]]] [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]] [spec [[item item] [list]]] [definition [[wrap] dip pack]]]] [buffer [[spec [[integer] [pipe]]] [definition []]]] [swapdown [[examples [[[1 2 3 swapdown] [2 1 3]]]] [spec [[[item a] [item b] [item c]] [[item a] [item c] [item b]]]]]] [string [[examples [[[1 string] ["1"]] [[[1 2 3] string] ["[1 2 3]"]] [[[] string] ["[]"]]]] [spec [[item] [string]]]]] [eval-step [[examples [[[[[expression [1 inc]]] environment eval-step eval-step [stack] lookup] [[2]]]]] [spec [[list] [list]]]]] [inject [[examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]] [definition [swap evert unpack dip evert]] [spec [[program list] [list]]]]] [association? [[spec [[item] [boolean]]] [examples [[[[[a b] [c d]] association?] [true]]]]]] [b 42] [serversocket [[spec [[string integer] [pipe]]]]] [every? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [unpack swap] swap pack [dip swap not] join wrap [dip or] join [[] [[[nothing?] shield] dip swap [or] shielddown] [not]] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] every?] [true]] [[[2 4 5] [even?] every?] [false]] [[[] [even?] every?] [true]] [[[2 4 6] [] every?] [true]] [[11 [2 4 6] [+ odd?] every?] [true 11]] [[12 [[even?] [positive?] [3 rem 0 =]] [execute] every?] [true 12]]]]]] [both? [[definition [sink pair swap every?]] [examples [[[1 2 [odd?] both?] [false]] [[1 3 [odd?] both?] [true]]]] [spec [[program item item] [boolean]]]]] [filter [[definition [[snapshot [] swap] dipdown [[clone] dip clone wrap swapdown] swap pack [join inject first [[pack]] [[discard]] branch swapdown dip] join step discard]] [examples [[[[1 2 3] [odd?] filter] [[1 3]]] [[[2 4 6] [odd?] filter] [[]]] [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]] [spec [[program list] [list]]]]] [file-in [[spec [[string] [pipe]]]]] [shielddowndown [[definition [shield [discard discard] dip]] [spec [[[program p] [item consumed] [item consumed]] [[item result]]]] [examples [[[1 2 3 [+ +] shielddowndown] [1 6]]]]]] [snapshot [[examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]] [[snapshot] [[]]]]] [spec [[] [list]]] [definition [[] evert clone evert unwrap]]]] [* [[spec [[number number] [number]]]]] [dictionary [[spec [[] [list]]]]] [word? [[examples [[[foo word?] [true]] [[[foo] unwrap word?] [true]] [[true word?] [false]]]] [spec [[item] [boolean]]]]] [put [[spec [[item [pipe in]] [[pipe in]]]]]] [max [[spec [[number number] [number]]] [definition []]]] [positive? [[spec [[number] [boolean]]] [definition [0 >]]]] [float [[examples [[[1 2 3 float] [2 3 1]]]] [spec [[[item a] [item b] [item c]] [[item c] [item a] [item b]]]]]] [zip [[examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]] [spec [[[list values] [list keys]] [association]]] [definition [[[]] dipdown [[unpack wrap] dip pack swap [pack] dip] step discard]]]] [quot [[definition []] [spec [[number number] [number]]]]] [reverse [[spec [[list] [list]]] [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]] [string? [[examples [[["hi" string?] [true]] [["" string?] [true]] [[["hi"] string?] [false]] [[true string?] [false]]]] [spec [[item] [boolean]]]]] [disassemble [[definition [[swap [put] dip] join [nothing? not] swap while discard]] [spec [[program item [pipe in]] [[pipe in]]]]]] [step [[examples [[[1 [2 3 4] [*] step] [24]] [[1 [] [*] step] [1]]]] [spec [[program list] [*]]]]] [wrap [[examples [[[1 wrap] [[1]]] [[[1 2] wrap] [[[1 2]]]]]] [spec [[item] [list]]]]] [> [[spec [[number number] [boolean]]] [examples [[[2 1 >] [true]] [[1.1 2.2 >] [false]] [[2.2 1 >] [true]]]]]] [zero? [[spec [[number] [boolean]]] [definition [0 =]] [examples [[[0 zero?] [true]] [[0 zero?] [true]] [[-0.00001 zero?] [false]] [[1.1 zero?] [false]]]]]] [addmethod [[spec [[[pair condition] [program combinator] word] []]] [definition [float [wrap dictionary swap lookup] shield [wrap swap pack] dipdown float [float [execute] dip] join inject swap inscribe]]]] [lingo [[definition [dictionary sink [clone] dipdown [execute] dip float swapdown [redefine execute] dip redefine]] [examples [[[[[square] [[definition [clone *]] [spec [[number] [number]]]] assign] [9 square] lingo] [81]]]] [spec [[[program enriched-lexicon] [program dictionary-modifier]] [*]]]]] [redefine [[spec [[association] []]]]] [unassign [[spec [[[item key] association] [association]]] [examples [[[[[a b] [c d]] [a] unwrap unassign] [[[c d]] association]] [[[[a b] [c d]] [e] unwrap unassign] [[[a b] [c d]] association]]]]]] [swap [[examples [[[1 2 3 swap] [1 3 2]]]] [spec [[[item a] [item b]] [[item b] [item a]]]]]] [prepend [[spec [[item list] [list]]] [examples [[[[1 2] 3 prepend] [[3 1 2]]]]] [definition [wrap swap join]]]] [spawn [[spec [[program] []]] [definition []]]] [recur [[spec [[[program rec2] [program rec1] [program true-branch] [program pred]] [*]]] [examples [[[3 [1 <=] [] [clone dec] [execute *] recur] [6]]]]]] [closed? [[spec [[pipe] [boolean]]]]] [sink [[spec [[[item a] [item b] [item c]] [[item b] [item c] [item a]]]] [examples [[[1 2 3 sink] [3 1 2]]]]]] [negative? [[spec [[number] [boolean]]] [definition [0 <]]]] [evaluate [[examples [[[[[expression [1 2 3 4 + *]]] environment evaluate [stack] lookup] [[14 1]]]]] [spec [[list] [list]]]]] [not [[examples [[[1 even? not] [true]] [[false not] [true]] [[true not] [false]] [[[] not] [true]]]] [spec [[item] [boolean]]]]] [timeout [[definition []] [spec [[integer] [pipe]]]]] [environment [[examples [[[[[expression [1 2 3]]] environment eval-step [stack] lookup] [[1]]]]] [spec [[association] [list]]]]] [bytes? [[spec [[item] [boolean]]]]] [update [[examples [[[[[a 1] [b 2]] [b] [inc] update] [[[a 1] [b 3]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update] [[[a [[c 4] [d 5]]] [b 2]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update] [[[a [[c 15] [d 5]]] [b 2]] association]] [[[[a 1] [b 2]] [d] [5] update] [[[a 1] [b 2] [d 5]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update] [[[a [[c 3] [d 5] [e 11]]] [b 2]] association]]]] [definition [[[lookup] shield] dip shielddown assign]] [spec [[program [list keys] association] [association]]]]] [tunnel [[definition [[[[type [ip-port] unwrap =] [clone [port] lookup [[address] lookup] dip !**java.net.Socket.]]] decide]] [spec [[item] [pipe]]]]] [number? [[spec [[item] [boolean]]] [examples [[[[1] number?] [false]] [[[] number?] [false]] [[5 number?] [true]] [[5.01 number?] [true]]]]]] [loop [[spec [[program [item flag]] [*]]] [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]] [select [[definition []] [spec [[[list pipes]] [item pipe [list pipes]]]]]] [evert [[spec [[list] [list *]]] [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]] [advance [[spec [[environment] [environment]]] [definition [[[expression] lookup count] shield swap [[expression] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap discard]]]] [dipdown [[spec [[program [item a] [item b]] [[item a] [item b] *]]] [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]] [map [[spec [[program list] [list]]] [examples [[[[1 2 3] [inc] map] [[2 3 4]]] [[1 [1 2 3] [+] map] [[2 3 4] 1]] [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]] [[7 9 [+] [] map] [[+] 9 7]]]] [definition [[snapshot [] swap] dipdown [wrap swap clone float] swap pack [[swap join] dip inject first swap [pack] dip] join step discard]]]] [primrec [[examples [[[5 [1] [*] primrec] [120]]]] [spec [[[program rec1] [program exit] [number data]] [*]]] [definition [[execute] swap join [[discard] swap join] dip [[zero?]] dipdown [[clone dec]] dip recur]]]] [execute [[spec [[program] [*]]] [examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]]]] [clone [[examples [[[1 2 3 clone] [1 2 3 3]]]] [spec [[[item a]] [[item a] [item a]]]]]] [or [[examples [[[1 odd? 3 even? or] [true]] [[1 2 or] [1]] [[[] 2 or] [2]] [[[] [] or] [false]]]] [spec [[item item] [item]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 2 =] [[]]] [[1 1 =] [true]] [[[] [] =] [true]] [[[1] [] =] [[]]] [[[1 [false]] [1 [false]] =] [true]] [[[1 ["foo"]] [1 ["foo"]] =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [[]]] [[[] true =] [[]]] [[[1 ["foo"]] [1 ["bar"]] =] [[]]] [[[[] [] association =] [true]]]]]]] [take [[spec [[[pipe out]] [item [pipe out]]]]]] [something? [[definition [nothing? not]] [spec [[item] [boolean]]] [examples [[[1 something?] [true]] [[false something?] [true]] [[[] something?] [false]]]]]] [type [[examples [[[[[foo 1]] type] [[foo] unwrap]] [[1] [[number] unwrap]] [[1] [[number] unwrap]] [[[]] [[nothing] unwrap]] [["foo" bytes] [[bytes] unwrap]] [["foo"] [[string] unwrap]] [[[[type foo]] [[foo] unwrap]]] [[[[type foo] [attr "blah"]] [[foo] unwrap]]] [[[[attr1 foo] [attr2 "blah"]] [[association] unwrap]]] [[[[foo 1]] [[foo] unwrap]]] [[[[type url] [value "http://foo.com"]] type] [[url] unwrap]]]] [spec [[item] [item]]] [definition [[[[nothing?] [[nothing] unwrap]] [[association?] [[[[type] lookup] [[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[association] unwrap]] [execute] any?]] [[list?] [[list] unwrap]] [[number?] [[number] unwrap]] [[word?] [[word] unwrap]] [[bytes?] [[bytes] unwrap]] [[string?] [[string] unwrap]] [[pipe?] [[pipe] unwrap]] [[error?] [[error] unwrap]]] decide swap discard]]]] [fail [[spec [[association] [*]]]]] [decide [[examples [[[5 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [5 "five"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [9 "something else"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]]] decide] [9 []]]]] [spec [[[association test-expr-pairs]] [*]]]]] [break [[spec [[environment [program condition]] [environment [program condition]]]] [definition [[[[[expression] lookup something?] [swap execute not]] [execute] every?] [eval-step] while]]]] [unwrap [[spec [[list] [*]]] [examples [[[[1] unwrap] [1]]]]]] [handoff [[spec [[] [pipe]]] [definition []]]] [even? [[spec [[number] [boolean]]]]] [assert [[definition [snapshot [shield] dip swap [discard] [string ["assertion failed "] dip join fail] branch]] [spec [[program] [*]]]]] [rest [[spec [[list] [list]]] [examples [[[[1 2 3] rest] [[2 3]]]]]]] [false [[spec [[] [item]]] [definition [nothing]]]] [pump [[spec [[program [pipe in] [pipe out]] [[pipe in] [pipe out]]]] [definition [wrap [shield] join [[] sink [pack] dip swapdown [pack] dip [[closed?] any?] dip swap]]]]] [branch [[examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]] [spec [[[program false-branch] [program true-branch] [item condition]] [*]]]]] [rem [[spec [[number number] [number]]] [definition []]]] [/ [[spec [[number number] [number]]]]] [value [[definition [[count 1 =] [first second] [[value] lookup] if]] [examples [[[[[foo 1]] value] [1]] [[[[type url] [value "http://foo.com"]] value] ["http://foo.com"]]]] [spec [[association] [item]]]]] [dec [[spec [[number] [number]]]]] [any? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [unpack swap] swap pack [dip swap] join wrap [dip or] join [[] [[[nothing?] shield] dip swap [or] shielddown] []] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] any?] [true]] [[[3 5 7] [even?] any?] [false]] [[[] [even?] any?] [false]] [[[2 4 6] [] any?] [2]] [[11 [3 5 6] [+ odd?] any?] [true 11]] [[-15 [[even?] [positive?] [3 rem 0 =]] [execute] any?] [true -15]]]]]] [and [[examples [[[1 odd? 2 even? and] [true]]]] [spec [[item item] [item]]]]] [pipe-in [[spec [[item] [pipe]]] [definition [[[[type [file] unwrap =] [value file-in]] [[type [stdout] unwrap =] [stdout]]] decide]]]] [nothing [[definition [[]]] [spec [[] [item]]]]] [range [[examples [[[1 5 range] [[1 2 3 4]]]]] [spec [[integer integer] [list]]]]] [unpack [[spec [[list] [item list]]] [examples [[[["a" "b" "c"] unpack] [["b" "c"] "a"]]]]]] [count [[examples [[[["a" "b" "c"] count] [3]]]] [spec [[list] [number]]]]] [list? [[examples [[[[1] list?] [true]] [[[] list?] [true]] [[5 list?] [false]]]] [spec [[item] [boolean]]]]] [retry [[spec [[error] [*]]] [examples [[[2 3 "four" * + handle [discard 4] dip retry] [14]]]] [definition [[unwound] lookup execute]]]] [min [[spec [[number number] [number]]] [definition []]]] [spit [[definition [[pipe-in] dip bytes put close discard]] [spec [[item [item target]] []]]]] [ceil [[spec [[number] [integer]]]]] [atom [[definition []] [spec [[item] [pipe]]]]] [join [[examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]] [["ab" "cd" join] ["abcd"]] [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]] [spec [[item item] [item]]]]] [odd? [[spec [[number] [boolean]]]]] [file-out [[spec [[string] [pipe]]]]] [discard [[spec [[item] []]] [examples [[[1 2 3 discard] [1 2]] [[1 2 3 [a b c] discard] [1 2 3]]]]]] [tos [[examples [[[[[stack [1 2 3]] [expression [[+] step]]] tos] [1]]]] [definition [[stack] lookup first]] [spec [[environment] [item]]]]] [+ [[examples [[[1 2 +] [3]] [[1.1 2.2 +] [3.3]] [[1 2.2 +] [3.2]]]] [spec [[number number] [number]]]]] [second [[spec [[list] [item]]] [examples [[[[4 5 6] second] [5]]]]]] [recover [[examples [[[[+] [discard 1 [+] [discard 2 +] recover] recover] [3]] [5 [1 2 "oh fudge"] [[+] [discard discard] recover] map] [5 [6 7 5]] [[swap] [swap] recover] [swap]]] [definition [[[handle] join] dip [snapshot] dipdown sink inject [first error?] [first swap execute] [evert discard] if]] [spec [[program program] [*]]]]] [inc [[examples [[[1 inc] [2]] [[-1 inc] [0]] [[99 inc] [100]]]] [spec [[number] [number]]]]] [pack [[examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]] [["foo" bytes 32 pack string] ["foo "]]]] [spec [[item list] [list]]]]] [true [[spec [[] [word]]]]] [pipe? [[spec [[item] [boolean]]]]] [error? [[spec [[item] [boolean]]]]] [bytes [[spec [[item] [bytes]]]]] [a 1] [while [[examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]] [spec [[[program body] [program pred]] [*]]] [definition [swap wrap [shield] join clone dipdown join loop]]]] [>= [[spec [[number number] [boolean]]]]] [shielddown [[examples [[[1 2 3 [=] shielddown] [1 2 false]]]] [definition [shield swap discard]] [spec [[program item] [item]]]]] [derivations [[definition [[]]]]] [times [[definition [swap [dec] swap pack [dip] join [0 >] swap while discard]] [spec [[[integer howmany] [program body]] [*]]]]] [++lookup [[spec [[item association] [item]]]]] [mod [[spec [[number number] [number]]]]] [<= [[spec [[number number] [boolean]]]]] [toe [[examples [[[[[stack [1 2 3]] [expression [[+] step]]] toe] [[+]]]]] [definition [[expression] lookup first]] [spec [[environment] [item]]]]]]
#+end_src

Need a way of converting an item to an entry that just pushes that item.

#+begin_src kcats :results code
  1 wrap [[[spec [[[] [item]]]]] [definition]] dip assign 
#+end_src

#+RESULTS:
#+begin_src kcats
[[spec [[[] [item]]]] [definition [1]]]
#+end_src

#+begin_src kcats :results code
  dictionary
  [[spec [[] [item]]]
   [definition [23]]]
  [fooptoopy] swap assign
  [fooptoopy] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[spec [[] [item]]] [definition [23]]]
#+end_src

#+begin_src kcats
  [[a [1 1 1]]
   [b [6 7 *]]]
  [a b +] let
#+end_src

*** TODO Error should have actual struct fields
It's still implemented as generic Hashmap data field. 
*** INPROGRESS make a polymorphic 'join'
:LOGBOOK:
CLOCK: [2023-01-04 Wed 05:48]--[2023-01-04 Wed 07:26] =>  1:38
:END:
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).

 - list assoc -> list
 - assoc list -> list
 - list string -> list
 - assoc string -> error
 - assoc assoc -> assoc (merge top into 2nd)

   #+begin_src kcats :results code
     [[a b] [c d]] [[e f]] join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a b] [c d] [e f]]
   #+end_src

   #+begin_src kcats :results code
     [[a b] [c d]] association [[a f]] association join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a f] [c d]]
   #+end_src
*** DONE Cryptographic primitives
**** DONE SHA256
#+begin_src kcats
"foo" bytes hash "fop" bytes hash =
#+end_src

#+RESULTS:
: []

#+begin_src kcats
  ["foo" bytes key] 2 times =
#+end_src

#+RESULTS:
: true

#+begin_src kcats
"foo" bytes key
#+end_src

#+RESULTS:
: [[secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="] [public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="] [type ec-keypair]]

**** DONE Signing
#+begin_src kcats :results code
  "foo" bytes key "we attack at dawn" bytes [sign] shield verify
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats :results code
  "foo" bytes key "we attack at dawn" bytes [sign] shield
  ;; now change the message
  [discard "we attack at sunset" bytes] dip
  verify
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

*** INPROGRESS Multithreading
**** Overview
There are a few major components here:
+ Be able to tell whether an environment can advance. It's basically
  "if there's nothing in the expression, it's done, otherwise it can
  run unless it's currently putting/taking from a pipe"
**** Pipes
It's not clear to me what to do about pipes. As soon as we call =take=
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need =tokio=.

tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.

So then another question is, how to use something like =select= in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.

I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately =await=. That should yield to allow other envs to run.

It looks like the =async= will creep all the way up to =axiom::eval=. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to =eval=
is going to be =async=.

I think that means fns like =f_stack1= etc will need to be async because
the =f= it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.

We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to =join= with other environment's tasks.
**** DONE Add tokio as dep
**** DONE Prepare for multithreading
***** DONE Use Arc instead of Rc
Does Arc have =make_mut=?  Yes! So hopefully it will be a drop-in
replacement.
**** DONE Update pipe types for fs and net to use tokio calls
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.

If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.

Maybe one way to proceed is to make an =Item= variant =Future=. So if
we're taking from a pipe, we can just put the =Future= on the stack and
continue. Of course, very soon we'll need to access the value and call
=await= on it. 

What then, do we do about =put=? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.

Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just discard it. Somewhere we'd need a type =Option<Item>= for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)

So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.

If this works then only eval/eval-step will need =async=.
**** DONE Use channel type to implement handoff pipe
***** DONE Use crossbeam channels
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".

#+begin_src kcats :results code
  handoff clone
  wrap [5 put "hello" put] join
  [] swap [[expression]] dip assign environment animate take [take] dip
#+end_src

#+RESULTS:
#+begin_src kcats
5 "hello" [[type pipe] [handoff todo: id-or-hash here]]
#+end_src

#+RESULTS:
:

One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 

The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.

The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot... is that
common?)

The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.

For now I think I'm inclined to leave it as-is and see how it goes.
***** TODO Nonblocking eval-step (for inner envs)
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe =try_eval_step= which tries to
make progress immediately and if it can't, just returns as-is.

There's probably a way to do this by polling the future. using =select!=
with a short timeout future would do it but there's probably a better
way.
***** TODO Combine implementations for net and fs
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.

**** DONE Implement 'spawn' or equavalent
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
=animate= seems rather fitting.

#+begin_src kcats
 [[expression [+ 1 1]]] environment animate 
#+end_src

#+RESULTS:
: 
**** DONE Implement 'future' or equivalent
The idea here is to take an expression and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.

I think the new env should probably inherit the current env's stack.
#+begin_src kcats :results code
  1 2 [+] 
  ;; make a pipe
  handoff swap
  ;; save the stack, including pipe
  [snapshot] dip
  ;; prepare the program for the new env
  ;; end up with [[+ snapshot] dip swap put]
  [snapshot] join wrap [dip swap put discard] join
  ; ;; now we have expr stack
  pair
  [stack expression] swap zip environment
  animate take
#+end_src

#+RESULTS:
#+begin_src kcats
[3] [[type pipe] [handoff todo: id-or-hash here]] 2 1
#+end_src

#+begin_src kcats
  1 [2 +] future take swap discard
#+end_src

#+RESULTS:
: [3] 1
*** TODO Division by zero consumes stack items
=5 0 /= shouldn't consume the =5= and =0= - compare to =1 "2" += behavior
(which leaves items on stack).

