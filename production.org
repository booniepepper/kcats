#+TITLE: The kcats Programming Language (Production Implementation)
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Production implementation
** Base Language
We will use Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
** Status
Experimental, currently learning a new language.
** Using
*** Dependencies
- rustc
- cargo
*** Build
Run =cargo build=, the binary will be placed in =./target/debug= by
default.
*** Run
Execute the binary: =./target/debug/kcats=. It will read a program
from stdin and execute it, then print the resulting stack.

** Project File
#+begin_src toml :tangle Cargo.toml
[package]
name = "kcats"
version = "0.1.1"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#rug = "1.15.0"
edn-format = "3.2.3"
base64 = "0.13.0"
internment = "0.6.0" 
thiserror = "1.0.30"
lazy_static = "1.4.0"

[dev-dependencies]
test-case = "2.0.0"
#+end_src
** Code
Let's start by defining some data structures in a separate module
#+begin_src rust :tangle src/types.rs
use internment::Intern;
use lazy_static::lazy_static;
use std::collections::{HashMap, VecDeque};
use std::fmt;
use std::hash::{Hash, Hasher};
use std::ptr;
use std::rc::Rc;
extern crate thiserror;

pub type Word = Intern<String>;

pub type List = VecDeque<Item>;

pub type KeyList = VecDeque<KeyItem>;

pub type Stack = List;

pub type Bytes = Vec<u8>;

pub type Int = i64;

pub type Float = f64;

pub type Associative = HashMap<KeyItem, Item>;

lazy_static! {
    pub static ref S_ASSOC: Intern<String> = Intern::new("association-list".to_string());
    pub static ref S_BOOLEAN: Intern<String> = Intern::new("boolean".to_string());
    pub static ref S_BYTES: Intern<String> = Intern::new("bytes".to_string());
    pub static ref S_FLOAT: Intern<String> = Intern::new("float".to_string());
    pub static ref S_INTEGER: Intern<String> = Intern::new("integer".to_string());
    pub static ref S_ITEM: Intern<String> = Intern::new("item".to_string());
    pub static ref S_LIST: Intern<String> = Intern::new("list".to_string());
    pub static ref S_NUMBER: Intern<String> = Intern::new("number".to_string());
    pub static ref S_PROGRAM: Intern<String> = Intern::new("program".to_string());
    pub static ref S_STRING: Intern<String> = Intern::new("string".to_string());
    pub static ref S_WORD: Intern<String> = Intern::new("word".to_string());
}

#[derive(Debug, Clone, PartialEq)]
pub enum Item {
    Int(Int),
    Float(Float),
    Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    Assoc(Associative),
    List(List),
    Env(Environment),
    AxiomDef(AxiomDef),
    DerivedDef(DerivedDef),
    Nothing,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum KeyItem {
    Int(Int),
    Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    AxiomDef(AxiomDef),
    List(VecDeque<KeyItem>),
    Nothing,
}

#[derive(Debug, Clone, PartialEq)]
pub struct WordDocs {
    pub examples: Option<List>,
    pub spec: Option<List>,
}

pub type Dictionary = Associative;

#[derive(Clone, PartialEq)]
pub struct Environment {
    pub stack: Stack,
    pub expression: Stack,
    pub dictionary: Dictionary,
}

pub type StepResult = Result<Environment, Error>;

pub type ItemResult = Result<Item, Error>;

pub type StepFn = dyn Fn(Environment) -> StepResult;

pub type AxiomWords = HashMap<Word, StepFn>;

#[derive(Clone)]
pub struct AxiomDef {
    pub word: Word,
    pub docs: WordDocs,
    pub f: Rc<StepFn>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct DerivedDef {
    pub docs: WordDocs,
    pub definition: List,
}

// dictionary entries are equal if they have the same function reference,
// no need to compare the function values
impl PartialEq for AxiomDef {
    fn eq(&self, other: &Self) -> bool {
        self.word == other.word
            && self.docs == other.docs
            && ptr::eq(self.f.as_ref(), other.f.as_ref())
    }
}

impl Eq for AxiomDef {}

impl Hash for AxiomDef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.word.hash(state);
    }
}

pub trait Doc {
    fn docs(self) -> Option<WordDocs>;
}

impl Doc for Item {
    fn docs(self) -> Option<WordDocs> {
        match self {
            Item::AxiomDef(a) => Some(a.docs),
            Item::DerivedDef(a) => Some(a.docs),
            _ => None
        }
    }
}

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("expected at least {expected} stack items but found {actual}:\n{context:#?}")]
    StackUnderflow {
        expected: usize,
        actual: usize,
        context: Option<Box<dyn std::fmt::Debug>>,
    },

    #[error("expected {expected} items but found {actual}: {context:?}")]
    Count {
        expected: usize,
        actual: usize,
        context: Option<Box<dyn std::fmt::Debug>>,
    },

    #[error("type mismatch - expected {expected_types:?} and got {actual_values:?}: {context:?}")]
    TypeMismatch {
        expected_types: Vec<String>,
        actual_values: Vec<Box<dyn std::fmt::Debug>>,
        context: Option<Box<dyn std::fmt::Debug>>,
    },

    #[error("word has no implementation: {word}")]
    Unimplemented {
        word: String,
        source: Option<Box<dyn std::error::Error>>,
        context: Option<Environment>,
    },

    #[error("invalid syntax, {message}: {context:?}")]
    Parser {
        message: String,
        source: Option<Box<dyn std::error::Error>>,
        context: Option<Box<dyn std::fmt::Debug>>,
    },

    #[error("Unknown word: {word}: {context:?}")]
    UnknownWord {
        word: String,
        context: Option<Box<dyn std::fmt::Debug>>,
    },

    #[error("example failed - expected {program} to produce {expected} but got {actual}")]
    ExampleTest {
        expected: String,
        actual: String,
        program: String,
    },
    //#[error("error")]
}

impl TryFrom<Item> for List {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::List(l) = i {
            Ok(l)
        } else {
            Err(Error::TypeMismatch {
                expected_types: vec!["List".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            })
        }
    }
}

impl TryFrom<Item> for AxiomDef {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::AxiomDef(b) = i {
            Ok(b)
        } else {
            Err(Error::TypeMismatch {
                expected_types: vec!["AxiomWord".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            })
        }
    }
}

impl TryFrom<Item> for Int {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Int(i) = i {
            Ok(i)
        } else {
            Err(Error::TypeMismatch {
                expected_types: vec!["Int".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            })
        }
    }
}

impl TryFrom<Item> for String {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::String(i) = i {
            Ok(i)
        } else {
            Err(Error::TypeMismatch {
                expected_types: vec!["String".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            })
        }
    }
}

impl TryFrom<Item> for Associative {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        match i {
            Item::Assoc(a) => Ok(a),
            Item::List(l) => Ok(to_hash(l)?),
            Item::Nothing => Ok(Associative::new()),
            _ => Err(Error::TypeMismatch {
                expected_types: vec!["Associative".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            }),
        }
    }
}

impl TryFrom<Item> for Environment {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        if let Item::Env(i) = i {
            Ok(i)
        } else {
            Err(Error::TypeMismatch {
                expected_types: vec!["Environment".to_string()],
                actual_values: vec![Box::new(i)],
                context: None,
            })
        }
    }
}
// impl TryFrom<Associative> for Environment {
//     type Error = Error;
//     fn try_from(i: Item) -> Result<Self, Self::Error> {
//         let 
//     }
// }

// impl TryFrom<Item> for Environment {
//     type Error = Error;
//     fn try_from(i: Item) -> Result<Self, Self::Error> {
//         let h = 
//         match i {
//             Item::Assoc(a) => Ok(a),
//             Item::List(l) => Ok(to_hash(l)?),
//             Item::Nothing => Ok(Associative::new()),
//             _ => Err(Error::TypeMismatch {
//                 expected_types: vec!["Associative".to_string()],
//                 actual_values: vec![Box::new(i)],
//                 context: None,
//             }),
//         }
//     }
// }

pub fn get_item(i: Item, index: usize) -> Option<Item> {
    if let Item::List(l) = i {
        match l.get(index) {
            Some(x) => Some(x.clone()),
            None => None,
        }
    } else {
        None
    }
}

impl fmt::Debug for AxiomDef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ds = f.debug_struct("AxiomDef");
        ds.field("word", &self.word);
        ds.finish()
    }
}

pub fn word(s: &str) -> Item {
    Item::Word(Word::from(s))
}

pub fn to_key_item(i: Item) -> Result<KeyItem, Error> {
    match i {
        Item::Int(i) => Ok(KeyItem::Int(i)),
        Item::String(i) => Ok(KeyItem::String(i)),
        Item::List(l) => Ok(KeyItem::List(
            l.iter()
                .map(|i| to_key_item(i.clone()))
                .collect::<Result<KeyList, Error>>()?,
        )),
        Item::Word(w) => Ok(KeyItem::Word(w)),
        Item::AxiomDef(w) => Ok(KeyItem::AxiomDef(w)),
        Item::Boolean(b) => Ok(KeyItem::Boolean(b)),
        Item::Bytes(bs) => Ok(KeyItem::Bytes(bs)),
        Item::Nothing => Ok(KeyItem::Nothing),
        _ => Err(Error::TypeMismatch {
            expected_types: vec!["KeyItem".to_string()],
            actual_values: vec![Box::new(i)],
            context: None,
        }),
    }
}

pub fn to_value_item(i: KeyItem) -> Item {
    match i {
        KeyItem::Int(i) => Item::Int(i),
        KeyItem::String(i) => Item::String(i),
        KeyItem::List(l) => {
            Item::List(l.iter().map(|i| to_value_item(i.clone())).collect::<List>())
        }
        KeyItem::Word(w) => Item::Word(w),
        KeyItem::AxiomDef(b) => Item::AxiomDef(b),
        KeyItem::Boolean(b) => Item::Boolean(b),
        KeyItem::Bytes(bs) => Item::Bytes(bs),
        KeyItem::Nothing => Item::Nothing,
    }
}

pub fn to_entry(i: Item) -> Result<(KeyItem, Item), Error> {
    match i {
        Item::List(mut l) => {
            if l.len() != 2 {
                Err(Error::TypeMismatch {
                    expected_types: vec!["List[2]".to_string()],
                    actual_values: vec![Box::new(l)],
                    context: None,
                })
            } else {
                let v = l.pop_back();
                let k = l.pop_back();
                let e = l.pop_back();
                match (k, v, e) {
                    (Some(k), Some(v), None) => Ok((to_key_item(k)?, v)),
                    (k, v, _) => Err(Error::TypeMismatch {
                        expected_types: vec!["List[2]".to_string()],
                        actual_values: vec![Box::new(v), Box::new(k)],
                        context: None,
                    }),
                }
            }
        }
        _ => Err(Error::TypeMismatch {
            expected_types: vec!["List".to_string()],
            actual_values: vec![Box::new(i)],
            context: None,
        }),
    }
}

pub fn to_hash(l: List) -> Result<Associative, Error> {
    l.iter()
        .map(|i| to_entry(i.clone()))
        .collect::<Result<HashMap<KeyItem, Item>, Error>>()
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoUFeO0S`.

Next is the top level functions, including =main=, how to evaluate
kcats ASTs, later we'll put command line options here.

#+begin_src rust :tangle src/main.rs
mod types;
use crate::types::*;
mod axiom;
mod serialize;
use internment::Intern;
use std::io;
use std::io::BufRead;
use std::mem;

fn print_result(r: StepResult) {
    match r {
        Err(e) => {
            println!("\n{}", e)
        }
        Ok(env) => {
            println!("\n{}", serialize::emit(&Item::List(env.stack)));
        }
    }
}

fn standard_env(program: Option<List>) -> Environment {
    let prog_expr = match program {
        Some(p) => Stack::from(p),
        _ => Stack::new(),
    };

    let initialized = axiom::add_standard_dictionary(Environment {
        stack: Stack::new(),
        expression: prog_expr,
        dictionary: Dictionary::new(),
    })
    .unwrap();

    initialized
}

fn get_stdin() -> String {
    let mut buf = String::new();
    for line in io::stdin().lock().lines() {
        buf.push_str(&line.unwrap());
        buf.push('\n');
    }
    buf
}

fn main() {
    let program = get_stdin();
    let mut env = standard_env(None);
    let parse_result = serialize::parse(program, Some(&env.dictionary));
    match parse_result {
        Ok(program) => {
            env.expression.extend(program);
            print_result(axiom::eval(env));
        }
        Err(e) => {
            println!("Error parsing input: {:?}", e);
        }
    }
}

fn test_example(mut env: Environment, w: Word, program: List, expected: List) -> Option<Error> {
    let p = program.clone();
    env.expression.extend(program);
    //let res = eval(env).ok()?;
    match axiom::eval(env) {
        Err(e) => Some(e),
        Ok(res) => {
            if res.stack == expected {
                None
            } else {
                Some(Error::ExampleTest {
                    expected: serialize::emit(&Item::List(expected)),
                    actual: serialize::emit(&Item::List(res.stack)),
                    program: serialize::emit(&Item::List(p)),
                })
            }
        }
    }
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;
    use internment::Intern;
    use test_case::test_case;

    fn test_word(standard_env: Environment, w: Word) -> Vec<Error> {
        if let Some(d) = standard_env.dictionary.get(&KeyItem::Word(w)) {
            d.clone()
                .docs()
                .unwrap()
                .examples
                .iter()
                .filter_map(|ex| {
                    let x = ex.get(0).unwrap().clone();
                    match (get_item(x.clone(), 0).unwrap(), get_item(x, 1).unwrap()) {
                        (Item::List(p), Item::List(exp)) => {
                            test_example(standard_env.clone(), w.clone(), p.clone(), exp.clone())
                        }
                        (p, exp) => Some(axiom::invalid_type_error(
                            vec![&p, &exp],
                            vec!["List", "List"],
                        )),
                    }
                })
                .collect::<Vec<Error>>()
        } else {
            Vec::new()
        }
    }

    #[test_case("+" ; "plus")]
    #[test_case("-" ; "minus")]
    #[test_case("=" ; "eq")]
    #[test_case(">" ; "gt")]
    #[test_case("and")]
    #[test_case("assign")]
    #[test_case("associative?")]
    #[test_case("branch")]
    #[test_case("clone")]
    #[test_case("count")]
    #[test_case("decide")]
    #[test_case("dip")]
    #[test_case("dipdown")]
    #[test_case("discard")]
    #[test_case("evert")]
    #[test_case("execute")]
    #[test_case("first")]
    #[test_case("float")]
    #[test_case("if")]
    #[test_case("inc")]
    #[test_case("inject")]
    #[test_case("join")]
    #[test_case("list?" ; "is_list")]
    #[test_case("lookup")]
    #[test_case("loop")]
    #[test_case("not")]
    #[test_case("odd?" ; "is_odd")]
    #[test_case("even?" ; "is_even")]
    #[test_case("number?" ; "is_number")]
    #[test_case("or")]
    #[test_case("pack")]
    #[test_case("range")]
    #[test_case("recur")]
    #[test_case("shield")]
    #[test_case("shielddown")]
    #[test_case("shielddowndown")]
    #[test_case("sink")]
    #[test_case("snapshot")]
    #[test_case("step")]
    #[test_case("string?" ; "is_string")]
    #[test_case("swap")]
    #[test_case("swapdown")]
    #[test_case("unpack")]
    #[test_case("unwrap")]
    #[test_case("update")]
    #[test_case("wrap")]
    fn test_lexicon(word: &str) {
        let e = standard_env(None);
        let r = test_word(e.clone(), Intern::new(word.to_string()));
        assert!(r.is_empty(), "{:?}", r);
    }
}

// if let (Item::List(program), Item::List(expected)) = (program, expected) {

//     } else {
//         Err(Error::from("Example should be a pair"))
//     }

// for ex in d.examples().iter() {
//             let e = List::try_from(*ex).ok().unwrap();
//             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
//             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

//             test_example(standard_env.clone(), w, p,exp)
//         }.retain(|i| i.is_some()).collect::<Vec<Error>>()
#+end_src

#+RESULTS:
: error: Could not compile `cargo7G4HYj`.

Here are the axiom functions. Some of them are just functions of the
topmost stack items, and we'll call them with =f_stack1= etc. The rest
modify the expression or dictionary and are functions of the environment.
#+begin_src rust :tangle src/axiom.rs
use super::serialize;
use crate::types::*;
use internment::Intern;
use std::collections::{HashMap, VecDeque};
use std::fmt::Debug;
use std::fs;
use std::iter;
use std::mem;
use std::ops::Range;
use std::rc::Rc;

fn f_stack1(f: fn(Item) -> ItemResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        //check_stack_depth(&env, 1)?;
        let x = env.stack.pop_front().unwrap();
        env.stack.push_front(f(x)?);
        Ok(env)
    }
}

fn f_stack2(f: fn(Item, Item) -> ItemResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        //check_stack_depth(&env, 2)?;
        let x = env.stack.pop_front().unwrap();
        let y = env.stack.pop_front().unwrap();
        env.stack.push_front(f(y, x)?);
        Ok(env)
    }
}

fn f_stack3(f: fn(Item, Item, Item) -> ItemResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        //check_stack_depth(&env, 3)?;
        let x = env.stack.pop_front().unwrap();
        let y = env.stack.pop_front().unwrap();
        let z = env.stack.pop_front().unwrap();
        env.stack.push_front(f(z, y, x)?);
        Ok(env)
    }
}

fn update_axiom_entries<'a>(mut d: Dictionary, updates: Vec<(&str, Rc<StepFn>)>) -> Dictionary {
    for (w, f) in updates {
        d.entry(KeyItem::Word(Word::from(w)))
            .and_modify(|e| match e {
                Item::AxiomDef(a) => {
                    a.f = f;
                }
                _ => {}
            });
    }
    d
}

pub fn add_builtins(d: Dictionary) -> Dictionary {
    update_axiom_entries(
        d,
        vec![
            ("*", Rc::new(f_stack2(mult))),
            ("+", Rc::new(f_stack2(plus))),
            ("-", Rc::new(f_stack2(minus))),
            ("/", Rc::new(f_stack2(div))),
            ("<", Rc::new(f_stack2(lt))),
            ("<=", Rc::new(f_stack2(lte))),
            ("=", Rc::new(f_stack2(eq))),
            (">", Rc::new(f_stack2(gt))),
            (">=", Rc::new(f_stack2(gte))),
            ("assign", Rc::new(f_stack3(assign))),
            ("associative?", Rc::new(f_stack1(is_associative))),
            ("branch", Rc::new(branch)),
            ("clone", Rc::new(clone)),
            ("count", Rc::new(f_stack1(count))),
            ("dec", Rc::new(f_stack1(dec))),
            ("decide", Rc::new(decide)),
            ("dip", Rc::new(dip)),
            ("dipdown", Rc::new(dipdown)),
            ("discard", Rc::new(discard)),
            ("eval-step", Rc::new(eval_step)),
            ("evert", Rc::new(evert)),
            ("execute", Rc::new(execute)),
            ("first", Rc::new(f_stack1(first))),
            ("float", Rc::new(float)),
            ("inc", Rc::new(f_stack1(inc))),
            ("join", Rc::new(f_stack2(join))),
            ("list?", Rc::new(f_stack1(is_list))),
            ("++lookup", Rc::new(f_stack2(lookup))),
            ("loop", Rc::new(env_effect2(loop_))),
            ("mod", Rc::new(f_stack2(mod_))),
            ("not", Rc::new(f_stack1(not))),
            ("even?", Rc::new(f_stack1(is_even))),
            ("odd?", Rc::new(f_stack1(is_odd))),
            ("number?", Rc::new(f_stack1(is_number))),
            ("or", Rc::new(f_stack2(or))),
            ("and", Rc::new(f_stack2(and))),
            ("pack", Rc::new(f_stack2(pack))),
            ("range", Rc::new(range)),
            ("read", Rc::new(read)),
            ("recur", Rc::new(recur)),
            ("sink", Rc::new(sink)),
            ("step", Rc::new(step)),
            ("string?", Rc::new(f_stack1(is_string))),
            ("swap", Rc::new(swap)),
            ("swapdown", Rc::new(swapdown)),
            ("unpack", Rc::new(unpack)),
            ("unwrap", Rc::new(unwrap)),
            ("wrap", Rc::new(wrap)),
        ],
    )
}

pub fn read_lexicon_file(filename: &str, mut env: Environment) -> StepResult {
    match fs::read_to_string(filename) {
        Ok(s) => {
            let items = serialize::parse(s, Some(&env.dictionary))?;
            let vitems = to_hash(List::from(items))?;
            for (k, def) in vitems.iter() {
                let h = to_hash(as_list(Some(def)).unwrap()).ok().unwrap();
                let word = as_word(k).unwrap();
                let newdef = to_lexicon_entry(word, h);
                let newdef2 = newdef.clone();
                env.dictionary
                    .entry(KeyItem::Word(word))
                    .and_modify(|e| match (e, newdef) {
                        (Item::AxiomDef(a), Item::AxiomDef(new_a)) => {
                            a.docs = new_a.docs;
                        }
                        (Item::DerivedDef(d), Item::DerivedDef(new_d)) => {
                            d.docs = new_d.docs;
                            d.definition = new_d.definition;
                        }
                        _ => {}
                    })
                    .or_insert(newdef2);
            }
            Ok(env)
        }
        Err(e) => Err(Error::Unimplemented {
            word: "lexicon".to_string(),
            source: Some(Box::new(e)),
            context: Some(env),
        }),
    }
}

pub fn add_standard_dictionary(env: Environment) -> StepResult {
    // read builtins
    let mut env = read_lexicon_file("src/kcats/builtins.kcats", env)?;
    env.dictionary = add_builtins(env.dictionary);
    env = read_lexicon_file("src/kcats/lexicon.kcats", env)?;
    Ok(env)
}

pub fn invalid_type_error(items: Vec<&Item>, expected_types: Vec<&str>) -> Error {
    Error::TypeMismatch {
        expected_types: expected_types.iter().map(|x| x.to_string()).collect(),
        actual_values: items
            .into_iter()
            .map(|i| Box::new(i.clone()) as Box<dyn Debug>)
            .collect(),
        context: None,
    }
}

fn number_type_error(items: Vec<&Item>) -> Error {
    invalid_type_error(
        items.clone(),
        iter::repeat("Number").take(items.len()).collect(),
    )
}

pub fn plus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i + j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i + j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float + j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i + j as Float)),
        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn minus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i - j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i - j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float - j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i - j as Float)),
        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn mult(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i * j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i * j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float * j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i * j as Float)),
        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn div(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i / j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i / j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float / j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i / j as Float)),
        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn mod_(i: Item, j: Item) -> ItemResult {
    Ok(Item::Int(Int::try_from(i)? % Int::try_from(j)?))
}

pub fn inc(i: Item) -> ItemResult {
    Ok(Item::Int(Int::try_from(i)? + 1))
}

pub fn dec(i: Item) -> ItemResult {
    Ok(Item::Int(Int::try_from(i)? - 1))
}

pub fn gt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i > j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i > j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean(i as Float > j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i > j as Float)),

        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn lt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i < j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i < j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean((i as Float) < j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i < j as Float)),

        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn gte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i >= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i >= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean(i as Float >= j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i >= j as Float)),

        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn lte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i <= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i <= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean((i as Float).le(&j))),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i <= j as Float)),

        (i, j) => Err(number_type_error(vec![&i, &j])),
    }
}

pub fn join(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::List(mut i), Item::List(j)) => {
            i.extend(j);
            Ok(Item::List(i))
        }
        (Item::String(mut i), Item::String(j)) => {
            i.push_str(&j);
            Ok(Item::String(i))
        }
        (i, j) => Err(invalid_type_error(
            vec![&i, &j],
            vec!["List|String", "List|String"],
        )),
    }
}

pub fn pack(i: Item, j: Item) -> ItemResult {
    let mut l = List::try_from(i)?;
    l.push_back(j);
    Ok(Item::List(l))
}

pub fn clone(mut env: Environment) -> StepResult {
    let clone = env.stack.front().unwrap().clone();
    env.stack.push_front(clone);
    Ok(env)
}

fn swap2(mut env: Environment, offset: usize) -> StepResult {
    let len = env.stack.len();
    env.stack.swap(offset, offset + 1);
    Ok(env)
}

pub fn swap(env: Environment) -> StepResult {
    swap2(env, 0)
}

pub fn swapdown(env: Environment) -> StepResult {
    swap2(env, 1)
}

pub fn sink(mut env: Environment) -> StepResult {
    env.stack.swap(0, 2);
    env.stack.swap(0, 1);
    Ok(env)
}

pub fn float(mut env: Environment) -> StepResult {
    env.stack.swap(0, 2);
    env.stack.swap(1, 2);
    Ok(env)
}

pub fn discard(mut env: Environment) -> StepResult {
    env.stack.pop_front();
    Ok(env)
}

fn extend_front(l: &mut List, mut to_prepend: List) -> () {
    mem::swap(l, &mut to_prepend);
    l.extend(to_prepend);
}

fn append_expression(mut env: Environment, items: VecDeque<Item>) -> StepResult {
    extend_front(&mut env.expression, items);
    Ok(env)
}

type EffectResult = Result<(Option<List>, Option<List>), Error>;

pub fn env_effect1(f: fn(Item) -> EffectResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        let i = env.stack.pop_front().unwrap();
        let (expr_items, stack_items) = f(i)?;
        if expr_items.is_some() {
            extend_front(&mut env.expression, expr_items.unwrap());
        }
        if stack_items.is_some() {
            extend_front(&mut env.stack, stack_items.unwrap());
        }

        Ok(env)
    }
}

pub fn env_effect2(f: fn(Item, Item) -> EffectResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        let i = env.stack.pop_front().unwrap();
        let j = env.stack.pop_front().unwrap();
        let (expr_items, stack_items) = f(i, j)?;
        if expr_items.is_some() {
            extend_front(&mut env.expression, expr_items.unwrap());
        }
        if stack_items.is_some() {
            extend_front(&mut env.stack, stack_items.unwrap());
        }

        Ok(env)
    }
}

pub fn eq(i: Item, j: Item) -> ItemResult {
    Ok(Item::Boolean(i == j))
}

pub fn count(i: Item) -> ItemResult {
    Ok(Item::Int(List::try_from(i)?.len().try_into().unwrap()))
}

pub fn is_string(i: Item) -> ItemResult {
    Ok(Item::Boolean(if let Item::String(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_number(i: Item) -> ItemResult {
    Ok(Item::Boolean(if let Item::Int(_) | Item::Float(_) = i {
        true
    } else {
        false
    }))
}

pub fn is_list(i: Item) -> ItemResult {
    Ok(Item::Boolean(if let Item::List(_) | Item::Nothing = i {
        true
    } else {
        false
    }))
}

pub fn first(i: Item) -> ItemResult {
    let mut l = List::try_from(i).unwrap();
    let x = if let Some(i) = l.pop_front() {
        i
    } else {
        Item::Nothing
    };
    Ok(x)
}

pub fn loop_(p: Item, f: Item) -> EffectResult {
    if let Item::List(mut p) = p {
        Ok({
            if is_truthy(f) {
                let p2 = p.clone();
                p.push_back(Item::List(p2));
                p.push_back(word("loop"));
                (Some(p), None)
            } else {
                (None, None)
            }
        })
    } else {
        Err(invalid_type_error(vec![&p, &f], vec!["List", "Item"]))
    }
}

pub fn execute(mut env: Environment) -> StepResult {
    let program = List::try_from(env.stack.pop_front().unwrap())?;
    append_expression(env, program)
}

pub fn wrap(mut env: Environment) -> StepResult {
    let item = env.stack.pop_front().unwrap();
    let mut v = List::new();
    v.push_front(item);
    env.stack.push_front(Item::List(v));
    Ok(env)
}

pub fn unwrap(mut env: Environment) -> StepResult {
    let l = List::try_from(env.stack.pop_front().unwrap())?;
    for i in l {
        env.stack.push_front(i);
    }
    Ok(env)
}

pub fn dip(mut env: Environment) -> StepResult {
    let program = List::try_from(env.stack.pop_front().unwrap())?;
    let item = env.stack.pop_front().unwrap();
    env.expression
        .push_front(Item::Word(Intern::new("unwrap".to_string())));
    let mut v = List::new();
    v.push_front(item);

    env.expression.push_front(Item::List(v));
    append_expression(env, program)
}

pub fn dipdown(mut env: Environment) -> StepResult {
    let program = List::try_from(env.stack.pop_front().unwrap())?;
    let item2 = env.stack.pop_front().unwrap();
    let item3 = env.stack.pop_front().unwrap();
    env.expression
        .push_front(Item::Word(Intern::new("unwrap".to_string())));
    let mut v = List::new();
    v.push_front(item2);
    v.push_front(item3);
    env.expression.push_front(Item::List(v));
    append_expression(env, program)
}

pub fn unpack(mut env: Environment) -> StepResult {
    // TODO: handle Nothing case
    if let s1 = env.stack.front_mut().unwrap() {
        if let Item::List(l) = s1 {
            if let Some(i) = l.pop_front() {
                env.stack.push_front(i);
            }
            Ok(env)
        } else {
            Err(invalid_type_error(vec![&s1], vec!["List"]))
        }
    } else {
        Err(Error::StackUnderflow {
            actual: 1,
            expected: 1,
            context: None,
        })
    }
}

fn is_truthy(i: Item) -> bool {
    match i {
        Item::Boolean(b) => b,
        Item::Nothing => false,
        Item::List(l) => !l.is_empty(),
        _ => true,
    }
}

pub fn branch(mut env: Environment) -> StepResult {
    let false_branch = List::try_from(env.stack.pop_front().unwrap())?;
    let true_branch = List::try_from(env.stack.pop_front().unwrap())?;
    let b = env.stack.pop_front().unwrap();
    append_expression(
        env,
        if is_truthy(b) {
            true_branch
        } else {
            false_branch
        },
    )
}

pub fn step(mut env: Environment) -> StepResult {
    let p = List::try_from(env.stack.pop_front().unwrap())?;
    let mut l = List::try_from(env.stack.pop_front().unwrap())?;
    if let Some(litem) = l.pop_front() {
        if !l.is_empty() {
            env.expression.push_front(word("step"));
            env.expression.push_front(Item::List(p.clone()));
            env.expression.push_front(Item::List(l));
        }
        env.expression.push_front(word("execute"));
        env.stack.push_front(litem);
        env.stack.push_front(Item::List(p));
    }
    Ok(env)
}

pub fn range(mut env: Environment) -> StepResult {
    let to = Int::try_from(env.stack.pop_front().unwrap())?;
    let from = Int::try_from(env.stack.pop_front().unwrap())?;
    env.stack.push_front(Item::List(
        (from..to).map(|i| Item::Int(i)).collect::<VecDeque<Item>>(),
    ));
    return Ok(env);
}

// (effect [rec2 rec1 then pred]
//                   ['[if]
//[(concat rec1
//         [[pred then rec1 rec2 'recur]] rec2)
// then pred]])

pub fn recur(mut env: Environment) -> StepResult {
    let rec2 = List::try_from(env.stack.pop_front().unwrap())?;
    let rec1 = List::try_from(env.stack.pop_front().unwrap())?;
    let then = List::try_from(env.stack.pop_front().unwrap())?;
    let pred = List::try_from(env.stack.pop_front().unwrap())?;
    env.expression.push_front(word("if"));
    let r = Item::List(List::from([
        Item::List(pred.clone()),
        Item::List(then.clone()),
        Item::List(rec1.clone()),
        Item::List(rec2.clone()),
        word("recur"),
    ]));
    let mut e = List::new();
    e.extend(rec1);
    e.push_back(r);
    e.extend(rec2);

    env.stack.push_front(Item::List(pred));
    env.stack.push_front(Item::List(then));
    env.stack.push_front(Item::List(e));
    Ok(env)
}

//(fn [{[l & others] 'stack :as env}]
//            (assoc env 'stack (apply list (vec others) l)))

pub fn evert(mut env: Environment) -> StepResult {
    let mut l = List::try_from(env.stack.pop_front().unwrap())?;
    mem::swap(&mut env.stack, &mut l);
    env.stack.push_front(Item::List(l));
    Ok(env)
}

fn key_item(s: &str) -> KeyItem {
    to_key_item(word(s)).unwrap()
}

fn as_list(i: Option<&Item>) -> Option<List> {
    if let Some(i) = i {
        if let Item::List(l) = i {
            Some(l.clone())
        } else {
            None
        }
    } else {
        None
    }
}

fn as_word(i: &KeyItem) -> Option<Word> {
    match i {
        KeyItem::Word(w) => Some(w.clone()),
        KeyItem::AxiomDef(b) => Some(b.word.clone()),
        _ => None,
    }
}

fn to_lexicon_entry(w: Word, def: HashMap<KeyItem, Item>) -> Item {
    //println!("{:?}", def);
    let docs = WordDocs {
        examples: as_list(def.get(&key_item("examples"))),
        spec: as_list(def.get(&key_item("spec"))),
    };
    if let Some(d) = as_list(def.get(&key_item("definition"))) {
        Item::DerivedDef(DerivedDef {
            definition: d,
            docs: docs,
        })
    } else {
        Item::AxiomDef(AxiomDef {
            word: w,
            docs: docs,
            f: Rc::new(move |_: Environment| {
                Err(Error::Unimplemented {
                    word: w.to_string(),
                    context: None,
                    source: None,
                })
            }),
        })
    }
}

fn assoc_in(i: Item, ks: &[KeyItem], v: Item) -> Result<Associative, Error> {
    let mut h = Associative::try_from(i)?;
    if let [k, ks @ ..] = ks {
        if ks.is_empty() {
            h.insert(k.clone(), v);
        } else {
            let inner = h.get(&k.clone()).unwrap_or(&Item::Nothing).clone();
            h.insert(k.clone(), Item::Assoc(assoc_in(inner, ks, v)?));
        }
    }
    Ok(h)
}

pub fn assign(m: Item, ks: Item, v: Item) -> ItemResult {
    let ks = List::try_from(ks)?;
    let mut ksvec = ks
        .into_iter()
        .map(|k| to_key_item(k))
        .collect::<Result<KeyList, Error>>()?;
    ksvec.make_contiguous();
    let (ks, _) = ksvec.as_slices();
    Ok(Item::Assoc(assoc_in(m, ks, v)?))
}

//TODO: this should really take a keylist like assign and lookup
pub fn unassign(m: Item, k: Item) -> ItemResult {
    let mut m = Associative::try_from(m)?;
    m.remove(&to_key_item(k)?);
    Ok(Item::Assoc(m))
}

pub fn lookup(m: Item, k: Item) -> ItemResult {
    let k = to_key_item(k)?;
    match m {
        Item::Assoc(m) => Ok(m.get(&k).unwrap_or(&Item::Nothing).clone()),
        Item::List(l) => Ok(lookup(Item::Assoc(to_hash(l)?), to_value_item(k))?),
        _ => Err(invalid_type_error(vec![&m], vec!["List"])),
    }
}

pub fn or(i: Item, j: Item) -> ItemResult {
    Ok(Item::Boolean(is_truthy(i) || is_truthy(j)))
}

pub fn and(i: Item, j: Item) -> ItemResult {
    Ok(Item::Boolean(is_truthy(i) && is_truthy(j)))
}

pub fn not(i: Item) -> ItemResult {
    Ok(Item::Boolean(!is_truthy(i)))
}

pub fn is_associative(i: Item) -> ItemResult {
    Ok(Item::Boolean(match i {
        Item::Assoc(_) => true,
        Item::List(l) => to_hash(l).is_ok(),
        _ => false,
    }))
}

pub fn is_odd(i: Item) -> ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::Boolean(i & 1 == 1))
}

pub fn is_even(i: Item) -> ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::Boolean(i & 1 == 0))
}

pub fn decide(mut env: Environment) -> StepResult {
    let mut clauses = List::try_from(env.stack.pop_front().unwrap())?;
    let clause = clauses.pop_front();
    if let Some(clause) = clause {
        if let Item::List(mut clause) = clause {
            if clause.len() != 2 {
                Err(Error::Count {
                    expected: 2,
                    actual: clause.len(),
                    context: Some(Box::new(clause)),
                })
            } else {
                let test = clause.pop_front().unwrap();
                let expr = clause.pop_front().unwrap();

                match (test, expr) {
                    (Item::List(test), Item::List(expr)) => {
                        // construct if
                        let testp = List::from(vec![Item::List(test), word("shield")]);
                        let elsep = List::from(vec![Item::List(clauses), word("decide")]);
                        let newexpr = List::from(vec![
                            Item::List(testp),
                            Item::List(expr),
                            Item::List(elsep),
                            word("if"),
                        ]);
                        append_expression(env, newexpr)
                    }
                    (test, expr) => {
                        Err(invalid_type_error(vec![&test, &expr], vec!["List", "List"]))
                    }
                }
            }
        } else {
            Err(invalid_type_error(vec![&clause], vec!["List"]))
        }
    } else {
        // clauses empty, return nothing
        env.stack.push_front(Item::Nothing);
        Ok(env)
    }
}

pub fn read(mut env: Environment) -> StepResult {
    let s = String::try_from(env.stack.pop_front().unwrap())?;
    let parsed = serialize::parse(s, Some(&env.dictionary))?;
    env.stack.push_front(Item::List(parsed));
    Ok(env)
}

fn check_type(env: &Environment, i: &Item, w: Word) -> Result<(), Error> {
    match i {
        Item::Int(i) => {
            if w == *S_INTEGER || w == *S_NUMBER || w == *S_ITEM {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::List(i) => {
            if w == *S_LIST || w == *S_ITEM || w == *S_ASSOC || w == *S_PROGRAM {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::Boolean(i) => {
            if w == *S_BOOLEAN {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::Float(i) => {
            if w == *S_FLOAT || w == *S_NUMBER {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::Bytes(i) => {
            if w == *S_BYTES {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::String(i) => {
            if w == *S_STRING {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }
        Item::Word(i) => {
            if w == *S_WORD {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }

        }
        Item::AxiomDef(i) => {
            if w == *S_WORD {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }

        }

        Item::DerivedDef(i) => {
            if w == *S_WORD {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }
        }        
        Item::Assoc(i)  => {
            if w == *S_ASSOC || w == *S_LIST {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }

        }
        Item::Env(i) => {
            if w == *S_ASSOC || w == *S_LIST {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }

        }
        Item::Nothing  => {
            if w == *S_LIST {
                Ok(())
            } else {
                Err(Error::TypeMismatch {
                    expected_types: vec![w.to_string()],
                    actual_values: vec![Box::new(i.clone())],
                    context: Some(Box::new(env.clone())),
                })
            }

        }
        _ => Ok(()),
    }
}

fn check_stack_depth(env: &Environment, min_depth: usize) -> Result<(), Error> {
    //println!("Checking stack has at least {} items", min_depth);
    if env.stack.len() < min_depth {
        Err(Error::StackUnderflow {
            actual: env.stack.len(),
            expected: min_depth,
            context: Some(Box::new(env.clone())),
        })
    } else {
        Ok(())
    }
}

fn check_input_spec(spec: &List, env: &Environment) -> Result<(), Error> {
    let input_spec = spec.front().unwrap();
    if let Item::List(specs) = input_spec {
        check_stack_depth(env, specs.len())?;
        let indexes = Range {
            start: 0,
            end: specs.len(),
        };

        indexes
            .into_iter()
            .map(|i| {
                let item = env.stack.get(i).unwrap();
                let spec = specs.get(i).unwrap();
                match spec {
                    Item::List(named) => {
                        if let Item::Word(w) = named.get(0).unwrap() {
                            check_type(env, item, *w)
                        } else {
                            Err(Error::TypeMismatch {
                                expected_types: vec!["List".to_string()],
                                actual_values: vec![Box::new(named.clone())],
                                context: Some(Box::new(env.clone())),
                            })
                        }
                    }
                    Item::Word(w) => check_type(env, item, *w),
                    _ => Err(Error::TypeMismatch {
                        expected_types: vec!["List".to_string()],
                        actual_values: vec![Box::new(spec.clone())],
                        context: Some(Box::new(spec.clone())),
                    }),
                }
            })
            .collect::<Result<(), Error>>()
    } else {
        Err(Error::TypeMismatch {
            expected_types: vec!["List".to_string()],
            actual_values: vec![Box::new(spec.clone())],
            context: Some(Box::new(env.clone())),
        })
    }
}

pub fn eval_step(mut env: Environment) -> StepResult {
    //println!("{:?}", env);
    let next_item = env.expression.front();

    if let Some(val) = next_item {
        match val {
            Item::Word(word) => {
                if let Some(dfn) = env.dictionary.get(&KeyItem::Word(*word)) {
                    match dfn {
                        Item::AxiomDef(d) => {
                            if let Some(spec) = &d.docs.spec {
                                check_input_spec(&spec, &env)?
                            } else {
                                println!("No spec for {}!", word);
                            }
                            env.expression.pop_front();
                            let f = d.f.clone();

                            (f)(env)
                        }
                        Item::DerivedDef(d) => {
                            if let Some(spec) = &d.docs.spec {
                                check_input_spec(&spec, &env)?
                            } else {
                                println!("No spec for {}!", word);
                            }
                            env.expression.pop_front();
                            let mut items = d.definition.clone();
                            mem::swap(&mut items, &mut env.expression);
                            env.expression.extend(items);

                            Ok(env)
                        }
                        _ => Err(Error::UnknownWord {
                            word: word.to_string(),
                            context: Some(Box::new(env)),
                        }),
                    }
                } else {
                    Err(Error::UnknownWord {
                        word: word.to_string(),
                        context: Some(Box::new(env)),
                    })
                }
            }
            _ => {
                // handle the case where it's a builtin and we want to use
                // the owned value, so we pop it
                if let Item::AxiomDef(builtin) = val {
                    if let Some(spec) = &builtin.docs.spec {
                        check_input_spec(&spec, &env)?
                    }
                    let b = AxiomDef::try_from(env.expression.pop_front().unwrap())?;
                    Ok((b.f)(env)?)
                } else {
                    // not a word, just push onto stack
                    env.stack.push_front(env.expression.pop_front().unwrap());
                    Ok(env)
                }
            }
        }
    } else {
        Err(Error::Count {
            expected: 1,
            actual: 0,
            context: Some(Box::new("Expression is empty".to_string())),
        })
    }
}

pub fn eval(env: Environment) -> StepResult {
    let mut result: StepResult = Result::Ok(env);
    loop {
        if let Ok(env) = result {
            if !env.expression.is_empty() {
                result = eval_step(env);
            } else {
                break Ok(env);
            }
        } else {
            break result;
        }
    }
}

pub fn eval_step_outer(mut env: Environment) -> StepResult {
    let mut inner_env = Environment::try_from(env.stack.pop_front().unwrap())?;
    Ok(env)
        
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoUpWAU9`.

Now we'll add the functions for parsing and emitting kcats source. 

#+begin_src rust :tangle src/serialize.rs
extern crate edn_format;
use crate::types::*;
use base64;
use internment::Intern;
use std::collections::VecDeque;
use std::fmt;

fn lookup_builtin(w: Word, standard_dictionary: Option<&Dictionary>) -> Item {
    if let Some(dict) = standard_dictionary {
        //println!("Looking up {} in dict of {} words", w, dict.len());
        if let Some(def) = dict.get(&KeyItem::Word(w)) {
            if let Item::AxiomDef(a) = def {
                return Item::AxiomDef(a.clone());
            };
        }
    }
    return Item::Word(w);
}
const BYTE_TAG: &str = "b64";

fn to_item(
    item: &edn_format::Value,
    standard_dictionary: Option<&Dictionary>,
) -> Result<Item, Error> {
    //println!("to item {:?}", item);
    match item {
        edn_format::Value::Integer(i) => Ok(Item::Int(*i)),
        edn_format::Value::Vector(v) => Ok(Item::List(
            v.iter()
                .map(|i| to_item(i, standard_dictionary))
                .collect::<Result<VecDeque<Item>, Error>>()?,
        )),
        edn_format::Value::Symbol(s) => Ok(lookup_builtin(
            Intern::new(s.name().to_string()),
            standard_dictionary,
        )),
        edn_format::Value::Boolean(b) => Ok(Item::Boolean(*b)),
        edn_format::Value::String(s) => Ok(Item::String(s.to_string())),
        edn_format::Value::Float(f) => Ok(Item::Float(f.into_inner())),
        edn_format::Value::TaggedElement(tag, e) => {
            if *tag == edn_format::Symbol::from_name(BYTE_TAG) {
                if let edn_format::Value::String(s) = &**e {
                    Ok(Item::Bytes(base64::decode(s).unwrap()))
                } else {
                    Err(Error::Parser {
                        message: "Invalid tag datatype for byte literal".to_string(),
                        context: Some(Box::new((*tag).clone())),
                        source: None,
                    })
                }
            } else {
                Err(Error::Parser {
                    message: "Unsupported tag".to_string(),
                    context: Some(Box::new((*item).clone())),
                    source: None,
                })
            }
        }
        _ => Err(Error::Parser {
            message: "Unsupported data literal".to_string(),
            context: Some(Box::new((*item).clone())),
            source: None,
        }),
    }
}

fn from_item(item: &Item) -> edn_format::Value {
    match item {
        Item::Int(i) => edn_format::Value::Integer(*i),
        Item::List(v) => edn_format::Value::Vector(
            v.iter()
                .map(|i| from_item(i))
                .collect::<Vec<edn_format::Value>>(),
        ),
        Item::Word(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
        Item::AxiomDef(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(&w.word)),
        Item::Boolean(b) => edn_format::Value::Boolean(*b),
        Item::String(s) => edn_format::Value::String(s.to_string()),
        Item::Float(f) => edn_format::Value::from(*f),
        Item::Bytes(bs) => edn_format::Value::TaggedElement(
            edn_format::Symbol::from_name("b64"),
            Box::new(edn_format::Value::String(base64::encode(bs))),
        ),
        Item::Assoc(h) => edn_format::Value::Vector(
            h.iter()
                .map(|(k, v)| {
                    edn_format::Value::Vector(vec![
                        from_item(&to_value_item(k.clone())),
                        from_item(v),
                    ])
                })
                .collect(),
        ),
        _ => edn_format::Value::Integer(999),
    }
}

pub fn parse(s: String, standard_dictionary: Option<&Dictionary>) -> Result<List, Error> {
    let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
    parser
        .map(move |r| match r {
            Ok(expr) => Ok(to_item(&expr, standard_dictionary)?),
            Err(e) => Err(Error::Parser {
                message: "Invalid edn".to_string(),
                source: Some(Box::new(e)),
                context: None,
            }),
        })
        .collect()
}

pub fn emit(item: &Item) -> String {
    edn_format::emit_str(&from_item(item))
}

pub fn emit_all(items: &VecDeque<Item>) -> String {
    let mut s: String = String::new();
    for i in items {
        s.push_str(&emit(&i));
    }
    return s;
}

// print out envs in error messages
impl fmt::Debug for Environment {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ stack: {}, expression: {} }}",
            emit(&Item::List(self.stack.clone())),
            emit(&Item::List(self.expression.clone())),
        )
    }
}
#+end_src

#+RESULTS:
: error: Could not compile `cargo2te10b`.

** Issues
*** DONE Serialization treats any tagged literal as byte string
*** DONE Serialization panics on reading invalid data
Should return Result objects from to_item. I don't think it is
necessary for from_item - since we're using a subset of edn, all Items
should be convertible to valid edn. But not all valid edn is
convertible to an Item.
*** TODO Association list and list of equal content don't compare equal
Probably need a custom PartialEq impl for Item here that converts the
list to a hash before comparing. Return false if the item doesn't
convert. 
*** TODO Interactive mode
run with =kcats -i= for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
*** TODO Install the lexicon in the proper place
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.
*** TODO Package the binary for various platforms
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
* Notes
** Bootstrapping
+ Builtin words need to exist *before* the derived words are read from
  the lexicon - so that the words in the derivation can be replaced
  with objects that are directly callable.
+ The parser for the lexicon needs to have the prebuilt builtin
  dictionary.

  So bootstrap in 2 stages:
  + read builtins.kcats that contains just specs/docs. Build a
    Dictionary. Populate the function fields with explicit code.
  + parse lexicon.cats, using the dictionary just built, replacing
    builtin words with builtin objects (I see no need to have Builtin
    as a separate struct, just use AxiomWord)

    What about string internment? the strings in builtins file should
    get interned at parse time.
    
* Code Playground
A bunch of code snippets to test things out, org-babel makes this a
piece of cake.

#+RESULTS:
: error: Could not compile `cargoVyY4IO`.

#+begin_src rust
// test swap
use std::collections::VecDeque;
type List = Vec<Item>;

type Stack = VecDeque<i32>;
#[derive(Debug)]
enum Item {
    Int(i32),
    List(List),
}

fn main(){
    use std::mem;
    let mut x = List::new();
    x.push(Item::Int(5));
    let mut y = List::new();
    y.push(Item::Int(6));
    //x.push(Item::List(y));
    mem::swap(&mut x, &mut y);
    y.push(Item::List(x));
    println!("{:?}",y);

    let mut v = Stack::new();
    v.push_front(5);
    v.push_front(6);
    println!("{:?}", v);
}

#+end_src

#+RESULTS:
: [Int(5), List([Int(6)])]
: [6, 5]

Test hash of fn
#+begin_src rust :crates
use std::collections::HashMap;
//use std::boxed::Box;
use std::rc::Rc;

struct Env {
    number: Option<i32>,
    dict: HashMap<String, Rc<dyn Fn(Env) -> Env>>
}

fn inc(i: i32) -> i32 {
    i + 1
}

struct Builtins {
    inc: fn(i32) -> i32
}

fn make_thing(f: fn(i32) -> i32) -> impl Fn(Env) -> Env {
    move | mut e: Env | {
        if let Some(n) = e.number {
            e.number = Some(f(n));
            e
        } else { e }
        
    }
}

fn main () {
    let mut dict = HashMap::<String, Rc<dyn Fn(Env) -> Env>>::new();
    let i = make_thing(inc);
    let builtins = Builtins { inc: inc };
    dict.insert("inc".to_string(), Rc::new(i));
    let mut env = Env { number: Some(12), dict: dict };
    let f = env.dict.get(&"inc".to_string()).unwrap().clone();
    println!("{}", f(env).number.unwrap());
}
#+end_src

#+RESULTS:
: 13

#+begin_src rust
use std::boxed::Box;
struct Environment {
    stack: Vec<Box<dyn Item>>
}

struct Inc {}

trait Item {
    fn onto_stack(self, env: Environment);
}

impl Item for i32 {
    fn onto_stack(self, mut env: Environment){
        env.stack.push(Box::new(self));
    }
}

impl Item for Inc {
    fn onto_stack(self, mut env: Environment) {
        
    }
    
}
  
#+end_src

destructuring
#+begin_src rust
let a = [];
let [x, y @ ..] = a;

println!("{:?}", y);
#+end_src

#+begin_src rust
use std::collections::VecDeque;

let x = VecDeque::from(vec![1, 2, 3]);
let y = &x[0..1];

println!("{}", y);

#+end_src

#+RESULTS:
: error: Could not compile `cargoewKZ71`.

experiment with single vecdeque

#+begin_src rust
use std::collections::VecDeque;

pub struct Plus {}
pub struct Inc {}

#[derive(Debug)]
pub enum Item {
    Number(i32),
    Plus,
    Inc
}
#[derive(Debug)]
pub struct Stack {
    stack: VecDeque<Item>,
    tos: usize
}

// move from expr to stack
fn push(v: &mut Stack) {
    v.stack.rotate_left(1);
    v.tos -= 1  
}
    
fn exec2(v: &mut Stack) {

    let i = v.stack.pop_back().unwrap();
    let j = v.stack.pop_back().unwrap();
    v.stack.pop_front();
    println!("exec {:?} {:?}", i, j);
    if let (Item::Number(i), Item::Number(j)) = (i, j) {
        let res = i + j;
        v.stack.push_front(Item::Number(res));
        v.tos -= 1;
    }
}
    

fn main(){
    let mut env = Stack { stack: VecDeque::new(),
                          tos: 0 };
    // load the program
    env.stack.extend(vec![Item::Number(1), Item::Number(2), Item::Number(3), Item::Plus]);
    env.tos = 4;
    //buf.push_front(Item::Plus);

    //
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    push(&mut env);
    println!("{:?}", env);
    exec2(&mut env);
    println!("{:?}", env);
    println!("{:?}", env.stack.front());
    

}


#+end_src

#+RESULTS:
: Stack { stack: [Number(1), Number(2), Number(3), Plus], tos: 4 }
: Stack { stack: [Number(2), Number(3), Plus, Number(1)], tos: 3 }
: Stack { stack: [Number(3), Plus, Number(1), Number(2)], tos: 2 }
: Stack { stack: [Plus, Number(1), Number(2), Number(3)], tos: 1 }
: exec Number(3) Number(2)
: Stack { stack: [Number(5), Number(1)], tos: 0 }
: Some(Number(5))

experiment with stackexpr trait
#+begin_src rust
use std::collections::VecDeque;
pub enum Item {
    Int(i32),
    Plus,
    Inc
}

pub struct Environment {
    stack: VecDeque<Item>,
}

trait StackExpr {
    fn tos(self) -> Option<&'static Item>;
    fn toe(self) -> Option<&'static Item>;
    fn pop_stack(self) -> Option<Item>;
    fn pop_expression(self) -> Option<Item>;
    fn prepend_expression(self, l: List);
    fn append_expression(self, l: List);
    fn onto_stack(self);
}

impl StackExpr for VecDeque<T> {
    fn tos(self) -> Option<&'static Item> {
        self.as_slices().
    }
    fn toe(self) -> Option<&'static Item> {
        self.stack.front()
    }
    fn pop_stack(self) -> Option<Item> {
        self.stack.pop_back()
    }
    fn pop_expression(self) -> Option<Item> {
        let item = self.stack.pop_front();
        
    }
    fn prepend_expression(self, l: List);
    fn append_expression(self, l: List);
    fn onto_stack(self);

}
#+end_src

#+RESULTS:

#+begin_src rust
use std::collections::VecDeque;

let mut vector = VecDeque::new();

vector.push_back(0);
vector.push_back(1);
vector.push_back(2);

assert_eq!(vector.as_slices(), (&[0, 1, 2][..], &[][..]));

vector.push_front(10);
vector.push_front(9);

assert_eq!(vector.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));

let mut v = VecDeque::new();
v.push_back(1);
assert_eq!(v.as_slices(), (&[1][..], &[][..]));

#+end_src

#+RESULTS:

vec to hashmap
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;

impl<K, V> TryFrom<dyn Iterator<Item = dyn Eq>> for HashMap<K, V>
where K: Eq + Hash,
    
{
    type Error = ();

    fn try_from(v: dyn Iterator<Item = dyn Eq>) -> Result<Self, Self::Error> {
        
        HashMap::from_iter(v.map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {Err()}
        }))
    }
}

fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    let vec = vec![a, b];
    let h: HashMap<i32, i32> = HashMap::from_iter(
        vec.iter().map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {(0,0)}
        })
    );
    println!("{:?}", h);
}


#+end_src

#+RESULTS:
: error: Could not compile `cargo8MBNov`.

from reddit:
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;
#[derive(Debug)]
struct NotPairsError;

fn to_hashmap<T>(v: Vec<Vec<T>>) -> Result<HashMap<T, T>,NotPairsError>
    where T: Eq + Hash,
{
    v.iter().map(|v| match (v.get(0), v.get(1), v.get(2)) {
        (Some(k), Some(v), None) => Ok((k, v)),
        _ => Err(NotPairsError),
    }).collect()
}


fn main() {
    
    let a = vec![vec!["a", "b"], vec!["c", "d"], vec![]];

    
    println!("{:?}", to_hashmap(a));
}

#+end_src

#+RESULTS:
: error: Could not compile `cargorhVTIG`.

from reddit:

#+begin_src rust :crates '((itertools . "0.10.0"))
use itertools::Itertools;

use std::collections::HashMap;

fn into_hm<I, T, V>(iter: I) -> Result<HashMap<V, V>, String>
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    
}

trait IntoHashMap<T> {
    fn into_hashmap(self) -> Result<HashMap<T, T>, String>;
}

impl<I, T, V> IntoHashMap<V> for I
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    fn into_hashmap(self) -> Result<HashMap<V, V>, String> {
        into_hm(self.into_iter())
    }
}

fn main() {
    let v = vec![vec!["k1", "v1"], vec!["k2", "v2"]];
    println!("{:#?}", v.into_hashmap());
}
#+end_src



#+RESULTS:
: error: Could not compile `cargoTmcGbz`.

edn comment bug - doesn't parse correctly when 2nd line comment in multiline
comment is at beginning of line
#+begin_src rust :crates '((edn-format . "3.2.2"))
extern crate edn_format;

fn main() {
    println!("{:?}", edn_format::parse_str(";; abc\n;; def \n\n ced"));
}
#+end_src

#+RESULTS:
: Err(ParserErrorWithContext { context: [], row: 1, col: 2, error: UnexpectedCharacter(';') })

#+begin_src rust
use std::hash::Hash;
fn into_entry<T, K, V>(k: T, v: V) -> Result<(K, V), String>
where K: Eq + Hash
{
    match k {
        
    }
}
#+end_src

#+RESULTS:

#+begin_src rust
#[derive(Debug)]
enum Value {
    Int(i32),
    Float(f32),
    String(String)
}

#[derive(Debug)]
enum Key {
    Int(i32),
    String(String)
}

fn entry(mut l: Vec<Value>) -> Result<(Key, Value), String> {
    let v = l.pop();
    let k = l.pop();
    let e = l.pop();
    match (k, v, e) {
        (Some(k), Some(v), None) => {
            match (k) {
                Value::Int(k) => { Ok((Key::Int(k), v)) }
                _ => {Err("Key is wrong type".to_string())}
            }
            
        },
        _ => { Err("Entry must be a duple".to_string()) }
    }
}
fn main(){

    let v = vec![Value::Float(1.2), Value::Float(3.12)];
    println!("{:?}", entry(v));
    
}
#+end_src

#+RESULTS:
: Err("Key is wrong type")

testing type checking dynamic?
#+begin_src rust
use std::ops::Range;
let r = Range { start: 0, end: 5 };
let x: Vec<i32> = r.into_iter().map(|i| i+1).collect();

println!("{:?}", x)
    
#+end_src

#+RESULTS:
: [1, 2, 3, 4, 5]

error recovery

#+begin_src kcats
2 [1 4 0] [[/] [discard 0] recover] map

[1 0 /] [discard 0] recover
1 [0 /] [discard 0] . recover
1 . snapshot
    [0 /] inject first
    [error?] [discard 0] [] if
    resume  
err [error?]  

; inject the program into a snapshot. If there's an error on top
; afterward, inject the recovery in there too. It'll have access to
; the whole context. If there's no error, evert and drop the ToS.

;; wait why is there even a snapshot? to let the recovery access the
;; stack without having to guess what's on it.

[1 0 /] . execute
. 1 0 /
err . [discard 0] execute resume
                        ;; ^ this is in the expression so keep going, actual word doesn't do anything


;; when the ToS is err, how do we know whether to stop?  we can look
;; at the expression to see what's coming. We can't do that at every
;; step of the entire execution but we don't have to. Just when ToS =
;; err. The challenge is to encode this just with the stack/expr and
;; no extra state. We can put a word like "continue" in the expr, but
;; at some point we actually have to have an err on ToS and do
;; something with it. The only place we can put some kind of flag not
;; to abort, is in the expression (or maybe the dictionary).

;; another approach is to explicitly continue unless halt is called,
;; but the error-producer doesn't know whether the error can be
;; handled or not.


;; how to unwind. can we just naively unwind to the next instance of
;; 'recover' in the expression? or will quoted programs mess this up?
;; Let's work through it

;; here the recover is quoted, but by the time an error occurs and we
;; look at the expression, it'll be there:
2 [1 4 0] [[/ 12 +] [discard 0] recover] map

2 err . 12 + resume [error?] [discard 0] if
2 err . [error?] [discard 0] [] if 

;; so the problem is even after we've unwound the expression to
;; 'resume', the error is still on the ToS! Now we want to actually do
;; the recovery, but we've already gotten rid of the flag that tells
;; us we're doing that. Maybe we can modify the error object itself to
;; note that it's been flagged for processing. Maybe [[type error]
;; [detected? true] [message "oops"]]. Or maybe we can convert it from
;; the error object to a richer object that contains the whole
;; stack/expr at the time it happened.

;; maybe we need a primitive here: fail, which will put a new item on
;; ToS which includes the whole env field plus a message field to
;; describe what is wrong.

;; eg

1 0 /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]]

1 0 . "division by zero" capture /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]] . /

;; ok what's the best we got so far?

;; i think it's recover/resume, without requiring nested env. Have the
;; error type with a flag detected?. Eval will do the following: if
;; there's an error on top, and there is no 'detected?' field, unwind
;; the expression to 'resume' (if there is one, otherwise clean the
;; expression). Set the detected field and continue. presumably what's
;; next is the error handler if there's anything left in the
;; expression.

;; ok this is good but it'd be nice to know what the expression was
;; before it gets unwound. For example what if the handler wants to
;; log the error? By the time it can do that, the original word that
;; errored is not in the expression anymore. The error object would
;; have to contain a snapshot (not just of the stack, but the
;; expression too). what about snapshotting the stack and cherry
;; picking the error object before the recovery? How does the recovery
;; distinguish different types of errors (java's catch-by-class is
;; kind of weak)

;;eg

1 "foo" + 0 /

;; there's 2 things wrong here, what if we only want to recover from
;; division by zero? well, we can only wrap / in a recover. ok waht about this

"foo" 0 /

;; this will actually error with type mismatch
#+end_src
