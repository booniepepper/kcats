[[shield [[spec [[p program]]]
          [[doc "Runs program keeping top of stack produced but protects existing items from being consumed."]]
          [definition [[snapshot] dip inject first]]
          [examples [[[1 2 3 [=] shield] [false 3 2 1]]]]]]

 [shielddown [[spec [[p program]]]
              [definition [shield swap discard]]]]

 [shielddowndown [[spec [[p program]]]
                  [definition [shield [discard discard] dip]]]]

 [if [[spec [[false-branch program]
             [true-branch program]
             [condition program]]]
      [definition [[shield] dipdown branch]]
      [examples [[[5 [5 =] [3 *] [4 +] if] [15]]
                 [[6 [5 =] [3 *] [4 +] if] [10]]]]]]

 [dipdown [[spec [[p program]
                  [a item]
                  [b item]]]
           [definition [wrap [dip] join dip]]
           [examples [[[1 2 3 [inc] dipdown] [3 2 2]]]]]]

 [primrec [[spec [[rec1 program]
                  [exit program]
                  [data number]]]
           [definition [[execute] swap join ;; add execute to rec1 to be recurs rec2
                        [[discard] swap join] dip ;; add discard to exit condition
                        [[clone zero?]] dipdown  ;; put the condition on bottom
                        [[clone dec]] dip ;; add the r1
                        recur]] ;; now its generic recur
           [examples [[[5 [1] [*] primrec] [120]]]]]]

 [= [[spec [[x item], [y item]]]
     [definition [++=]]
     [examples [[[1 1 =] [true]]
                [["hi" "hi" =] [true]]
                [["hi" "there" =] [false]]
                [[[] false =] [false]]
                [[1 "hi" "hi" =] [true 1]]]]]]

 [count [[spec [[l list]]]
         [definition [+count]]
         [examples [[[["a" "b" "c"] count] [3]]]]]]

 [prepend [[spec [[a item]
                  [l list]]]
           [definition [wrap swap join]]
           [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]]

 [assert [[spec [[p program]]]
          [definition [snapshot ;; save stack to print in err message
                       [shield] dip swap ;; run the assertion under the saved stack
                       [discard] ;; if passes, drop the saved stack, dont need
                       [string ["assertion failed "] dip join fail] ;; else throw err
                       branch]]]]

 [inject [[spec [[p program]
                 [l list]]]
          [doc "Inject the quoted program into the list below
                   it (runs the program with the list as its
                   stack).  Does not affect the rest of the stack."]
          [definition [swap evert unpack dip evert]]
          [examples [[[1 2 3 [4 5 6] [* +] inject] [[26] 3 2 1]]]]]]

 [snapshot [[spec []]
            [doc "Save the whole stack as a list on the stack"]
            [definition [[] evert clone evert unwrap]]
            [examples [[[1 2 3 snapshot] [[3 2 1] 3 2 1]]
                       [[snapshot] [[]]]]]]]

 [first [[spec [[l list]]]
         [definition [+first +nil->nothing]]
         [examples [[[[4 5 6] first] [4]]]]]]

 [second [[spec [[l list]]]
          [definition [+second]]
          [examples [[[[4 5 6] second] [5]]]]]]

 [bytes? [[spec [[a item]]]
          [definition [+bytes?]]]]

 [string? [[spec [[a item]]]
           [definition [+string?]]]]

 [bytes [[spec [[a item]]]
         [definition [[[[clone string?] [!*getBytes]]
                       [[clone bytes?] []]]
                      decide]]]]

 [map [[spec [[p program]
              [l list]]]
       [definition [[snapshot [] swap] ;; save original stack, and
                    ;; add an empty list to
                    ;; hold results
                    dipdown ;; do this underneath the program and list
                    [wrap swap clone float] ;; program snippet a to
                    ;; copy the original stack
                    ;; that we saved, will make
                    ;; new copy for each item
                    ;; in the list

                    swap pack ;; pack the map program into the
                    ;; partial program a above

                    ;; inject the map program into the stack copy,
                    ;; take the first item and pack it into the
                    ;; result list. the join here is to literally
                    ;; add the list item to the stack copy,
                    ;; without actually executing it, in case its
                    ;; a bare word
                    [[swap join] dip inject first swap [pack] dip]
                    join ;; add the program snippet b above to the
                    ;; snippet a, to get a program for step
                    step ;; step through the above program, using
                    ;; the list as data
                    discard ;; we dont need the copy of the
                    ;; original stack anymore
                   ]]
       [examples [[[[1 2 3] [inc] map] [[2 3 4]]]
                  [[1 [1 2 3] [+] map] [[2 3 4] 1]]
                  [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]]
                  [[7 9 [+] [] map] [[+] 9 7]]]]]]

 [filter [[spec [[p program]
                 [l list]]]
          [definition [[snapshot [] swap]
                       dipdown
                       ;; clone the original value so we can save it in results if needed
                       [[clone] dip clone wrap swapdown]
                       swap pack
                       [join inject first
                        ;; if passes filter, pack it into results
                        [[pack]]
                        ;; othewise discard it
                        [[discard]]
                        branch
                        swapdown
                        dip]
                       join step discard]]]]

 [nothing? [[spec [[a item]]]
            [definition [[] =]]]]

 [something? [[spec [[a item]]]
              [definition [nothing? not]]]]

 [while [[spec [[body program]
                [pred program]]]
         [definition [swap wrap [shield] join ;; add shield to the pred program
                      clone dipdown ;; run it on the previous ToS
                      join loop]]
         [examples [[[3 [0 >] [clone dec] while] [0 1 2 3]]]]]]]
