<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-08-07 Mon 02:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The kcats Programming Language (Production Implementation)</title>
<meta name="author" content="Skyrod Vactai" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="styles.css"/>
<style type="text/css">
.org-src-container.results > pre {
margin: 1px 0 0 2em;
}
.org-src-container > pre {
margin: 1px 0 0 2em;
}
.org-src-container.results::before {
content: "Result:";
display: inline-block;
font-size: 0.55em;
margin: 0 0 0 3em;
padding: 0;
}
p {
margin: 12px 0 12px 0;
}
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The kcats Programming Language (Production Implementation)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge27ac2f">1. Production implementation</a>
<ul>
<li><a href="#orged5d5fc">1.1. Base Language</a></li>
<li><a href="#orga05c054">1.2. Status</a></li>
<li><a href="#org32af47e">1.3. Using</a>
<ul>
<li><a href="#org1a76e01">1.3.1. Dependencies</a></li>
<li><a href="#org7f2c364">1.3.2. Build</a></li>
<li><a href="#org34c2998">1.3.3. Run</a></li>
<li><a href="#orgbdd4e79">1.3.4. Emacs REPL</a></li>
</ul>
</li>
<li><a href="#org663b70a">1.4. Source</a>
<ul>
<li><a href="#org41c3e50">1.4.1. Project File</a></li>
<li><a href="#org2953944">1.4.2. Internal data types</a>
<ul>
<li><a href="#org7480b74">1.4.2.1. Basic internal types</a></li>
<li><a href="#org84bbe46">1.4.2.2. Collection types</a></li>
<li><a href="#orgb0939b8">1.4.2.3. Associative types</a></li>
<li><a href="#orgacb5d33">1.4.2.4. Error types</a></li>
<li><a href="#org7973589">1.4.2.5. Dictionary types</a></li>
<li><a href="#orgb3b1e5c">1.4.2.6. Environment types</a></li>
<li><a href="#org2cc4d2f">1.4.2.7. Cryptographic primitives</a></li>
</ul>
</li>
<li><a href="#orgfcc4fe7">1.4.3. Serialization</a></li>
<li><a href="#orgb30914b">1.4.4. Builtin words</a></li>
<li><a href="#orgc5288a1">1.4.5. Top level execution</a></li>
<li><a href="#org591aea7">1.4.6. Pipes (input/output)</a></li>
</ul>
</li>
<li><a href="#org32abe9f">1.5. Issues</a>
<ul>
<li><a href="#org8685e66">1.5.1. <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></a>
<ul>
<li><a href="#org59deb3f">1.5.1.1. <span class="todo TODO">TODO</span> Only print the changed part of the stack</a></li>
<li><a href="#orgf57e784">1.5.1.2. <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</a></li>
</ul>
</li>
<li><a href="#orgcf5bdc9">1.5.2. <span class="done DONE">DONE</span> Install the lexicon in the proper place</a></li>
<li><a href="#org368e5e8">1.5.3. <span class="done CANCELED">CANCELED</span> Add option to read an alternative lexicon file</a></li>
<li><a href="#org9a5698a">1.5.4. <span class="todo TODO">TODO</span> Package the binary for various platforms</a></li>
<li><a href="#orgee59bc3">1.5.5. <span class="done DONE">DONE</span> Optimize memory allocation</a>
<ul>
<li><a href="#org22ac4a9">1.5.5.1. <span class="done DONE">DONE</span> Lists</a></li>
</ul>
</li>
<li><a href="#org62da342">1.5.6. <span class="done DONE">DONE</span> pack and unpack are not inverse</a></li>
<li><a href="#orgaf74919">1.5.7. <span class="done DONE">DONE</span> true and false are not words?</a></li>
<li><a href="#orgab28aca">1.5.8. <span class="done DONE">DONE</span> Division by zero panics</a></li>
<li><a href="#org454563e">1.5.9. <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#orgcd91184">1.5.9.1. <span class="done DONE">DONE</span> Write to a file</a></li>
<li><a href="#org926b9fd">1.5.9.2. <span class="done DONE">DONE</span> Read from a file</a></li>
<li><a href="#org10c9a66">1.5.9.3. <span class="done DONE">DONE</span> Close a pipe</a></li>
<li><a href="#org796493c">1.5.9.4. <span class="done DONE">DONE</span> Serialize pipes with something sane</a></li>
<li><a href="#org9a22f87">1.5.9.5. <span class="done DONE">DONE</span> Sockets</a></li>
<li><a href="#org2322074">1.5.9.6. <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</a></li>
<li><a href="#org5a52409">1.5.9.7. <span class="todo TODO">TODO</span> Composable transforms</a></li>
<li><a href="#org40b0b92">1.5.9.8. <span class="done CANCELED">CANCELED</span> Filled pipes</a></li>
<li><a href="#org8598e47">1.5.9.9. <span class="todo TODO">TODO</span> Object pipes</a></li>
<li><a href="#org02e7858">1.5.9.10. <span class="done DONE">DONE</span> Time pipe</a></li>
<li><a href="#org88cb6d3">1.5.9.11. <span class="done DONE">DONE</span> stdin/stdout pipes</a></li>
<li><a href="#org7f1e368">1.5.9.12. <span class="todo TODO">TODO</span> Pipe take outcome</a></li>
</ul>
</li>
<li><a href="#org1fd7540">1.5.10. <span class="done DONE">DONE</span> 'Fail' is not defined</a></li>
<li><a href="#orge8d7c76">1.5.11. <span class="done DONE">DONE</span> 'dictionary' doesn't allow access to the data inside definitions</a></li>
<li><a href="#orgcf53fe4">1.5.12. <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a></li>
<li><a href="#org5a5bd92">1.5.13. <span class="done DONE">DONE</span> Change boolean operators to retain values</a></li>
<li><a href="#org3a052f5">1.5.14. <span class="done DONE">DONE</span> 'recover' is broken</a></li>
<li><a href="#org7c5c127">1.5.15. <span class="done DONE">DONE</span> Fix handle in nested env</a></li>
<li><a href="#org641acdc">1.5.16. <span class="done DONE">DONE</span> Lots of association-like objects that aren't</a></li>
<li><a href="#orgd7195fd">1.5.17. <span class="done DONE">DONE</span> scoping of dictionary entries</a>
<ul>
<li><a href="#org2731a05">1.5.17.1. What to call this word</a></li>
<li><a href="#org8ef945f">1.5.17.2. Implementation</a></li>
</ul>
</li>
<li><a href="#orgdf5ddf4">1.5.18. <span class="done DONE">DONE</span> Move environment stuff into own module</a></li>
<li><a href="#orgdfe78b9">1.5.19. <span class="done DONE">DONE</span> When printing results, don't wrap the stack</a></li>
<li><a href="#org8afa6d4">1.5.20. <span class="done DONE">DONE</span> Update pipes to use enums instead of traits</a></li>
<li><a href="#org6087a95">1.5.21. <span class="done CANCELED">CANCELED</span> Recover clears the stack built up in the try program</a></li>
<li><a href="#org0b86e78">1.5.22. <span class="done DONE">DONE</span> List access and update by index</a></li>
<li><a href="#orge9b4234">1.5.23. <span class="done DONE">DONE</span> write 'let'</a></li>
<li><a href="#orgca3e696">1.5.24. <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a></li>
<li><a href="#org9d1f91e">1.5.25. <span class="todo TODO">TODO</span> Script</a>
<ul>
<li><a href="#org3c79278">1.5.25.1. <span class="done DONE">DONE</span> Cryptographic primitives</a></li>
<li><a href="#org47a5c97">1.5.25.2. <span class="done DONE">DONE</span> Pure functional env</a></li>
<li><a href="#org53d4ec0">1.5.25.3. <span class="todo TODO">TODO</span> Infinite loop protection</a></li>
</ul>
</li>
<li><a href="#org93d31ce">1.5.26. <span class="done DONE">DONE</span> Multithreading</a>
<ul>
<li><a href="#org30ea8cf">1.5.26.1. Overview</a></li>
<li><a href="#orga249a56">1.5.26.2. Pipes</a></li>
<li><a href="#org77588a9">1.5.26.3. <span class="done DONE">DONE</span> Add tokio as dep</a></li>
<li><a href="#org732d969">1.5.26.4. <span class="done DONE">DONE</span> Prepare for multithreading</a></li>
<li><a href="#org328099e">1.5.26.5. <span class="done DONE">DONE</span> Update pipe types for fs and net to use tokio calls</a></li>
<li><a href="#org67944cd">1.5.26.6. <span class="done DONE">DONE</span> Use channel type to implement handoff pipe</a></li>
<li><a href="#org1f536a3">1.5.26.7. <span class="done DONE">DONE</span> Implement 'spawn' or equavalent</a></li>
<li><a href="#orgf390ae3">1.5.26.8. <span class="done DONE">DONE</span> Implement 'future' or equivalent</a></li>
</ul>
</li>
<li><a href="#orgea066d2">1.5.27. <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></a></li>
<li><a href="#org694995d">1.5.28. <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</a>
<ul>
<li><a href="#orgf362ff3">1.5.28.1. <span class="done DONE">DONE</span> XOR</a></li>
<li><a href="#orga497dad">1.5.28.2. <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</a></li>
<li><a href="#orga3177e4">1.5.28.3. <span class="todo TODO">TODO</span> Kademlia functions</a></li>
</ul>
</li>
<li><a href="#orgff948d9">1.5.29. <span class="done DONE">DONE</span> Implement print (opposite of read)</a></li>
<li><a href="#org9ed4873">1.5.30. <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a></li>
<li><a href="#orgf75f1a6">1.5.31. <span class="todo TODO">TODO</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a>
<ul>
<li><a href="#org178da2a">1.5.31.1. <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</a></li>
<li><a href="#orgdb9ce69">1.5.31.2. <span class="todo TODO">TODO</span> Division by zero consumes stack items</a></li>
</ul>
</li>
<li><a href="#org7382311">1.5.32. <span class="done DONE">DONE</span> logical enum hierarchy</a>
<ul>
<li><a href="#org1f824ef">1.5.32.1. <span class="done DONE">DONE</span> Collection hierarchy</a></li>
<li><a href="#org85a34cf">1.5.32.2. <span class="done DONE">DONE</span> pipe as list-like thing</a></li>
<li><a href="#org2ddde48">1.5.32.3. <span class="done DONE">DONE</span> Step accepts pipes</a></li>
<li><a href="#org6bc7fb6">1.5.32.4. <span class="done DONE">DONE</span> Set close = discard</a></li>
<li><a href="#org66b2f0c">1.5.32.5. <span class="done DONE">DONE</span> Remove closed?</a></li>
<li><a href="#orgccf2359">1.5.32.6. <span class="done DONE">DONE</span> make a polymorphic 'join'</a></li>
<li><a href="#org26e5b62">1.5.32.7. <span class="done DONE">DONE</span> Update spec types to be more abstract</a></li>
</ul>
</li>
<li><a href="#orgc0194ec">1.5.33. <span class="done DONE">DONE</span> Support char type</a></li>
<li><a href="#org9d337ac">1.5.34. <span class="todo TODO">TODO</span> implement sleep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a></li>
<li><a href="#orgdc01176">1.5.35. <span class="done DONE">DONE</span> handoff tests</a></li>
<li><a href="#org272a64b">1.5.36. <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a>
<ul>
<li><a href="#orga66ab00">1.5.36.1. <span class="todo TODO">TODO</span> Compile programs</a></li>
<li><a href="#orga423628">1.5.36.2. <span class="todo TODO">TODO</span> Programs as their own immutable type</a></li>
</ul>
</li>
<li><a href="#org8a33322">1.5.37. <span class="todo TODO">TODO</span> Debugging method for animated envs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></a></li>
<li><a href="#org8a84eff">1.5.38. <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#orgb162b52">1.5.38.1. <span class="done DONE">DONE</span> Basic functionality and generators</a></li>
<li><a href="#org7fc559e">1.5.38.2. <span class="done DONE">DONE</span> map</a></li>
<li><a href="#orgcee0c5e">1.5.38.3. <span class="done DONE">DONE</span> filter</a></li>
<li><a href="#org29ff266">1.5.38.4. <span class="done DONE">DONE</span> take</a></li>
<li><a href="#org2010666">1.5.38.5. <span class="done DONE">DONE</span> drop</a></li>
<li><a href="#orgf65f60b">1.5.38.6. <span class="done CANCELED">CANCELED</span> last</a></li>
<li><a href="#orgb758dff">1.5.38.7. <span class="todo TODO">TODO</span> distinct</a></li>
<li><a href="#org3d59539">1.5.38.8. <span class="todo TODO">TODO</span> partition</a></li>
<li><a href="#orgfb14ed6">1.5.38.9. <span class="done DONE">DONE</span> joiner (aka catenate)</a></li>
<li><a href="#org5d2efb0">1.5.38.10. <span class="todo TODO">TODO</span> groupby</a></li>
<li><a href="#org1869887">1.5.38.11. <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</a></li>
<li><a href="#org3cd2267">1.5.38.12. <span class="done DONE">DONE</span> Reduce</a></li>
</ul>
</li>
<li><a href="#org30dd496">1.5.39. <span class="done DONE">DONE</span> Investigate simpler map/filter impls</a></li>
<li><a href="#org88d015c">1.5.40. <span class="done DONE">DONE</span> Allow generator transforms to work on pipes</a></li>
<li><a href="#orgf95a1c5">1.5.41. <span class="todo INPROGRESS">INPROGRESS</span> Implement hashset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org230d2e9">1.5.41.1. <span class="todo INPROGRESS">INPROGRESS</span> Implement set membership check</a></li>
</ul>
</li>
<li><a href="#org158ade1">1.5.42. <span class="done DONE">DONE</span> Implement until</a></li>
<li><a href="#org3c3f71f">1.5.43. <span class="todo TODO">TODO</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org0c63b13">1.5.43.1. <span class="todo TODO">TODO</span> Implement partialord</a></li>
<li><a href="#org720425b">1.5.43.2. <span class="todo TODO">TODO</span> Make floats hashable</a></li>
<li><a href="#orgf465ee5">1.5.43.3. <span class="todo TODO">TODO</span> Implement compare</a></li>
</ul>
</li>
<li><a href="#orga6a93e4">1.5.44. <span class="todo INPROGRESS">INPROGRESS</span> CI on github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#org70e47a3">1.5.45. <span class="done DONE">DONE</span> Add a kcats logo to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#org896035b">1.5.46. <span class="done DONE">DONE</span> Add a video snippet of repl interaction to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#org545cc61">1.5.47. <span class="todo INPROGRESS">INPROGRESS</span> Write an alpha release announcement&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#orge4ff425">1.5.48. <span class="todo TODO">TODO</span> Post announcement on various forums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge27ac2f" class="outline-2">
<h2 id="orge27ac2f"><span class="section-number-2">1.</span> Production implementation</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orged5d5fc" class="outline-3">
<h3 id="orged5d5fc"><span class="section-number-3">1.1.</span> Base Language</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Built in Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
</p>
</div>
</div>
<div id="outline-container-orga05c054" class="outline-3">
<h3 id="orga05c054"><span class="section-number-3">1.2.</span> Status</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Unstable
</p>
</div>
</div>
<div id="outline-container-org32af47e" class="outline-3">
<h3 id="org32af47e"><span class="section-number-3">1.3.</span> Using</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org1a76e01" class="outline-4">
<h4 id="org1a76e01"><span class="section-number-4">1.3.1.</span> Dependencies</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>rustc</li>
<li>cargo</li>
</ul>
</div>
</div>
<div id="outline-container-org7f2c364" class="outline-4">
<h4 id="org7f2c364"><span class="section-number-4">1.3.2.</span> Build</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Run <code>cargo build --release</code>, the binary will be placed in <code>./target/release</code> by
default.
</p>
</div>
</div>
<div id="outline-container-org34c2998" class="outline-4">
<h4 id="org34c2998"><span class="section-number-4">1.3.3.</span> Run</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Execute the binary: <code>./target/release/kcats</code>. It will read a program
from stdin and execute it, then print the resulting stack. (To signal
you're done with input, on most platforms Ctrl-D will do it).
</p>
</div>
</div>
<div id="outline-container-orgbdd4e79" class="outline-4">
<h4 id="orgbdd4e79"><span class="section-number-4">1.3.4.</span> Emacs REPL</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
See <a href="book-of-kcats.html#MissingReference">Emacs</a>. The elisp files you need to evaluate are there. Evaluate
them, then run <code>M-x kcats-repl</code>. You may need to run <code>M-x
customize-variable</code>, <code>kcats-babel-executable</code>, and enter the location of
the kcats binary.
</p>
</div>
</div>
</div>
<div id="outline-container-org663b70a" class="outline-3">
<h3 id="org663b70a"><span class="section-number-3">1.4.</span> Source</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org41c3e50" class="outline-4">
<h4 id="org41c3e50"><span class="section-number-4">1.4.1.</span> Project File</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-toml">[<span style="font-weight: bold; text-decoration: underline;">package</span>]
<span style="font-weight: bold; font-style: italic;">name</span> = <span style="font-style: italic;">"kcats"</span>
<span style="font-weight: bold; font-style: italic;">version</span> = <span style="font-style: italic;">"0.3.0"</span>
<span style="font-weight: bold; font-style: italic;">edition</span> = <span style="font-style: italic;">"2021"</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

[<span style="font-weight: bold; text-decoration: underline;">dependencies</span>]
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">serialization</span>
<span style="font-weight: bold; font-style: italic;">edn-format</span> = <span style="font-style: italic;">"3.2.3"</span>
<span style="font-weight: bold; font-style: italic;">base64</span> = <span style="font-style: italic;">"0.13.0"</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">String literals</span>
<span style="font-weight: bold; font-style: italic;">internment</span> = <span style="font-style: italic;">"0.6.0"</span> 
<span style="font-weight: bold; font-style: italic;">lazy_static</span> = <span style="font-style: italic;">"1.4.0"</span>

<span style="font-weight: bold; font-style: italic;">num-integer</span> = <span style="font-style: italic;">"0.1.44"</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">crypto stuff</span>
<span style="font-weight: bold; font-style: italic;">ed25519-dalek</span> = {version=<span style="font-style: italic;">"1"</span>, features=[<span style="font-style: italic;">"batch_deterministic"</span>, <span style="font-style: italic;">"std"</span>, <span style="font-style: italic;">"rand"</span>]}
<span style="font-weight: bold; font-style: italic;">sha2</span> = <span style="font-style: italic;">"0.10.6"</span>
<span style="font-weight: bold; font-style: italic;">rand_core</span> = <span style="font-style: italic;">"0.5.1"</span> <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">careful here, having 2 versions present will make weird compile errors</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">multithreading</span>
<span style="font-weight: bold; font-style: italic;">futures</span> = <span style="font-style: italic;">"0.3"</span>
<span style="font-weight: bold; font-style: italic;">tokio</span> = { version = <span style="font-style: italic;">"1"</span>, features = [<span style="font-style: italic;">"full"</span>] }
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">multiple-consumer channels</span>
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">crossbeam-channel = "0.5" # doesn't support async send/recv</span>
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">async-channel = "1.8.0"</span>
<span style="font-weight: bold; font-style: italic;">flume</span> = <span style="font-style: italic;">"0.10.14"</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">debugging</span>
<span style="font-weight: bold; font-style: italic;">backtrace</span> = <span style="font-style: italic;">"0.3.61"</span>
[<span style="font-weight: bold; text-decoration: underline;">dev-dependencies</span>]
<span style="font-weight: bold; font-style: italic;">test-case</span> = <span style="font-style: italic;">"2.0.0"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org2953944" class="outline-4">
<h4 id="org2953944"><span class="section-number-4">1.4.2.</span> Internal data types</h4>
<div class="outline-text-4" id="text-1-4-2">
</div>
<div id="outline-container-org7480b74" class="outline-5">
<h5 id="org7480b74"><span class="section-number-5">1.4.2.1.</span> Basic internal types</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<p>
We'll start by defining the basic data structures that kcats will use
internally, to keep track of things like the stack, expression, lists etc.
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::pipes::{In, Out};
use crate::types::collection as coll;
use crate::types::dictionary as dict;
use crate::types::environment as env;
use crate::types::error::Error;
use internment::Intern;
use lazy_static::lazy_static;
use std::collections::{HashMap, VecDeque};
use std::fmt;
use std::hash::Hash;
use std::marker::Sync;
use std::ops::{Deref, DerefMut};
use std::pin::Pin;

pub mod associative;
pub mod collection;
pub mod dictionary;
pub mod environment;
pub mod error;

// A generic newtype to contain various kinds
#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub struct Newtype&lt;T&gt;(pub T);

// Access the inner value easily
impl&lt;T&gt; Deref for Newtype&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;T&gt; DerefMut for Newtype&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl&lt;T: IntoIterator&gt; IntoIterator for Newtype&lt;T&gt; {
    type Item = T::Item;
    type IntoIter = T::IntoIter;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.0.into_iter()
    }
}

// but still clone the whole thing, not the inner part
impl&lt;T: Clone&gt; Clone for Newtype&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Newtype(self.0.clone())
    }
}

pub type Word = Intern&lt;String&gt;;

pub type Stack = collection::List;

pub type Bytes = Vec&lt;u8&gt;;

pub type Int = i64;

pub type Float = f64;

pub type Char = char;

lazy_static! {
    pub static ref S_ASSOC: Intern&lt;String&gt; = Intern::new("association".to_string());
    pub static ref S_BOOLEAN: Intern&lt;String&gt; = Intern::new("boolean".to_string());
    pub static ref S_BYTES: Intern&lt;String&gt; = Intern::new("bytes".to_string());
    pub static ref S_CHAR: Intern&lt;String&gt; = Intern::new("character".to_string());
    pub static ref S_ENVIRONMENT: Intern&lt;String&gt; = Intern::new("environment".to_string());
    pub static ref S_ERROR: Intern&lt;String&gt; = Intern::new("error".to_string());
    pub static ref S_FLOAT: Intern&lt;String&gt; = Intern::new("float".to_string());
    pub static ref S_INTEGER: Intern&lt;String&gt; = Intern::new("integer".to_string());
    pub static ref S_ITEM: Intern&lt;String&gt; = Intern::new("item".to_string());
    pub static ref S_LIST: Intern&lt;String&gt; = Intern::new("list".to_string());
    pub static ref S_NUMBER: Intern&lt;String&gt; = Intern::new("number".to_string());
    pub static ref S_PIPE: Intern&lt;String&gt; = Intern::new("pipe".to_string());
    pub static ref S_PROGRAM: Intern&lt;String&gt; = Intern::new("program".to_string());
    pub static ref S_STRING: Intern&lt;String&gt; = Intern::new("string".to_string());
    pub static ref S_WORD: Intern&lt;String&gt; = Intern::new("word".to_string());
    pub static ref S_DISPENSER: Intern&lt;String&gt; = Intern::new("dispenser".to_string());
    pub static ref S_SIZED: Intern&lt;String&gt; = Intern::new("sized".to_string());
    pub static ref S_ORDERED: Intern&lt;String&gt; = Intern::new("ordered".to_string());
}

// #[derive(Debug, Clone)]
// pub enum Sequence {
//     Assoc(Associative),
//     List(ListContent),
//     Nothing,
// }

#[derive(Debug, Clone)]
pub enum Item {
    Int(Int),
    Float(Float),
    Word(Word),
    Char(Char),
    Dispenser(coll::Dispenser),
    Receptacle(coll::Receptacle),
}

pub type Future&lt;T&gt; = Pin&lt;Box&lt;dyn std::future::Future&lt;Output = T&gt; + Send&gt;&gt;;
pub type StepFn = dyn Fn(env::Environment) -&gt; Future&lt;env::Environment&gt; + Sync + Send;

impl PartialEq for Item {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            // same types, just use their own eq
            (Item::Int(a), Item::Int(b)) =&gt; a == b,
            (Item::Float(a), Item::Float(b)) =&gt; a == b,
            (Item::Word(a), Item::Word(b)) =&gt; a == b,
            (
                Item::Dispenser(coll::Dispenser::Sized(a)),
                Item::Receptacle(coll::Receptacle::Sized(b)),
            ) =&gt; a == b,
            (
                Item::Receptacle(coll::Receptacle::Sized(a)),
                Item::Dispenser(coll::Dispenser::Sized(b)),
            ) =&gt; a == b,
            (Item::Dispenser(a), Item::Dispenser(b)) =&gt; a == b,
            (Item::Char(a), Item::Char(b)) =&gt; a == b,
            // (Item::Assoc(a), Item::Assoc(b)) =&gt; a == b,
            // (Item::List(a), Item::List(b)) =&gt; a == b,
            // //TODO: (Item::Collection(a), Item::Collection(b)) =&gt; a == b,
            // (Item::Env(a), Item::Env(b)) =&gt; a == b,
            // (Item::Entry(a), Item::Entry(b)) =&gt; a == b,
            // (Item::Dictionary(a), Item::Dictionary(b)) =&gt; a == b,
            // (Item::Error(a), Item::Error(b)) =&gt; a == b,
            // //TODO:
            // //(Item::In(a), Item::In(b)) =&gt; a == b,
            // //(Item::Out(a), Item::Out(b)) =&gt; a == b,
            // //(Item::Tunnel(a), Item::Tunnel(b)) =&gt; a == b,
            // (Item::Nothing, Item::Nothing) =&gt; true,
            // // different types, but can be converted to the same type
            // (Item::Nothing, Item::List(l)) =&gt; l.is_empty(),
            // (Item::List(l), Item::Nothing) =&gt; l.is_empty(),

            // (Item::Nothing, Item::Assoc(l)) =&gt; l.is_empty(),
            // (Item::Assoc(l), Item::Nothing) =&gt; l.is_empty(),

            // (Item::Nothing, Item::Collection(l)) =&gt; l.is_empty(),
            // (Item::Collection(l), Item::Nothing) =&gt; l.is_empty(),

            // (Item::List(l), Item::Assoc(a)) =&gt; l.is_empty() &amp;&amp; a.is_empty(),
            // (Item::Assoc(a), Item::List(l)) =&gt; l.is_empty() &amp;&amp; a.is_empty(),
            //(Item::Error(i), Item::Assoc(j)) =&gt; (*i).data == *j,
            //(Item::Assoc(i), Item::Error(j)) =&gt; (*j).data == *i,

            //TODO Definition, Associative etc
            _ =&gt; false,
        }
    }
}

// The default Item is NOTHING.
impl Default for Item {
    fn default() -&gt; Self {
        coll::NOTHING
    }
}

pub fn wrap(i: Item) -&gt; coll::List {
    coll::List::from_iter([i])
}

impl TryFrom&lt;Item&gt; for Int {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Int(i) =&gt; Ok(i),
            i =&gt; Err(Error::expected("integer", i)),
        }
    }
}

impl TryFrom&lt;Item&gt; for Float {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Float(i) =&gt; Ok(i),
            i =&gt; Err(Error::expected("float", i)),
        }
    }
}

impl TryFrom&lt;Item&gt; for String {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;
        match s {
            coll::Sized::String(i) =&gt; Ok(i),
            i =&gt; Err(Error::expected("string", i.into())),
        }
    }
}

impl TryFrom&lt;Item&gt; for Word {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Word(i) =&gt; Ok(i),
            i =&gt; Err(Error::expected("word", i)),
        }
    }
}

impl TryFrom&lt;Item&gt; for Bytes {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;
        match s {
            coll::Sized::Bytes(b) =&gt; Ok(b),
            b =&gt; Err(Error::expected("bytes", b.into())),
        }
    }
}

// impl TryFrom&lt;Item&gt; for Association {
//     type Error = Error;
//     fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
//         match i {
//             Item::Assoc(a) =&gt; Ok(a),
//             Item::List(l) =&gt; Ok(to_hash(l)?),
//             Item::Nothing =&gt; Ok(Arc::new(AssociationContent::new())),
//             Item::DerivedDef(d) =&gt; Ok(Association::from(d)),
//             Item::AxiomDef(a) =&gt; Ok(Association::from(a)),
//             Item::Env(e) =&gt; Ok(Association::from(e)),
//             Item::Error(e) =&gt; Ok(Association::from(e)),
//             _ =&gt; Err(Error::expected("association")),
//         }
//     }
// }

impl TryFrom&lt;Item&gt; for In {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Receptacle(coll::Receptacle::In(i)) =&gt; Ok(i),
            i =&gt; Err(Error::expected("pipe", i)),
        }
    }
}

impl TryFrom&lt;Item&gt; for Out {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Dispenser(coll::Dispenser::Out(o)) =&gt; Ok(o),
            i =&gt; Err(Error::expected("pipe", i)),
        }
    }
}

// As there are no real booleans, we use the word 'true' but literally
// any value except the empty list is truthy. If we read a value
// 'false' in edn, that's not actually a boolean, it's just the
// symbol/word false.
impl From&lt;bool&gt; for Item {
    fn from(b: bool) -&gt; Item {
        if b {
            "true".into()
        } else {
            coll::NOTHING
        }
    }
}

// impl From&lt;Environment&gt; for Association {
//     fn from(env: Environment) -&gt; Association {
//         let mut a = AssociationContent::new();
//         a.insert(word_key("stack"), Item::List(env.stack.clone()));
//         a.insert(word_key("expression"), Item::List(env.expression.clone()));
//         a.insert(word_key("dictionary"), Item::Assoc(env.dictionary.clone()));
//         Arc::new(a)
//     }
// }

impl From&lt;std::io::Error&gt; for Error {
    fn from(err: std::io::Error) -&gt; Error {
        Error::create(wrap("io".into()), &amp;err.to_string(), None)
    }
}

impl From&lt;&amp;str&gt; for Item {
    fn from(i: &amp;str) -&gt; Self {
        Item::Word(Word::from(i))
    }
}

impl From&lt;String&gt; for Item {
    fn from(i: String) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(i)))
    }
}

impl From&lt;Bytes&gt; for Item {
    fn from(b: Bytes) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(b)))
    }
}

impl From&lt;Char&gt; for Item {
    fn from(c: Char) -&gt; Self {
        Item::Char(c)
    }
}

impl From&lt;Int&gt; for Item {
    fn from(c: Int) -&gt; Self {
        Item::Int(c)
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org84bbe46" class="outline-5">
<h5 id="org84bbe46"><span class="section-number-5">1.4.2.2.</span> Collection types</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<div class="org-src-container">
<pre class="src src-rust">use futures::FutureExt;

use crate::pipes as pipe;
use crate::types::associative as assoc;
use crate::types::*;
use std::{collections::HashSet, future, sync};

pub type Arc&lt;T&gt; = Newtype&lt;sync::Arc&lt;T&gt;&gt;;
pub type Listy&lt;I&gt; = Newtype&lt;VecDeque&lt;I&gt;&gt;;
pub type Setty&lt;I&gt; = Newtype&lt;HashSet&lt;I&gt;&gt;;
// impl&lt;T: PartialEq&gt; PartialEq for Newtype&lt;Arc&lt;T&gt;&gt; {
//     fn eq(&amp;self, other: &amp;Self) -&gt; bool {
//         **self.0 == **other.0
//     }
// }

impl&lt;T: Clone&gt; Arc&lt;T&gt; {
    pub fn make_mut(&amp;mut self) -&gt; &amp;mut T {
        sync::Arc::make_mut(&amp;mut self.0)
    }

    pub fn inner(&amp;mut self) -&gt; T {
        sync::Arc::try_unwrap(self.0.clone()).unwrap_or_else(|rc| (*rc).clone())
    }

    pub fn wrap(inner: T) -&gt; Self {
        Self(sync::Arc::new(inner))
    }
}

pub type ListContent = Listy&lt;Item&gt;;
pub type List = Arc&lt;ListContent&gt;;
pub type Set = Arc&lt;Setty&lt;assoc::KeyItem&gt;&gt;;

impl List {
    pub fn new() -&gt; List {
        Newtype(sync::Arc::new(Newtype(VecDeque::new())))
    }
}

impl Set {
    pub fn from(h: HashSet&lt;assoc::KeyItem&gt;) -&gt; Set {
        Newtype(sync::Arc::new(Newtype(h)))
    }

    pub fn new() -&gt; Set {
        Set::from(HashSet::new())
    }
}

impl FromIterator&lt;Item&gt; for List {
    fn from_iter&lt;I&gt;(iter: I) -&gt; Self
    where
        I: IntoIterator&lt;Item = Item&gt;,
    {
        Newtype(sync::Arc::new(Newtype(
            iter.into_iter().collect::&lt;VecDeque&lt;Item&gt;&gt;(),
        )))
    }
}

// Most generic collection type, all we know is it can contain
// multiple items.
#[derive(Debug, Clone, PartialEq)]
pub enum Dispenser {
    Sized(Sized),
    Out(pipe::Out),
    Tunnel(pipe::Tunnel),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Receptacle {
    Sized(Sized),
    In(pipe::In),
    Tunnel(pipe::Tunnel),
}

// Collection that has a definite size that we can access. Implies
// that it can also be appended to.
#[derive(Debug, Clone)]
pub enum Sized {
    Associative(assoc::Associative),
    List(List),
    Set(Set),
    String(String),
    Bytes(Bytes),
    Nothing,
}

impl PartialEq for Sized {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if self.is_empty() &amp;&amp; other.is_empty() {
            return true;
        }
        match (self, other) {
            (Sized::Associative(a), Sized::Associative(b)) =&gt; a == b,
            (Sized::List(a), Sized::List(b)) =&gt; a == b,
            (Sized::String(a), Sized::String(b)) =&gt; a == b,
            (Sized::Bytes(a), Sized::Bytes(b)) =&gt; a == b,
            (Sized::Set(a), Sized::Set(b)) =&gt; a == b,
            (Sized::Nothing, Sized::Nothing) =&gt; true,
            (Sized::Nothing, l) =&gt; l.is_empty(),
            (l, Sized::Nothing) =&gt; l.is_empty(),
            _ =&gt; false,
        }
    }
}
// a const Item value for Nothing
pub const NOTHING: Item = Item::Dispenser(Dispenser::Sized(Sized::Nothing));

impl Dispenser {
    pub fn take(self) -&gt; Future&lt;(Dispenser, Option&lt;Item&gt;)&gt; {
        match self {
            Dispenser::Sized(s) =&gt; Box::pin(future::ready(s.take())),
            Dispenser::Out(mut o) =&gt; Box::pin({
                let i = o.take();
                i.map(|r| {
                    (
                        Dispenser::Out(o),
                        match r {
                            Ok(Some(i)) =&gt; Some(i),
                            Ok(None) =&gt; None,
                            Err(e) =&gt; Some(Item::from(e)),
                        },
                    )
                })
            }),
            Dispenser::Tunnel(mut t) =&gt; Box::pin({
                let i = t.take();
                i.map(|r| {
                    (
                        Dispenser::Tunnel(t),
                        match r {
                            Ok(Some(i)) =&gt; Some(i),
                            Ok(None) =&gt; None,
                            Err(e) =&gt; Some(Item::from(e)),
                        },
                    )
                })
            }),
        }
    }
}

impl Sized {
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }

    pub fn len(&amp;self) -&gt; usize {
        match self {
            Sized::Associative(a) =&gt; a.len(),
            Sized::List(l) =&gt; l.len(),
            Sized::String(s) =&gt; s.len(),
            Sized::Bytes(b) =&gt; b.len(),
            Sized::Set(s) =&gt; s.len(),
            Sized::Nothing =&gt; 0,
        }
    }

    pub fn take(self) -&gt; (Dispenser, Option&lt;Item&gt;) {
        match self {
            Sized::Associative(a) =&gt; a.take(),
            Sized::List(mut l) =&gt; {
                let lm = l.make_mut();
                let i = lm.pop_front();
                (Dispenser::Sized(Sized::List(l)), i)
            }
            Sized::Nothing =&gt; (Dispenser::Sized(Sized::Nothing), None),
            Sized::String(mut s) =&gt; {
                let i = s.pop().map(Item::Char);
                (Dispenser::Sized(Sized::String(s)), i)
            }
            Sized::Bytes(mut b) =&gt; {
                let i = b.pop().map(|b| Item::Int(b as i64));
                (Dispenser::Sized(Sized::Bytes(b)), i)
            }
            Sized::Set(mut s) =&gt; {
                let i = s.iter().next().cloned();
                let sm = s.make_mut();
                if let Some(i) = i.clone() {
                    sm.take(&amp;i);
                }
                (Dispenser::Sized(Sized::Set(s)), i.map(Item::from))
            }
        }
    }

    pub fn put(self, other: Item) -&gt; Result&lt;Sized, Error&gt; {
        match (self, other) {
            (Sized::List(mut c), i) =&gt; {
                c.make_mut().push_back(i);
                Ok(Sized::List(c))
            }
            (Sized::Associative(a), l) =&gt; Ok(Sized::Associative(a.put(l)?)),
            (Sized::Set(mut s), i) =&gt; {
                s.make_mut().insert(assoc::KeyItem::try_from(i)?);
                Ok(Sized::Set(s))
            }
            (Sized::Bytes(mut b), Item::Int(i)) =&gt; {
                b.push(i as u8);
                Ok(Sized::Bytes(b))
            }
            (Sized::Nothing, i) =&gt; Ok(Sized::List(List::from_iter([i]))),
            (Sized::String(_), _) =&gt; unimplemented!(),
            (i, _) =&gt; Err(Error::expected("packable", i.into())),
        }
    }

    pub fn join(self, other: Sized) -&gt; Result&lt;Sized, Error&gt; {
        Ok(match (self, other) {
            (Sized::Associative(a), Sized::List(l)) =&gt; Sized::Associative({
                let mut a: assoc::Association = a.into();
                let mut more = assoc::Association::try_from_iter(l.clone().inner().into_iter())?;
                let am = a.make_mut();
                am.extend(more.inner().into_iter());
                assoc::Associative::Assoc(a)
            }),
            (Sized::List(l), Sized::Associative(a)) =&gt; {
                let mut a: assoc::Association = a.into();
                let mut la = assoc::Association::try_from_iter(l.clone().inner().into_iter())?;
                let lam = la.make_mut();
                lam.extend(a.inner().into_iter());
                Sized::Associative(assoc::Associative::Assoc(la))
            }
            (Sized::Associative(a), Sized::Associative(b)) =&gt; Sized::Associative(a.join(b)),
            (Sized::List(mut a), Sized::List(mut b)) =&gt; {
                let am = a.make_mut();
                am.extend(b.inner());
                Sized::List(a)
            }
            (Sized::Set(mut a), Sized::Set(mut b)) =&gt; {
                let am = a.make_mut();
                am.extend(b.inner());
                Sized::Set(a)
            }
            (Sized::List(mut a), Sized::Set(mut b)) =&gt; {
                let bm = b.make_mut();

                bm.extend(
                    a.inner()
                        .into_iter()
                        .map(assoc::KeyItem::try_from)
                        .collect::&lt;Result&lt;Vec&lt;assoc::KeyItem&gt;, Error&gt;&gt;()?
                        .into_iter(),
                );
                Sized::Set(b)
            }
            (Sized::Set(mut a), Sized::List(mut b)) =&gt; {
                let am = a.make_mut();

                am.extend(
                    b.inner()
                        .into_iter()
                        .map(assoc::KeyItem::try_from)
                        .collect::&lt;Result&lt;Vec&lt;assoc::KeyItem&gt;, Error&gt;&gt;()?
                        .into_iter(),
                );
                Sized::Set(a)
            }
            (Sized::String(mut a), Sized::String(b)) =&gt; {
                a.push_str(&amp;b);
                Sized::String(a)
            }
            (Sized::Bytes(mut a), Sized::Bytes(b)) =&gt; {
                a.extend(b);
                Sized::Bytes(a)
            }
            (Sized::Nothing, x) =&gt; x,
            (x, Sized::Nothing) =&gt; x,
            //TODO: not every combination makes sense, return error here, don't panic
            (s, other) =&gt; todo!("Cannot join {:?} and {:?}", s, other),
        })
    }

    pub fn contains(&amp;self, other: &amp;Item) -&gt; bool {
        match (self, other) {
            (Sized::Associative(a), other) =&gt; {
                assoc::KeyItem::try_from(other.clone()).map_or(false, |k| a.contains_key(&amp;k))
            }
            (Sized::List(l), other) =&gt; l.contains(other),
            (Sized::Set(s), other) =&gt; {
                assoc::KeyItem::try_from(other.clone()).map_or(false, |k| s.contains(&amp;k))
            }
            _ =&gt; todo!("contains not implemented for {:?}", self),
        }
    }
}

impl Receptacle {
    pub fn put(self, i: Item) -&gt; Future&lt;Result&lt;Receptacle, Error&gt;&gt; {
        match self {
            Receptacle::Sized(s) =&gt; Box::pin(future::ready(s.put(i).map(Receptacle::Sized))),
            Receptacle::In(mut p) =&gt; Box::pin(p.put(i).map(|r| r.map(|_| Receptacle::In(p)))),
            Receptacle::Tunnel(mut t) =&gt; {
                let p = t.put(i);
                Box::pin(p.map(|r| r.map(|_| Receptacle::Tunnel(t))))
            }
        }
    }
}

impl IntoIterator for Sized {
    type Item = Item;
    type IntoIter = Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        match self {
            Sized::Associative(map) =&gt; Box::new(map.into_iter().map(|kv| kv.into())),
            Sized::List(mut list) =&gt; Box::new(list.inner().into_iter()),
            Sized::Nothing =&gt; Box::new(std::iter::empty()),
            Sized::String(s) =&gt; {
                let chars: Vec&lt;char&gt; = s.chars().collect();
                Box::new(chars.into_iter().map(|c| c.into()))
            }
            Sized::Bytes(b) =&gt; {
                let vec: Vec&lt;Item&gt; = b.into_iter().map(|byte| Item::from(byte as Int)).collect();
                Box::new(vec.into_iter())
            }
            Sized::Set(mut s) =&gt; Box::new(s.inner().into_iter().map(|i| i.into())),
        }
    }
}

impl TryFrom&lt;Dispenser&gt; for Sized {
    type Error = Error;

    fn try_from(c: Dispenser) -&gt; Result&lt;Self, Self::Error&gt; {
        //println!("from iterable {:?}", c);
        match c {
            Dispenser::Sized(s) =&gt; Ok(s),
            i =&gt; Err(Error::expected("sized", i.into())),
        }
    }
}

impl TryFrom&lt;Receptacle&gt; for Sized {
    type Error = Error;

    fn try_from(c: Receptacle) -&gt; Result&lt;Self, Self::Error&gt; {
        match c {
            Receptacle::Sized(s) =&gt; Ok(s),
            i =&gt; Err(Error::expected("sized", Item::Receptacle(i))),
        }
    }
}

impl TryFrom&lt;Sized&gt; for List {
    type Error = Error;

    fn try_from(s: Sized) -&gt; Result&lt;Self, Self::Error&gt; {
        match s {
            Sized::List(l) =&gt; Ok(l),
            Sized::Nothing =&gt; Ok(List::new()),
            Sized::Associative(a) =&gt; Ok(List::from_iter(a.into_iter().map(Item::from))),
            i =&gt; Err(Error::expected("list", i.into())),
        }
    }
}

impl TryFrom&lt;Item&gt; for List {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Dispenser(l) =&gt; Sized::try_from(l).and_then(List::try_from),
            Item::Receptacle(l) =&gt; Sized::try_from(l).and_then(List::try_from),
            i =&gt; Err(Error::expected("list", i.into())),
        }
    }
}

impl TryFrom&lt;Item&gt; for Sized {
    type Error = Error;

    fn try_from(item: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match item {
            Item::Dispenser(c) =&gt; c.try_into(),
            Item::Receptacle(p) =&gt; Dispenser::try_from(p)?.try_into(),
            i =&gt; {
                // let bt = backtrace::Backtrace::new();
                // println!("try from item {:?},\n {:?}", i, bt);
                Err(Error::expected("sized", i))
            }
        }
    }
}

impl TryFrom&lt;Item&gt; for Receptacle {
    type Error = Error;

    fn try_from(item: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match item {
            Item::Receptacle(p) =&gt; Ok(p),
            Item::Dispenser(c) =&gt; c.try_into(),
            i =&gt; Err(Error::expected("packable", i)),
        }
    }
}

impl TryFrom&lt;Dispenser&gt; for Receptacle {
    type Error = Error;

    fn try_from(c: Dispenser) -&gt; Result&lt;Self, Self::Error&gt; {
        match c {
            Dispenser::Sized(s) =&gt; Ok(Receptacle::Sized(s)),
            Dispenser::Tunnel(t) =&gt; Ok(Receptacle::Tunnel(t)),
            i =&gt; Err(Error::expected("packable", i.into())),
        }
    }
}

impl TryFrom&lt;Receptacle&gt; for Dispenser {
    type Error = Error;

    fn try_from(c: Receptacle) -&gt; Result&lt;Self, Self::Error&gt; {
        match c {
            Receptacle::Sized(s) =&gt; Ok(Dispenser::Sized(s)),
            Receptacle::Tunnel(t) =&gt; Ok(Dispenser::Tunnel(t)),
            i =&gt; Err(Error::expected("iterable", Item::Receptacle(i))),
        }
    }
}

impl TryFrom&lt;Item&gt; for Box&lt;dyn Iterator&lt;Item = Item&gt;&gt; {
    type Error = Error;

    fn try_from(item: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Sized::try_from(item)?.into_iter())
    }
}

impl From&lt;Sized&gt; for Box&lt;dyn Iterator&lt;Item = Item&gt;&gt; {
    fn from(sized: Sized) -&gt; Self {
        Box::new(sized.into_iter())
    }
}

impl From&lt;List&gt; for Sized {
    fn from(l: List) -&gt; Self {
        Sized::List(l)
    }
}

impl From&lt;Sized&gt; for Dispenser {
    fn from(s: Sized) -&gt; Self {
        Dispenser::Sized(s)
    }
}

impl From&lt;List&gt; for Item {
    fn from(l: List) -&gt; Self {
        Item::Dispenser(Dispenser::Sized(Sized::List(l)))
    }
}

impl From&lt;Dispenser&gt; for Item {
    fn from(c: Dispenser) -&gt; Self {
        Item::Dispenser(c)
    }
}

impl From&lt;Sized&gt; for Item {
    fn from(s: Sized) -&gt; Self {
        Dispenser::Sized(s).into()
    }
}

impl TryFrom&lt;Item&gt; for Dispenser {
    type Error = Error;

    fn try_from(item: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match item {
            Item::Dispenser(c) =&gt; Ok(c),
            Item::Receptacle(p) =&gt; Ok(Dispenser::try_from(p)?),
            i =&gt; Err(Error::expected("iterable", i)),
        }
    }
}

impl TryFrom&lt;Item&gt; for Set {
    type Error = Error;

    fn try_from(item: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = Sized::try_from(item)?;
        let hs: HashSet&lt;assoc::KeyItem&gt; = s
            .into_iter()
            .map(|i| i.try_into())
            .collect::&lt;Result&lt;HashSet&lt;assoc::KeyItem&gt;, Error&gt;&gt;()?;
        Ok(Set::from(hs))
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0939b8" class="outline-5">
<h5 id="orgb0939b8"><span class="section-number-5">1.4.2.3.</span> Associative types</h5>
<div class="outline-text-5" id="text-1-4-2-3">
<div class="org-src-container">
<pre class="src src-rust">use crate::types::collection as coll;
use crate::types::dictionary as dict;
use crate::types::environment as env;
use crate::types::*;
use std::iter::FromIterator;
use std::sync;
pub type Associationy&lt;K, V&gt; = Newtype&lt;HashMap&lt;K, V&gt;&gt;;
pub type AssociationContent = Associationy&lt;KeyItem, Item&gt;;
pub type Association = coll::Arc&lt;AssociationContent&gt;;

#[derive(Debug, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]
pub enum KeyItem {
    // Order matters here, for comparison purposes - changing the
    // order will change the result of how eg int compares to word.
    Nothing,
    Int(Int),
    Word(Word),
    Bytes(Bytes),
    String(String),
    List(KeyList),
}

impl KeyList {
    pub fn try_from_iter&lt;I&gt;(l: I) -&gt; Result&lt;Self, Error&gt;
    where
        I: IntoIterator&lt;Item = Item&gt;,
    {
        Ok(coll::Arc::wrap(Newtype(
            l.into_iter()
                .map(KeyItem::try_from)
                .collect::&lt;Result&lt;VecDeque&lt;KeyItem&gt;, Error&gt;&gt;()?,
        )))
    }
}

impl From&lt;KeyItem&gt; for Item {
    fn from(i: KeyItem) -&gt; Self {
        match i {
            KeyItem::Int(i) =&gt; Item::Int(i),
            KeyItem::String(i) =&gt; i.into(),
            KeyItem::List(mut l) =&gt; {
                coll::List::from_iter(l.inner().into_iter().map(Item::from)).into()
            }
            KeyItem::Word(w) =&gt; Item::Word(w),
            KeyItem::Bytes(bs) =&gt; bs.into(),
            KeyItem::Nothing =&gt; coll::NOTHING,
        }
    }
}

impl From&lt;&amp;str&gt; for KeyItem {
    fn from(i: &amp;str) -&gt; Self {
        KeyItem::Word(Word::from(i))
    }
}

impl From&lt;Word&gt; for KeyItem {
    fn from(i: Word) -&gt; Self {
        KeyItem::Word(i)
    }
}

impl TryFrom&lt;Item&gt; for KeyItem {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Error&gt; {
        match i {
            Item::Int(i) =&gt; Ok(KeyItem::Int(i)),
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(i))) =&gt; {
                Ok(KeyItem::String(i))
            }
            Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(i))) =&gt; {
                Ok(KeyItem::String(i))
            }
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(i))) =&gt; Ok(KeyItem::Bytes(i)),
            Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(i))) =&gt; {
                Ok(KeyItem::Bytes(i))
            }
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))) =&gt; Ok(KeyItem::List(
                KeyList::try_from_iter(l.inner().into_iter())?,
            )),

            Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Nothing)) =&gt; Ok(KeyItem::Nothing),
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Nothing)) =&gt; Ok(KeyItem::Nothing),

            Item::Word(w) =&gt; Ok(KeyItem::Word(w)),

            i =&gt; Err(Error::expected("KeyItem", i.into())),
        }
    }
}

impl TryFrom&lt;KeyItem&gt; for Word {
    type Error = Error;
    fn try_from(k: KeyItem) -&gt; Result&lt;Self, Self::Error&gt; {
        match k {
            KeyItem::Word(w) =&gt; Ok(w.clone()),
            i =&gt; Err(Error::expected("word", i.into())),
        }
    }
}

pub type Entry = (KeyItem, Item);

pub type KeyListContent = coll::Listy&lt;KeyItem&gt;;
pub type KeyList = coll::Arc&lt;KeyListContent&gt;;

#[derive(Debug, Clone)]
pub enum Associative {
    Assoc(Association),
    DictEntry(dict::Entry),
    Env(env::Environment),
    Error(Error),
    Dictionary(dict::Dictionary),
    Nothing,
}

impl PartialEq for Associative {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (Associative::Assoc(a), Associative::Assoc(b)) =&gt; a == b,
            (Associative::DictEntry(a), Associative::DictEntry(b)) =&gt; a == b,
            (Associative::Env(a), Associative::Env(b)) =&gt; a == b,
            (Associative::Error(a), Associative::Error(b)) =&gt; a == b,
            (Associative::Dictionary(a), Associative::Dictionary(b)) =&gt; a == b,
            (Associative::Nothing, Associative::Nothing) =&gt; true,
            //(Associative::Assoc(a), b) =&gt; Association::from(a) == Association::from(b),
            //(a, Associative::Assoc(b)) =&gt; Association::from(a) == Association::from(b),
            _ =&gt; false,
        }
    }
}

impl Associative {
    pub fn len(&amp;self) -&gt; usize {
        match self {
            Associative::Assoc(a) =&gt; a.len(),
            Associative::DictEntry(a) =&gt; a.len(),
            Associative::Env(e) =&gt; e.len(),
            Associative::Error(e) =&gt; e.len(),
            Associative::Dictionary(d) =&gt; d.len(),
            Associative::Nothing =&gt; 0,
        }
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }

    pub fn insert(self, k: KeyItem, v: Item) -&gt; (Associative, Option&lt;Item&gt;) {
        match self {
            Associative::Assoc(mut a) =&gt; {
                let am = coll::Arc::make_mut(&amp;mut a);
                let e = am.insert(k, v);
                (Associative::Assoc(a), e)
            }
            Associative::Dictionary(mut d) =&gt; match (k, v) {
                (KeyItem::Word(w), e) =&gt; {
                    let e2 = e.clone();
                    if let Ok(e) = dict::Entry::try_from(e) {
                        let dm = coll::Arc::make_mut(&amp;mut d);
                        let e = dm.insert(w, e).and_then(|e| Some(Item::from(e)));
                        (Associative::Dictionary(d), e)
                    } else {
                        // TODO silently failing to insert here is bad
                        println!("Warning, failed to insert into dictionary: {:?}", e2);
                        (Associative::Dictionary(d), None)
                    }
                }
                _ =&gt; (Associative::Dictionary(d), None),
            },
            Associative::Env(e) =&gt; e.insert(k, v),
            _ =&gt; todo!("insert Implementations for error, env etc"),
        }
    }

    pub fn put(self, other: Item) -&gt; Result&lt;Associative, Error&gt; {
        let entry: (KeyItem, Item) = other.try_into()?;
        Ok(self.insert(entry.0, entry.1).0)
    }

    pub fn join(self, other: Associative) -&gt; Associative {
        match (self, other) {
            // same type means 2nd one wins.
            //TODO: a little more complex for types that can be extended
            (Associative::DictEntry(_), Associative::DictEntry(other)) =&gt; {
                Associative::DictEntry(other)
            }
            (Associative::Dictionary(mut this), Associative::Dictionary(mut other)) =&gt; {
                let thism = coll::Arc::make_mut(&amp;mut this);
                thism.extend(other.inner().into_iter());
                Associative::Dictionary(this)
            }
            (Associative::Error(_), Associative::Error(other)) =&gt; Associative::Error(other),
            (Associative::Env(_), Associative::Env(other)) =&gt; Associative::Env(other),
            (Associative::Nothing, Associative::Nothing) =&gt; Associative::Nothing,
            (Associative::Assoc(mut this), other) =&gt; {
                let thism = coll::Arc::make_mut(&amp;mut this);
                thism.extend(other.into_iter());
                Associative::Assoc(this)
            }
            (this, other) =&gt; {
                let thisa: Association = this.into();
                (Associative::Assoc(thisa)).join(other)
            }
        }
    }

    pub fn get(&amp;self, k: &amp;KeyItem) -&gt; Option&lt;Item&gt; {
        match self {
            Associative::Assoc(a) =&gt; a.get(k).and_then(|x| Some(x.clone())),
            Associative::Error(e) =&gt; e.data.get(k).and_then(|x| Some(x.clone())),
            Associative::Env(e) =&gt; match k {
                KeyItem::Word(s) =&gt; e.get(s.as_str()),
                _ =&gt; None,
            },
            Associative::DictEntry(d) =&gt; match k {
                KeyItem::Word(s) =&gt; d.get(s.as_str()),
                _ =&gt; None,
            },
            Associative::Dictionary(d) =&gt; match k {
                KeyItem::Word(w) =&gt; d.get(w).and_then(|x| Some(x.clone().into())),
                _ =&gt; None,
            },
            &amp;Associative::Nothing =&gt; None,
        }
    }

    pub fn contains_key(&amp;self, k: &amp;KeyItem) -&gt; bool {
        match self {
            Associative::Assoc(a) =&gt; a.contains_key(k),
            Associative::Error(e) =&gt; e.data.contains_key(k),
            Associative::Env(e) =&gt; e.contains_key(k),
            Associative::DictEntry(d) =&gt; d.contains_key(k),
            Associative::Dictionary(d) =&gt; match k {
                KeyItem::Word(w) =&gt; d.contains_key(w),
                _ =&gt; false,
            },
            &amp;Associative::Nothing =&gt; false,
        }
    }

    //TODO remove
    pub fn remove(self, k: &amp;KeyItem) -&gt; (Associative, Option&lt;Item&gt;) {
        match self {
            Associative::Assoc(mut a) =&gt; {
                let am = coll::Arc::make_mut(&amp;mut a);
                let v = am.remove(k);
                (Associative::Assoc(a), v)
            }
            Associative::Dictionary(mut d) =&gt; {
                let dm = coll::Arc::make_mut(&amp;mut d);
                let v = dm.remove(&amp;Word::try_from(k.clone()).unwrap_or_default());
                (Associative::Dictionary(d), v.map(|v| v.into()))
            }
            _ =&gt; todo!("Removing from other associative types"),
        }
    }

    pub fn take(self) -&gt; (coll::Dispenser, Option&lt;Item&gt;) {
        match self {
            Associative::Assoc(mut a) =&gt; {
                let maybe_key = a.inner().keys().next().cloned();
                let am = a.make_mut();
                let maybe_value = maybe_key.as_ref().and_then(|key| am.remove(&amp;key));
                (
                    coll::Dispenser::Sized(coll::Sized::Associative(Associative::Assoc(a))),
                    maybe_key.map(|key| {
                        coll::List::from_iter(
                            vec![Item::from(key), Item::from(maybe_value.unwrap_or_default())]
                                .into_iter(),
                        )
                        .into()
                    }),
                )
            }
            Associative::Dictionary(mut d) =&gt; {
                let maybe_key = d.inner().keys().next().cloned();
                let dm = d.make_mut();
                let maybe_value = maybe_key.and_then(|key| dm.remove(&amp;key));
                (
                    coll::Dispenser::Sized(coll::Sized::Associative(Associative::Dictionary(d))),
                    maybe_key.map(|key| {
                        coll::List::from_iter(
                            vec![
                                Item::Word(key),
                                maybe_value.map(Item::from).unwrap_or(coll::NOTHING),
                            ]
                            .into_iter(),
                        )
                        .into()
                    }),
                )
            }
            _ =&gt; unimplemented!(),
        }
    }
}

impl IntoIterator for Associative {
    type Item = Entry;
    type IntoIter = Box&lt;dyn Iterator&lt;Item = Entry&gt;&gt;;

    fn into_iter&lt;'a&gt;(self) -&gt; Self::IntoIter {
        match self {
            Associative::Assoc(mut a) =&gt; Box::new(a.inner().into_iter()),
            Associative::DictEntry(e) =&gt; Box::new(e.into_iter()),
            Associative::Dictionary(mut d) =&gt; {
                Box::new(d.inner().into_iter().map(|(k, v)| (k.into(), v.into())))
            }
            Associative::Error(e) =&gt; e.into_iter(),
            Associative::Env(e) =&gt; e.into_iter(),
            Associative::Nothing =&gt; Box::new(std::iter::empty()),
        }
    }
}

impl From&lt;Associative&gt; for coll::List {
    fn from(a: Associative) -&gt; Self {
        coll::List::from_iter(a.into_iter())
    }
}

impl TryFrom&lt;Item&gt; for Associative {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Error&gt; {
        let s = coll::Sized::try_from(i)?;
        match s {
            coll::Sized::Associative(a) =&gt; Ok(a),
            coll::Sized::String(i) =&gt; Err(Error::expected("associative", i.into())),
            coll::Sized::Bytes(i) =&gt; Err(Error::expected("associative", i.into())),
            s =&gt; Ok(Associative::Assoc(Association::try_from_iter(s)?)),
        }
    }
}

// Convert anything that can be iterated over as Items, to an
// Association. The items must be pairs that are
// convertable to Entry, otherwise it will return an error.
impl Association {
    pub fn new() -&gt; Association {
        coll::Arc::wrap(Newtype(HashMap::new()))
    }

    pub fn try_from_iter&lt;I&gt;(l: I) -&gt; Result&lt;Self, Error&gt;
    where
        I: IntoIterator&lt;Item = Item&gt;,
    {
        Ok(coll::Arc::wrap(Newtype(
            l.into_iter()
                .map(|i| Entry::try_from(i.clone()))
                .collect::&lt;Result&lt;HashMap&lt;KeyItem, Item&gt;, Error&gt;&gt;()?,
        )))
    }
}

impl FromIterator&lt;Entry&gt; for Association {
    fn from_iter&lt;I&gt;(iter: I) -&gt; Self
    where
        I: IntoIterator&lt;Item = Entry&gt;,
    {
        coll::Arc::wrap(Newtype(
            iter.into_iter().collect::&lt;HashMap&lt;KeyItem, Item&gt;&gt;(),
        ))
    }
}

impl FromIterator&lt;Entry&gt; for coll::List {
    fn from_iter&lt;I&gt;(iter: I) -&gt; Self
    where
        I: IntoIterator&lt;Item = Entry&gt;,
    {
        coll::Arc::wrap(Newtype(
            iter.into_iter()
                .map(|e| e.into())
                .collect::&lt;VecDeque&lt;Item&gt;&gt;(),
        ))
    }
}

impl FromIterator&lt;KeyItem&gt; for KeyList {
    fn from_iter&lt;I&gt;(iter: I) -&gt; Self
    where
        I: IntoIterator&lt;Item = KeyItem&gt;,
    {
        Newtype(sync::Arc::new(Newtype(
            iter.into_iter().collect::&lt;VecDeque&lt;KeyItem&gt;&gt;(),
        )))
    }
}

impl From&lt;Entry&gt; for Item {
    fn from(e: Entry) -&gt; Item {
        coll::List::from_iter([Item::from(e.0), e.1]).into()
    }
}

impl TryFrom&lt;Item&gt; for Entry {
    type Error = Error;

    fn try_from(i: Item) -&gt; Result&lt;Self, Error&gt; {
        let s = coll::Sized::try_from(i)?;
        if s.len() != 2 {
            Err(Error::expected("pair", s.into()))
        } else {
            let mut iter = s.into_iter();
            let key: KeyItem = iter.next().unwrap().try_into()?;
            let value = iter.next().unwrap();
            Ok((key, value))
        }
    }
}

impl From&lt;Associative&gt; for Association {
    fn from(a: Associative) -&gt; Association {
        match a {
            Associative::Assoc(a) =&gt; a,
            a =&gt; a.into_iter().collect::&lt;Association&gt;(),
        }
    }
}

impl From&lt;AssociationContent&gt; for Item {
    fn from(a: AssociationContent) -&gt; Item {
        coll::Arc::wrap(a).into()
    }
}

impl From&lt;Association&gt; for Item {
    fn from(a: Association) -&gt; Item {
        Associative::Assoc(a).into()
    }
}

impl From&lt;Associative&gt; for Item {
    fn from(a: Associative) -&gt; Item {
        coll::Sized::Associative(a).into()
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgacb5d33" class="outline-5">
<h5 id="orgacb5d33"><span class="section-number-5">1.4.2.4.</span> Error types</h5>
<div class="outline-text-5" id="text-1-4-2-4">
<div class="org-src-container">
<pre class="src src-rust">use crate::types;
use crate::types::associative as assoc;
use crate::types::collection as coll;
use crate::types::{Int, Item, Word};

#[derive(Clone, PartialEq)]
pub struct Error {
    pub data: assoc::Association,
    pub is_handled: bool,
}

impl Error {
    pub fn create(asked: coll::List, reason: &amp;str, actual: Option&lt;Item&gt;) -&gt; Error {
        // let bt = backtrace::Backtrace::new();
        let mut data: Vec&lt;(assoc::KeyItem, Item)&gt; = vec![
            ("type".into(), "error".into()),
            ("asked".into(), asked.into()),
            ("reason".into(), reason.to_string().into()),
            //("backtrace".into(), Item::String(format!("{:?}", bt))),
        ];
        if let Some(actual) = actual {
            data.push(("actual".into(), actual));
        }
        Error {
            is_handled: false,

            data: assoc::Association::from_iter(data),
        }
    }

    pub fn stack_underflow() -&gt; Error {
        Error::create(
            types::wrap("consume".into()),
            "not enough items on stack",
            None,
        )
    }

    pub fn undefined(w: Word) -&gt; Error {
        Error::create(types::wrap(Item::Word(w)), "word is not defined", None)
    }

    pub fn type_mismatch(asked: coll::List, actual: Option&lt;Item&gt;) -&gt; Error {
        Error::create(asked, "type mismatch", actual)
    }

    pub fn division_by_zero() -&gt; Error {
        Error::create(types::wrap("/".into()), "division by zero", None)
    }

    pub fn expected(typestr: &amp;str, actual: Item) -&gt; Error {
        Error::type_mismatch(types::wrap(typestr.into()), Some(actual))
    }

    pub fn short_list(expected: Int) -&gt; Error {
        Error::create(
            coll::List::from_iter(["count".into(), Item::Int(expected), "&gt;=".into()]),
            "list had too few items",
            None,
        )
    }

    pub fn list_count(expected: Int) -&gt; Error {
        Error::create(
            coll::List::from_iter(["count".into(), Item::Int(expected), "=".into()]),
            "list had wrong number of items",
            None,
        )
    }

    pub fn parse(reason: &amp;str) -&gt; Error {
        Error::create(types::wrap("read".into()), reason, None)
    }

    pub fn test_assertion(program: coll::List, expected: coll::List, actual: coll::List) -&gt; Error {
        let mut e = Error::create(program, "assertion failed", Some(actual.into()));
        let d = e.data.make_mut();
        d.insert("expected".into(), expected.into());
        return e;
    }

    pub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }
}

impl From&lt;Error&gt; for assoc::Association {
    fn from(e: Error) -&gt; assoc::Association {
        e.data
    }
}

impl TryFrom&lt;Item&gt; for Error {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        match i {
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                assoc::Associative::Error(e),
            ))) =&gt; Ok(e),
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
            | Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_))) =&gt; {
                Err(Error::expected("error", Default::default()))
            }
            Item::Dispenser(coll::Dispenser::Sized(c)) =&gt; c.into_iter().try_into(),
            i =&gt; Err(Error::expected("error", i)),
        }
    }
}

impl TryFrom&lt;Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;&gt; for Error {
    type Error = Error;
    fn try_from(i: Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        //TODO: this can't fail, can just be a From.
        // Really though, Error should have predefined fields like Environment.
        let data = assoc::Association::try_from_iter(i)?;
        Ok(Error {
            data,
            is_handled: false,
        })
    }
}

impl TryFrom&lt;assoc::Associative&gt; for Error {
    type Error = Error;
    fn try_from(a: assoc::Associative) -&gt; Result&lt;Self, Self::Error&gt; {
        match a {
            assoc::Associative::Error(e) =&gt; Ok(e),
            assoc::Associative::Assoc(a) =&gt; {
                if a.get(&amp;assoc::KeyItem::from("type")) != Some(&amp;Item::from("error")) {
                    Err(Error::expected("error", a.into()))
                } else {
                    Ok(Error {
                        data: a.clone(),
                        is_handled: true,
                    })
                }
            }
            i =&gt; Err(Error::expected("error", i.into())),
        }
    }
}

impl From&lt;Error&gt; for Item {
    fn from(e: Error) -&gt; Item {
        assoc::Associative::Error(e).into()
    }
}

impl IntoIterator for Error {
    type Item = assoc::Entry;
    type IntoIter = Box&lt;dyn Iterator&lt;Item = assoc::Entry&gt;&gt;;

    fn into_iter(mut self) -&gt; Self::IntoIter {
        Box::new(
            self.data
                .inner()
                .into_iter()
                .chain(std::iter::once(("handled".into(), self.is_handled.into()))),
        )
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7973589" class="outline-5">
<h5 id="org7973589"><span class="section-number-5">1.4.2.5.</span> Dictionary types</h5>
<div class="outline-text-5" id="text-1-4-2-5">
<div class="org-src-container">
<pre class="src src-rust">use crate::types::associative as assoc;
use crate::types::collection as coll;
use crate::types::*;

#[derive(Debug, Clone)]
pub struct Entry {
    pub examples: Option&lt;coll::List&gt;,
    pub spec: Option&lt;coll::List&gt;,
    pub definition: Definition,
}

impl Entry {
    pub fn len(&amp;self) -&gt; usize {
        3 // 3 fields
    }

    pub fn get(&amp;self, key: &amp;str) -&gt; Option&lt;Item&gt; {
        match key {
            "spec" =&gt; self.spec.clone().and_then(|x| Some(x.into())),
            "examples" =&gt; self.examples.clone().and_then(|x| Some(x.into())),
            "definition" =&gt; Some(match self.definition.clone() {
                dict::Definition::Axiom(_) =&gt; "builtin".into(),
                dict::Definition::Derived(d) =&gt; d.into(),
            }),
            _ =&gt; None,
        }
    }

    pub fn contains_key(&amp;self, key: &amp;assoc::KeyItem) -&gt; bool {
        Word::try_from(key.clone()).map_or(false, |w| match w.as_str() {
            "examples" =&gt; true,
            "spec" =&gt; true,
            "definition" =&gt; true,
            _ =&gt; false,
        })
    }
}

pub type Dictionary = coll::Arc&lt;HashMap&lt;Word, Entry&gt;&gt;;

#[derive(Clone)]
pub enum Definition {
    Axiom(&amp;'static StepFn),
    Derived(coll::List),
}

impl PartialEq for Definition {
    fn eq(&amp;self, _: &amp;Self) -&gt; bool {
        // TODO actually implement this
        true
    }
}

// dictionary entries are equal if they have the same function reference,
// no need to compare the function values
impl PartialEq for Entry {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.definition == other.definition
            &amp;&amp; self.examples == other.examples
            &amp;&amp; self.spec == other.spec
    }
}

impl fmt::Debug for Definition {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Definition::Axiom(_) =&gt; f.write_str("Builtin"),
            Definition::Derived(d) =&gt; {
                let mut ds = f.debug_list();
                ds.entries(d.iter());
                ds.finish()
            }
        }
    }
}

impl IntoIterator for Entry {
    type Item = assoc::Entry;
    type IntoIter = Box&lt;dyn Iterator&lt;Item = assoc::Entry&gt;&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        let mut v: Vec&lt;(assoc::KeyItem, Item)&gt; = vec![("definition".into(), {
            match self.definition {
                dict::Definition::Derived(l) =&gt; l.into(),
                dict::Definition::Axiom(_) =&gt; "builtin-function".into(),
            }
        })];
        if let Some(e) = self.examples {
            v.push(("examples".into(), e.into()));
        }
        if let Some(s) = self.spec {
            v.push(("spec".into(), s.into()))
        }
        Box::new(v.into_iter().map(|kv| kv.into()))
    }
}

impl TryFrom&lt;Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;&gt; for Entry {
    type Error = Error;
    fn try_from(iter: Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;) -&gt; Result&lt;Self, Error&gt; {
        let mut examples: Option&lt;coll::List&gt; = None;
        let mut definition: Option&lt;Definition&gt; = None;
        let mut spec: Option&lt;coll::List&gt; = None;
        for i in iter {
            let (k, v): (assoc::KeyItem, Item) = i.try_into()?;
            //println!("k: {:?}, v: {:?}", k, v);
            if k == "examples".into() {
                examples = Some(v.try_into()?);
            } else if k == "definition".into() {
                definition = Some(v.try_into()?);
            } else if k == "spec".into() {
                spec = Some(v.try_into()?);
            } else {
                continue;
            }
        }
        Ok(Entry {
            examples,
            definition: definition.unwrap_or(Definition::Derived(coll::List::new())),
            spec,
        })
    }
}

impl TryFrom&lt;Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;&gt; for Dictionary {
    type Error = Error;

    fn try_from(iter: Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;) -&gt; Result&lt;Self, Error&gt; {
        iter.map(|kv| &lt;(Word, Entry)&gt;::try_from(kv))
            .collect::&lt;Result&lt;HashMap&lt;Word, Entry&gt;, Error&gt;&gt;()
            .map(coll::Arc::wrap)
    }
}

impl TryFrom&lt;Item&gt; for Definition {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        coll::List::try_from(i).and_then(|l| Ok(Definition::Derived(l)))
    }
}

impl TryFrom&lt;Item&gt; for Entry {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;
        match s {
            coll::Sized::Associative(assoc::Associative::DictEntry(d)) =&gt; Ok(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

impl From&lt;Entry&gt; for assoc::Associative {
    fn from(d: Entry) -&gt; assoc::Associative {
        let mut assoc = assoc::Association::new();
        let a = assoc.make_mut();
        d.examples
            .and_then(|l| a.insert("examples".into(), l.into()));
        d.spec.and_then(|l| a.insert("spec".into(), l.into()));
        match d.definition {
            Definition::Derived(d) =&gt; {
                a.insert("definition".into(), d.into());
            }
            _ =&gt; {}
        }
        assoc::Associative::Assoc(assoc)
    }
}

// impl TryFrom&lt;Associative&gt; for Entry {
//     type Error = Error;
//     fn try_from(d: Associative) -&gt; Result&lt;Self, Error&gt; {
//         // TODO: This should handle cases where there's no def present
//         // and return error
//         let (d, def) = d.remove(&amp;"definition".into());
//         let (d, examples) = d.remove(&amp;"examples".into());
//         let (_, spec) = d.remove(&amp;"spec".into());

//         Ok(Entry {
//             definition: if let Some(d) = def {
//                 Definition::Derived(List::try_from(d).unwrap())
//             } else {
//                 //Err(Error::expected("definition field"))?  use a
//                 // dummy value, presumably if this is during
//                 // bootstrap,the definition will be replaced later.
//                 Definition::Derived(Arc::new(ListContent::new()))
//             },

//             // {Box::leak(Box::new(move |env: Environment| {
//             //    env.push(Item::Error(Error::undefined(w)))
//             //}))}
//             examples: examples.and_then(|i| List::try_from(i).ok()),
//             spec: spec.and_then(|i| List::try_from(i).ok()),
//         })
//     }
// }

// impl TryFrom&lt;List&gt; for Entry {
//     type Error = Error;
//     fn try_from(l: List) -&gt; Result&lt;Self, Error&gt; {
//         let a: Associative = l.try_into()?;
//         a.try_into()
//     }
// }

// impl TryFrom&lt;assoc::Associative&gt; for Dictionary {
//     type Error = Error;
//     fn try_from(a: assoc::Associative) -&gt; Result&lt;Self, Self::Error&gt; {
//         match a {
//             assoc::Associative::Dictionary(e) =&gt; Ok(e),
//             assoc::Associative::Assoc(a) =&gt; {
//                 let h = rc_inner(&amp;a)
//                     .into_iter()
//                     .map(|(k, v)| {
//                         let e: (Word, Entry) = (k.try_into()?, v.try_into()?);
//                         Ok(e)
//                     })
//                     .collect::&lt;Result&lt;HashMap&lt;Word, Entry&gt;, Error&gt;&gt;()?;
//                 Ok(Arc::new(h))
//             }
//             _ =&gt; Err(Error::expected("dictionary")),
//         }
//     }
// }

// impl From&lt;Dictionary&gt; for assoc::Associative {
//     fn from(d: Dictionary) -&gt; Self {
//         Associative::Assoc(Arc::new(
//             rc_inner(&amp;d)
//                 .into_iter()
//                 .map(|(k, v)| (assoc::KeyItem::Word(k), Item::Entry(v)))
//                 .collect(),
//         ))
//     }
// }

impl TryFrom&lt;Item&gt; for Dictionary {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;
        match s {
            coll::Sized::Associative(assoc::Associative::Dictionary(d)) =&gt; Ok(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

impl From&lt;Entry&gt; for Item {
    fn from(e: Entry) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::DictEntry(e),
        )))
    }
}

impl From&lt;Dictionary&gt; for Item {
    fn from(d: Dictionary) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Dictionary(d),
        )))
    }
}

impl From&lt;(Word, Entry)&gt; for Item {
    fn from((k, v): (Word, Entry)) -&gt; Item {
        coll::List::from_iter([Item::Word(k.clone()), Item::from(v.clone())]).into()
    }
}

impl TryFrom&lt;Item&gt; for (Word, Entry) {
    type Error = Error;

    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;
        if s.len() != 2 {
            Err(Error::expected("pair", s.into()))
        } else {
            let mut iter = s.into_iter();
            let key: Word = iter.next().unwrap().try_into()?;
            let value: Entry = iter.next().unwrap().try_into()?;
            Ok((key, value))
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb3b1e5c" class="outline-5">
<h5 id="orgb3b1e5c"><span class="section-number-5">1.4.2.6.</span> Environment types</h5>
<div class="outline-text-5" id="text-1-4-2-6">
<div class="org-src-container">
<pre class="src src-rust">use crate::axiom;
use crate::serialize;
use crate::types::*;
use crate::types::{associative as assoc, collection as coll, dictionary as dict};
use std::future;

#[derive(Clone, PartialEq)]
pub struct Environment {
    pub stack: Stack,
    pub expression: Stack,
    pub dictionary: dict::Dictionary,
}

impl Environment {
    pub fn push(mut self, i: Item) -&gt; Environment {
        coll::Arc::make_mut(&amp;mut self.stack).push_front(i);
        self
    }

    pub fn pop(&amp;mut self) -&gt; Item {
        coll::Arc::make_mut(&amp;mut self.stack).pop_front().unwrap()
    }

    pub fn push_expr(mut self, i: Item) -&gt; Environment {
        coll::Arc::make_mut(&amp;mut self.expression).push_front(i);
        self
    }

    pub fn pop_expr(&amp;mut self) -&gt; Item {
        coll::Arc::make_mut(&amp;mut self.expression)
            .pop_front()
            .unwrap()
    }

    pub fn append_expression(mut self, mut items: coll::List) -&gt; Environment {
        let expr = self.expression.make_mut();
        let ct = expr.len();
        expr.append(items.make_mut());
        expr.rotate_left(ct);
        self
    }

    pub fn tos&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;&amp;'a Item&gt; {
        self.stack.front()
    }

    pub fn len(&amp;self) -&gt; usize {
        3 // 3 fields
    }

    pub fn get(&amp;self, key: &amp;str) -&gt; Option&lt;Item&gt; {
        match key {
            "stack" =&gt; Some(self.stack.clone().into()),
            "expression" =&gt; Some(self.expression.clone().into()),
            "dictionary" =&gt; Some(self.dictionary.clone().into()),
            _ =&gt; None,
        }
    }

    pub fn contains_key(&amp;self, key: &amp;assoc::KeyItem) -&gt; bool {
        Word::try_from(key.clone()).map_or(false, |w| match w.as_str() {
            "stack" =&gt; true,
            "expression" =&gt; true,
            "dictionary" =&gt; true,
            _ =&gt; false,
        })
    }

    pub fn insert(mut self, k: assoc::KeyItem, v: Item) -&gt; (assoc::Associative, Option&lt;Item&gt;) {
        match k {
            assoc::KeyItem::Word(w) =&gt; match w.as_str() {
                "stack" =&gt; {
                    let l = coll::List::try_from(v.clone());
                    match l {
                        Ok(l) =&gt; {
                            let old = self.stack.clone();
                            self.stack = l;
                            (assoc::Associative::Env(self), Some(old.into()))
                        }
                        Err(_) =&gt; {
                            let mut a = assoc::Association::from_iter(self);
                            let old = a.inner().insert(k, v);
                            (assoc::Associative::Assoc(a), old)
                        }
                    }
                }
                "expression" =&gt; {
                    let l = coll::List::try_from(v.clone());
                    match l {
                        Ok(l) =&gt; {
                            let old = self.expression.clone();
                            self.expression = l;
                            (assoc::Associative::Env(self), Some(old.into()))
                        }
                        Err(_) =&gt; {
                            let mut a = assoc::Association::from_iter(self);
                            let old = a.inner().insert(k, v);
                            (assoc::Associative::Assoc(a), old)
                        }
                    }
                }
                "dictionary" =&gt; {
                    let d = dict::Dictionary::try_from(v.clone());
                    match d {
                        Ok(d) =&gt; {
                            let old = self.dictionary.clone();
                            self.dictionary = d;
                            (assoc::Associative::Env(self), Some(old.into()))
                        }
                        Err(_) =&gt; {
                            let mut a = assoc::Association::from_iter(self);
                            let old = a.inner().insert(k, v);
                            (assoc::Associative::Assoc(a), old)
                        }
                    }
                }
                k =&gt; {
                    let mut a = assoc::Association::from_iter(self);
                    let old = a.inner().insert(k.into(), v);
                    (assoc::Associative::Assoc(a), old)
                }
            },
            _ =&gt; {
                let mut a = assoc::Association::from_iter(self);
                let old = a.inner().insert(k, v);
                (assoc::Associative::Assoc(a), old)
            }
        }
    }
}

impl TryFrom&lt;Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;&gt; for Environment {
    type Error = Error;
    fn try_from(iter: Box&lt;dyn Iterator&lt;Item = Item&gt;&gt;) -&gt; Result&lt;Self, Error&gt; {
        let mut stack: Option&lt;coll::List&gt; = None;
        let mut expression: Option&lt;coll::List&gt; = None;
        let mut dictionary: Option&lt;dict::Dictionary&gt; = None;
        for i in iter {
            let (k, v): (assoc::KeyItem, Item) = i.try_into()?;
            if k == "stack".into() {
                stack = Some(v.try_into()?)
            } else if k == "expression".into() {
                expression = Some(v.try_into()?)
            } else if k == "dictionary".into() {
                dictionary = Some(v.try_into()?)
            } else {
                continue;
            }
        }
        let mut env = axiom::standard_env(expression, stack);
        if let Some(mut d) = dictionary {
            let edmut = env.dictionary.make_mut();
            edmut.extend(d.inner().into_iter());
        }
        Ok(env)
    }
}
impl TryFrom&lt;Item&gt; for Environment {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let s = coll::Sized::try_from(i)?;

        match s {
            coll::Sized::Associative(assoc::Associative::Env(e)) =&gt; Ok(e),
            l =&gt; l.into_iter().try_into(),
        }
    }
}

impl From&lt;Environment&gt; for Item {
    fn from(env: Environment) -&gt; Item {
        assoc::Associative::Env(env).into()
    }
}

impl From&lt;Environment&gt; for Future&lt;Environment&gt; {
    fn from(env: Environment) -&gt; Future&lt;Environment&gt; {
        Box::pin(future::ready(env))
    }
}

impl IntoIterator for Environment {
    type Item = assoc::Entry;
    type IntoIter = Box&lt;dyn Iterator&lt;Item = assoc::Entry&gt;&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        let v: Vec&lt;(assoc::KeyItem, Item)&gt; = vec![
            ("stack".into(), self.stack.into()),
            ("expression".into(), self.expression.into()),
            ("dictionary".into(), self.dictionary.into()),
        ];
        Box::new(v.into_iter().map(|kv| kv.into()))
    }
}

impl serialize::Display for Environment {
    fn representation(&amp;self) -&gt; Item {
        let mut assoc = assoc::Association::from_iter(self.clone());
        let am = assoc.make_mut();
        am.remove(&amp;("dictionary".into()));
        assoc.into()
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2cc4d2f" class="outline-5">
<h5 id="org2cc4d2f"><span class="section-number-5">1.4.2.7.</span> Cryptographic primitives</h5>
<div class="outline-text-5" id="text-1-4-2-7">
<p>
We'll implement certain cryptography functions in rust and make kcats
words for them (hashing, encryption, signing)
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::axiom::ItemResult;
use crate::types::{associative as assoc, error::Error, Bytes, Item};
use core::ops::Deref;
use ed25519_dalek as signing;
use ed25519_dalek::{Signer, Verifier};
use rand_core;
use rand_core::{CryptoRng, RngCore};
use sha2::{self, Digest};

pub fn hash(i: Item) -&gt; ItemResult {
    let b = Bytes::try_from(i).unwrap();
    Ok(sha2::Sha256::digest(b).deref().to_vec().into())
}

type Value = Vec&lt;u8&gt;;

pub struct SeededRNG {
    seed: Value,
    salt: Value,
}

impl SeededRNG {
    // Hash of seed|value
    fn hash(&amp;self) -&gt; Vec&lt;u8&gt; {
        let mut v = self.seed.clone();
        v.extend(self.salt.clone());
        sha2::Sha256::digest(v.as_slice()).deref().to_vec()
    }
}

impl RngCore for SeededRNG {
    fn next_u32(&amp;mut self) -&gt; u32 {
        rand_core::impls::next_u32_via_fill(self)
    }

    fn next_u64(&amp;mut self) -&gt; u64 {
        rand_core::impls::next_u64_via_fill(self)
    }

    fn fill_bytes(&amp;mut self, dest: &amp;mut [u8]) {
        let l = dest.len();
        dest.copy_from_slice(&amp;self.hash()[..l]);
    }

    fn try_fill_bytes(&amp;mut self, dest: &amp;mut [u8]) -&gt; Result&lt;(), rand_core::Error&gt; {
        self.fill_bytes(dest);
        Ok(())
    }
}

impl CryptoRng for SeededRNG {}

pub fn key(seed: Item) -&gt; ItemResult {
    let sbs: Bytes = seed.try_into()?;
    let kp = signing::Keypair::generate(&amp;mut SeededRNG {
        seed: vec![],
        salt: sbs,
    });
    Ok(assoc::Association::from_iter([
        ("type".into(), "elliptic-curve-key".into()),
        ("secret".into(), kp.secret.as_ref().to_vec().into()),
        ("public".into(), kp.public.as_ref().to_vec().into()),
    ])
    .into())
}

impl TryFrom&lt;Item&gt; for signing::Keypair {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let sk: signing::SecretKey = i.try_into()?;
        let pk: signing::PublicKey = (&amp;sk).into();
        Ok(signing::Keypair {
            secret: sk,
            public: pk,
        })
    }
}

impl TryFrom&lt;Item&gt; for signing::SecretKey {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let a = assoc::Associative::try_from(i)?;
        if a.get(&amp;"type".into()) == Some("elliptic-curve-key".into()) {
            let sk = signing::SecretKey::from_bytes(
                &amp;Bytes::try_from(
                    a.get(&amp;"secret".into())
                        .ok_or_else(|| Error::expected("secret", Default::default()))?,
                )?[..],
            )
            .map_err(|_e| Error::expected("valid-secret-key", Default::default()))?;
            Ok(sk)
        } else {
            Err(Error::expected("keypair", a.clone().into()))
        }
    }
}

impl TryFrom&lt;Item&gt; for signing::PublicKey {
    type Error = Error;
    fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {
        let a = assoc::Associative::try_from(i)?;
        if a.get(&amp;"type".into()) == Some("elliptic-curve-key".into()) {
            let pk = signing::PublicKey::from_bytes(
                &amp;Bytes::try_from(
                    a.get(&amp;"public".into())
                        .ok_or_else(|| Error::expected("public", Default::default()))?,
                )?[..],
            )
            .map_err(|_e| Error::expected("valid-public-key", Default::default()))?;
            Ok(pk)
        } else {
            Err(Error::expected("public-key", a.clone().into()))
        }
    }
}
//TODO: we can only call sign from a keypair, so we may want to assume
// that we have either the kp, or just the secret key.
pub fn sign(k: Item, m: Item) -&gt; ItemResult {
    let kp: signing::Keypair = k.try_into()?;
    let message: Bytes = m.try_into()?;
    let signature: signing::Signature = kp.sign(&amp;message);
    Ok(signature.as_ref().to_vec().into())
}

pub fn verify(k: Item, m: Item, s: Item) -&gt; ItemResult {
    let pk: signing::PublicKey = k.try_into()?;
    let mbs: Bytes = m.try_into()?;
    let sbs: Bytes = s.try_into()?;
    let sig = signing::Signature::from_bytes(&amp;sbs)
        .map_err(|_e| Error::expected("signature", Default::default()))?;
    Ok(pk
        .verify(&amp;mbs, &amp;sig)
        .map(|_| Item::from(true))
        .unwrap_or_default())
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfcc4fe7" class="outline-4">
<h4 id="orgfcc4fe7"><span class="section-number-4">1.4.3.</span> Serialization</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
We'll define how kcats data structure are parsed and written (for
example, in order to read/write to/from disk).
</p>
<div class="org-src-container">
<pre class="src src-rust">extern crate edn_format;
use crate::types::environment::Environment;
use crate::types::{associative as assoc, collection as coll, error::Error, *};
use base64;
use std::collections::VecDeque;
use std::fmt;

pub trait Display {
    fn representation(&amp;self) -&gt; Item;
}

const BYTE_TAG: &amp;str = "b64";

fn to_item(item: &amp;edn_format::Value) -&gt; Result&lt;Item, Error&gt; {
    //println!("to item {:?}", item);
    match item {
        edn_format::Value::Integer(i) =&gt; Ok(Item::Int(*i)),
        edn_format::Value::Vector(v) =&gt; Ok({
            if v.is_empty() {
                coll::NOTHING
            } else {
                coll::List::from_iter(
                    v.iter()
                        .map(|i| to_item(i))
                        .collect::&lt;Result&lt;Vec&lt;Item&gt;, Error&gt;&gt;()?,
                )
                .into()
            }
        }),
        edn_format::Value::Symbol(s) =&gt; Ok(Item::Word(s.to_string().into())),
        // we don't have booleans in kcats, so if we see 'false' that
        // is the word false which is not defined in the base
        // language, but might be user-defined later.
        edn_format::Value::Boolean(b) =&gt; Ok(if *b { "true".into() } else { "false".into() }),
        edn_format::Value::String(s) =&gt; Ok(s.to_string().into()),
        edn_format::Value::Float(f) =&gt; Ok(Item::Float(f.into_inner())),
        edn_format::Value::TaggedElement(tag, e) =&gt; {
            if *tag == edn_format::Symbol::from_name(BYTE_TAG) {
                if let edn_format::Value::String(s) = &amp;**e {
                    Ok(base64::decode(s).unwrap().into())
                } else {
                    Err(Error::parse("Invalid tag datatype for byte literal"))
                }
            } else {
                Err(Error::parse("Unsupported tag"))
            }
        }
        edn_format::Value::Character(c) =&gt; Ok(Item::Char(*c)),
        _ =&gt; Err(Error::parse("Unsupported data literal")),
    }
}

pub fn from_item(item: &amp;Item) -&gt; edn_format::Value {
    match item {
        // dictionaries are big and it's ugly to print them for
        // environments.
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Env(e),
        ))) =&gt; from_item(&amp;e.representation()),
        Item::Int(i) =&gt; edn_format::Value::Integer(*i),
        Item::Float(f) =&gt; edn_format::Value::from(*f),
        Item::Char(c) =&gt; edn_format::Value::Character(*c),
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(s))) =&gt; {
            edn_format::Value::String(s.to_string())
        }
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(bs))) =&gt; {
            edn_format::Value::TaggedElement(
                edn_format::Symbol::from_name("b64"),
                Box::new(edn_format::Value::String(base64::encode(bs))),
            )
        }
        Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(s))) =&gt; {
            edn_format::Value::String(s.to_string())
        }
        Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(bs))) =&gt; {
            edn_format::Value::TaggedElement(
                edn_format::Symbol::from_name("b64"),
                Box::new(edn_format::Value::String(base64::encode(bs))),
            )
        }
        Item::Dispenser(coll::Dispenser::Sized(v)) =&gt; edn_format::Value::Vector(
            v.clone()
                .into_iter()
                .map(|i| from_item(&amp;i))
                .collect::&lt;Vec&lt;edn_format::Value&gt;&gt;(),
        ),
        Item::Receptacle(coll::Receptacle::Sized(v)) =&gt; {
            from_item(&amp;Item::Dispenser(coll::Dispenser::Sized(v.clone())))
        }
        Item::Word(w) =&gt; edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
        //Item::Entry(w) =&gt; edn_format::Value::Symbol(edn_format::Symbol::from_name(&amp;w.word)),
        Item::Dispenser(coll::Dispenser::Out(o)) =&gt; from_item(&amp;o.representation()),
        Item::Dispenser(coll::Dispenser::Tunnel(t)) =&gt; from_item(&amp;t.representation()),
        Item::Receptacle(coll::Receptacle::In(i)) =&gt; from_item(&amp;i.representation()),
        Item::Receptacle(coll::Receptacle::Tunnel(t)) =&gt; from_item(&amp;t.representation()),
    }
}

pub fn parse(s: String) -&gt; Result&lt;coll::List, Error&gt; {
    let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
    Ok(coll::List::from_iter(
        parser
            .map(move |r| match r {
                Ok(expr) =&gt; Ok(to_item(&amp;expr)?),
                Err(_) =&gt; Err(Error::parse("Invalid edn")),
            })
            .collect::&lt;Result&lt;Vec&lt;Item&gt;, Error&gt;&gt;()?,
    ))
}

pub fn emit(item: &amp;Item) -&gt; String {
    edn_format::emit_str(&amp;from_item(item))
}

pub fn emit_all(items: &amp;VecDeque&lt;Item&gt;) -&gt; String {
    let mut s: String = String::new();
    for i in items {
        s.push_str(&amp;emit(&amp;i));
        s.push_str(" ".into());
    }
    s.pop();
    return s;
}

// print out envs in error messages
impl fmt::Debug for Environment {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(
            f,
            "{{ stack: {}, expression: {} }}",
            emit(&amp;Item::from(self.stack.clone())),
            emit(&amp;Item::from(self.expression.clone())),
        )
    }
}

impl fmt::Debug for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "{}", emit(&amp;Item::from(self.data.clone())))
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb30914b" class="outline-4">
<h4 id="orgb30914b"><span class="section-number-4">1.4.4.</span> Builtin words</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
We'll define some words as axioms (not in terms of other words, only defined in Rust). 
</p>
<div class="org-src-container">
<pre class="src src-rust">use super::serialize;
use crate::pipes;
use crate::types::associative as assoc;
use crate::types::collection as coll;
use crate::types::dictionary as dict;
use crate::types::environment::Environment;
use crate::types::error::Error;
use crate::types::*;

use futures::future::FutureExt;
use num_integer::Roots;
use std::collections::HashMap;
//use std::future::Future;
use std::mem;
use std::ops::Range;

pub type ItemResult = Result&lt;Item, Error&gt;;

impl From&lt;ItemResult&gt; for Item {
    fn from(i: ItemResult) -&gt; Self {
        match i {
            Ok(i) =&gt; i,
            Err(e) =&gt; e.into(),
        }
    }
}

fn f_stack1(f: fn(Item) -&gt; ItemResult) -&gt; impl Fn(Environment) -&gt; Future&lt;Environment&gt; {
    move |mut env: Environment| {
        let x = env.pop();
        env.push(Item::from(f(x))).into()
    }
}

fn f_stack2(f: fn(Item, Item) -&gt; ItemResult) -&gt; impl Fn(Environment) -&gt; Future&lt;Environment&gt; {
    move |mut env: Environment| {
        let x = env.pop();
        let y = env.pop();
        env.push(Item::from(f(y, x))).into()
    }
}

fn f_stack3(f: fn(Item, Item, Item) -&gt; ItemResult) -&gt; impl Fn(Environment) -&gt; Future&lt;Environment&gt; {
    move |mut env: Environment| {
        let x = env.pop();
        let y = env.pop();
        let z = env.pop();
        env.push(Item::from(f(z, y, x))).into()
    }
}

fn f_stack2_async(
    f: fn(Item, Item) -&gt; Future&lt;ItemResult&gt;,
) -&gt; impl Fn(Environment) -&gt; Future&lt;Environment&gt; {
    move |mut env: Environment| {
        let x = env.pop();
        let y = env.pop();
        Box::pin(f(x, y).map(|r| env.push(Item::from(r))))
    }
}

fn update_axiom_entries(
    mut d: dict::Dictionary,
    updates: Vec&lt;(&amp;str, &amp;'static StepFn)&gt;,
) -&gt; dict::Dictionary {
    let dm = coll::Arc::make_mut(&amp;mut d);
    for (w, f) in updates {
        dm.entry(Word::from(w)).and_modify(|e| {
            e.definition = dict::Definition::Axiom(f);
        });
    }
    d
}

pub fn add_builtins(d: dict::Dictionary) -&gt; dict::Dictionary {
    update_axiom_entries(
        d,
        vec![
            ("*", Box::leak(Box::new(f_stack2(mult)))),
            ("+", Box::leak(Box::new(f_stack2(plus)))),
            ("++lookup", Box::leak(Box::new(f_stack2(lookup)))),
            ("++sort", Box::leak(Box::new(f_stack1(sort_by_key)))),
            ("-", Box::leak(Box::new(f_stack2(minus)))),
            ("/", Box::leak(Box::new(f_stack2(div)))),
            ("&lt;", Box::leak(Box::new(f_stack2(lt)))),
            ("&lt;=", Box::leak(Box::new(f_stack2(lte)))),
            ("=", Box::leak(Box::new(f_stack2(eq)))),
            ("&gt;", Box::leak(Box::new(f_stack2(gt)))),
            ("&gt;=", Box::leak(Box::new(f_stack2(gte)))),
            ("abs", Box::leak(Box::new(f_stack1(abs)))),
            ("and", Box::leak(Box::new(f_stack2(and)))),
            ("animate", Box::leak(Box::new(animate))),
            ("assign", Box::leak(Box::new(f_stack3(assign)))),
            ("association", Box::leak(Box::new(f_stack1(association)))),
            (
                "association?",
                Box::leak(Box::new(f_stack1(is_association))),
            ),
            ("branch", Box::leak(Box::new(branch))),
            ("bytes", Box::leak(Box::new(f_stack1(bytes)))),
            ("bytes?", Box::leak(Box::new(f_stack1(is_bytes)))),
            ("clone", Box::leak(Box::new(clone))),
            ("contains?", Box::leak(Box::new(f_stack2(contains)))),
            ("ceil", Box::leak(Box::new(f_stack1(ceil)))),
            ("compare", Box::leak(Box::new(f_stack2(compare)))),
            ("count", Box::leak(Box::new(f_stack1(count)))),
            ("dec", Box::leak(Box::new(f_stack1(dec)))),
            ("decide", Box::leak(Box::new(decide))),
            ("dip", Box::leak(Box::new(dip))),
            ("dictionary", Box::leak(Box::new(dictionary))),
            ("dipdown", Box::leak(Box::new(dipdown))),
            ("drop", Box::leak(Box::new(drop))),
            ("emit", Box::leak(Box::new(f_stack1(emit)))),
            ("environment", Box::leak(Box::new(f_stack1(environment)))),
            ("error?", Box::leak(Box::new(f_stack1(is_error)))),
            ("eval-step", Box::leak(Box::new(eval_step_outer))),
            ("evaluate", Box::leak(Box::new(evaluate))),
            ("even?", Box::leak(Box::new(f_stack1(is_even)))),
            ("evert", Box::leak(Box::new(evert))),
            ("execute", Box::leak(Box::new(execute))),
            ("fail", Box::leak(Box::new(f_stack1(fail)))),
            (
                "file-in",
                Box::leak(Box::new(f_stack1(crate::pipes::fs::file_in))),
            ),
            (
                "file-out",
                Box::leak(Box::new(f_stack1(crate::pipes::fs::file_out))),
            ),
            ("first", Box::leak(Box::new(f_stack1(first)))),
            ("float", Box::leak(Box::new(float))),
            ("handle", Box::leak(Box::new(f_stack1(handle)))),
            (
                "handoff",
                Box::leak(Box::new(crate::pipes::channel::handoff)),
            ),
            ("hash", Box::leak(Box::new(f_stack1(crate::crypto::hash)))),
            ("inc", Box::leak(Box::new(f_stack1(inc)))),
            ("inspect", Box::leak(Box::new(f_stack1(inspect)))),
            ("join", Box::leak(Box::new(f_stack2(join)))),
            ("key", Box::leak(Box::new(f_stack1(crate::crypto::key)))),
            ("last", Box::leak(Box::new(f_stack1(last)))),
            ("list?", Box::leak(Box::new(f_stack1(is_list)))),
            ("loop", Box::leak(Box::new(loop_))),
            ("mod", Box::leak(Box::new(f_stack2(mod_)))),
            ("not", Box::leak(Box::new(f_stack1(not)))),
            ("number?", Box::leak(Box::new(f_stack1(is_number)))),
            ("odd?", Box::leak(Box::new(f_stack1(is_odd)))),
            ("or", Box::leak(Box::new(f_stack2(or)))),
            ("pop", Box::leak(Box::new(pop))),
            ("put", Box::leak(Box::new(put))),
            ("pipe?", Box::leak(Box::new(f_stack1(is_pipe)))),
            ("range", Box::leak(Box::new(range))),
            ("read", Box::leak(Box::new(read))),
            ("recur", Box::leak(Box::new(recur))),
            ("redefine", Box::leak(Box::new(redefine))),
            ("resume", Box::leak(Box::new(identity))),
            ("reverse", Box::leak(Box::new(f_stack1(reverse)))),
            ("second", Box::leak(Box::new(f_stack1(second)))),
            (
                "serversocket",
                Box::leak(Box::new(f_stack2_async(crate::pipes::net::server_socket))),
            ),
            ("set", Box::leak(Box::new(f_stack1(set)))),
            ("set?", Box::leak(Box::new(f_stack1(is_set)))),
            ("sign", Box::leak(Box::new(f_stack2(crate::crypto::sign)))),
            ("sink", Box::leak(Box::new(sink))),
            ("sqrt", Box::leak(Box::new(f_stack1(sqrt)))),
            ("standard", Box::leak(Box::new(standard))),
            ("step", Box::leak(Box::new(step))),
            ("string", Box::leak(Box::new(f_stack1(string)))),
            ("string?", Box::leak(Box::new(f_stack1(is_string)))),
            ("swap", Box::leak(Box::new(swap))),
            ("swapdown", Box::leak(Box::new(swapdown))),
            ("timestamps", Box::leak(Box::new(timestamps))),
            ("true", Box::leak(Box::new(true_))),
            ("unassign", Box::leak(Box::new(f_stack2(unassign)))),
            ("take", Box::leak(Box::new(take))),
            ("unwrap", Box::leak(Box::new(unwrap))),
            (
                "verify",
                Box::leak(Box::new(f_stack3(crate::crypto::verify))),
            ),
            ("word?", Box::leak(Box::new(f_stack1(is_word)))),
            ("wrap", Box::leak(Box::new(wrap))),
            ("xor", Box::leak(Box::new(f_stack2(xor)))),
            ("zero?", Box::leak(Box::new(f_stack1(is_zero)))),
        ],
    )
}

pub fn read_lexicon(lexicon: String, mut env: Environment) -&gt; Environment {
    let mut items = serialize::parse(lexicon).unwrap();
    for r in Box::new(items.inner().into_iter()) {
        let (k, def): (assoc::KeyItem, Item) = r.try_into().unwrap();
        let word: Word = k.try_into().unwrap();
        let iter: Box&lt;dyn Iterator&lt;Item = Item&gt;&gt; = def.try_into().unwrap();

        let new_entry: dict::Entry = iter.try_into().unwrap();
        let new_entry2 = new_entry.clone();
        let dict = coll::Arc::make_mut(&amp;mut env.dictionary);
        dict.entry(word)
            .and_modify(|e| {
                e.examples = new_entry.examples;
                e.spec = new_entry.spec;
                e.definition = new_entry.definition;
            })
            .or_insert(new_entry2);
    }
    env
}

pub fn add_standard_dictionary(env: Environment) -&gt; Environment {
    // read builtins
    let builtins = String::from_utf8(include_bytes!("kcats/builtins.kcats").to_vec()).unwrap();
    let mut env = read_lexicon(builtins, env);
    //println!("with builtins {:?}", env.dictionary);
    env.dictionary = add_builtins(env.dictionary);
    //env = add_derivations(env);
    let lexicon = String::from_utf8(include_bytes!("kcats/lexicon.kcats").to_vec()).unwrap();
    read_lexicon(lexicon, env)
}

pub fn invalid_type_error(asked: coll::List, actual: Item) -&gt; ItemResult {
    Err(Error::type_mismatch(asked, Some(actual)))
}

fn number_type_error(i: Item) -&gt; ItemResult {
    invalid_type_error(crate::types::wrap(Item::Word(*S_NUMBER)), i)
}

fn pair(i: Item, j: Item) -&gt; Item {
    coll::List::from_iter([i, j]).into()
}

pub fn plus(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::Int(i + j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::Float(i + j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::Float(i as Float + j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::Float(i + j as Float)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn minus(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::Int(i - j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::Float(i - j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::Float(i as Float - j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::Float(i - j as Float)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn mult(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::Int(i * j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::Float(i * j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::Float(i as Float * j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::Float(i * j as Float)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

fn divide(i: Float, j: Float) -&gt; ItemResult {
    let q = i / j;
    if q.is_nan() {
        Err(Error::division_by_zero())
    } else {
        Ok(Item::Float(q))
    }
}

pub fn div(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; i
            .checked_div(j)
            .ok_or_else(|| Error::division_by_zero())
            .and_then(|i| Ok(Item::Int(i))),

        (Item::Float(i), Item::Float(j)) =&gt; divide(i, j),
        (Item::Int(i), Item::Float(j)) =&gt; divide(i as Float, j),
        (Item::Float(i), Item::Int(j)) =&gt; divide(i, j as Float),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn mod_(i: Item, j: Item) -&gt; ItemResult {
    let i = Int::try_from(i)?;
    let j = Int::try_from(j)?;
    Ok(Item::Int(i % j))
}

pub fn inc(i: Item) -&gt; ItemResult {
    Ok(Item::Int(Int::try_from(i)? + 1))
}

pub fn dec(i: Item) -&gt; ItemResult {
    Ok(Item::Int(Int::try_from(i)? - 1))
}

pub fn is_zero(i: Item) -&gt; ItemResult {
    match i {
        Item::Int(i) =&gt; Ok(Item::from(i == 0)),
        Item::Float(i) =&gt; Ok(Item::from(i == 0.0)),
        i =&gt; number_type_error(i),
    }
}

pub fn gt(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::from(i &gt; j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::from(i &gt; j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::from(i as Float &gt; j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::from(i &gt; j as Float)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn lt(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::from(i &lt; j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::from(i &lt; j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::from((i as Float) &lt; j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::from(i &lt; j as Float)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn gte(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::from(i &gt;= j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::from(i &gt;= j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::from(i as Float &gt;= j)),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::from(i &gt;= j as Float)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn lte(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::from(i &lt;= j)),
        (Item::Float(i), Item::Float(j)) =&gt; Ok(Item::from(i &lt;= j)),
        (Item::Int(i), Item::Float(j)) =&gt; Ok(Item::from((i as Float).le(&amp;j))),
        (Item::Float(i), Item::Int(j)) =&gt; Ok(Item::from(i &lt;= j as Float)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

pub fn join(i: Item, j: Item) -&gt; ItemResult {
    let i = coll::Sized::try_from(i)?;
    let j = coll::Sized::try_from(j)?;
    Ok(i.join(j)?.into())
}

pub fn put(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let j = env.pop();
    let i = env.pop();
    let i2 = i.clone();
    let pr = coll::Receptacle::try_from(i);
    match pr {
        Ok(p) =&gt; Box::pin(p.put(j).map(|f| match f {
            Ok(p) =&gt; env.push(Item::Receptacle(p)).into(),
            Err(e) =&gt; env.push(i2).push(e.into()).into(),
        })),
        Err(e) =&gt; env.push(i2).push(e.into()).into(),
    }
}

pub fn clone(env: Environment) -&gt; Future&lt;Environment&gt; {
    let clone = env.stack.front().unwrap().clone();
    env.push(clone).into()
}

fn swap2(mut env: Environment, offset: usize) -&gt; Future&lt;Environment&gt; {
    coll::Arc::make_mut(&amp;mut env.stack).swap(offset, offset + 1);
    env.into()
}

pub fn swap(env: Environment) -&gt; Future&lt;Environment&gt; {
    swap2(env, 0)
}

pub fn swapdown(env: Environment) -&gt; Future&lt;Environment&gt; {
    swap2(env, 1)
}

pub fn sink(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let s = coll::Arc::make_mut(&amp;mut env.stack);
    s.swap(0, 2);
    s.swap(0, 1);
    env.into()
}

pub fn float(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let s = coll::Arc::make_mut(&amp;mut env.stack);
    s.swap(0, 2);
    s.swap(1, 2);
    env.into()
}

pub fn drop(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    env.pop();
    env.into()
}

pub fn eq(i: Item, j: Item) -&gt; ItemResult {
    Ok(Item::from(i == j))
}

pub fn count(i: Item) -&gt; ItemResult {
    match i {
        Item::Dispenser(coll::Dispenser::Sized(i)) =&gt; Ok(Item::Int(i.len() as Int)),
        Item::Receptacle(coll::Receptacle::Sized(i)) =&gt; Ok(Item::Int(i.len() as Int)),
        i =&gt; Err(Error::expected("sized", i)),
    }
}

pub fn is_string(i: Item) -&gt; ItemResult {
    Ok(Item::from(matches!(
        i,
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_)))
    )))
}

pub fn is_bytes(i: Item) -&gt; ItemResult {
    Ok(Item::from(matches!(
        i,
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_)))
    )))
}

pub fn is_error(i: Item) -&gt; ItemResult {
    Ok(Item::from(matches!(
        i,
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Error(_),
        )))
    )))
}

pub fn is_word(i: Item) -&gt; ItemResult {
    Ok(Item::from(match i {
        Item::Word(_) =&gt; true,
        //Item::Iterable(Item(_)) =&gt; true,
        // TODO maybe also check if it's an associative that looks like a Def?
        _ =&gt; false,
    }))
}

pub fn is_pipe(i: Item) -&gt; ItemResult {
    Ok(Item::from(match i {
        Item::Dispenser(coll::Dispenser::Out(_)) =&gt; true,
        Item::Dispenser(coll::Dispenser::Tunnel(_)) =&gt; true,
        Item::Receptacle(coll::Receptacle::In(_)) =&gt; true,
        Item::Receptacle(coll::Receptacle::Tunnel(_)) =&gt; true,
        _ =&gt; false,
    }))
}
pub fn is_number(i: Item) -&gt; ItemResult {
    Ok(Item::from(matches!(i, Item::Int(_) | Item::Float(_))))
}

pub fn is_list(i: Item) -&gt; ItemResult {
    Ok(Item::from(matches!(
        i,
        Item::Dispenser(coll::Dispenser::Sized(_))
    )))
}

pub fn first(i: Item) -&gt; ItemResult {
    let l = coll::List::try_from(i)?;
    Ok(l.front().map(|i| i.clone()).unwrap_or_default())
}

pub fn second(i: Item) -&gt; ItemResult {
    let l = coll::List::try_from(i)?;
    Ok(l.get(1).map(|i| i.clone()).unwrap_or_default())
}

pub fn last(i: Item) -&gt; ItemResult {
    let l = coll::List::try_from(i)?;
    Ok(l.back().map(|i| i.clone()).unwrap_or_default())
}

pub fn loop_(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let p = coll::List::try_from(env.pop());
    match p {
        Ok(mut p) =&gt; {
            let f = env.pop();
            if is_truthy(f) {
                let p2 = p.clone();
                let pm = coll::Arc::make_mut(&amp;mut p);
                pm.push_back(Item::from(p2));
                pm.push_back("loop".into());
                env.append_expression(p)
            } else {
                env
            }
        }
        Err(e) =&gt; env.push(Item::from(e)),
    }
    .into()
}

pub fn execute(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let i = env.pop();
    match coll::List::try_from(i) {
        Ok(program) =&gt; env.append_expression(program),
        Err(e) =&gt; env.push(e.into()),
    }
    .into()
}

pub fn wrap(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let item = env.pop();
    env.push(coll::List::from_iter([item]).into()).into()
}

pub fn unwrap(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    //println!("unwrapping");
    match coll::List::try_from(env.pop()) {
        Ok(l) =&gt; {
            let len = l.len();
            let l2 = (0..len).map(move |i| l[i].clone());
            for i in l2 {
                env = env.push(i);
            }
            env
        }
        Err(e) =&gt; env.push(e.into()),
    }
    .into()
}

pub fn dip(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    match coll::List::try_from(env.pop()) {
        Ok(program) =&gt; {
            let item = env.pop();
            let expr = env.expression.make_mut();
            expr.push_front("unwrap".into());
            expr.push_front(coll::List::from_iter([item]).into());
            env.append_expression(program)
        }
        Err(e) =&gt; env.push(e.into()),
    }
    .into()
}

pub fn dipdown(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    match coll::List::try_from(env.pop()) {
        Ok(program) =&gt; {
            let item1 = env.pop();
            let item2 = env.pop();
            let expr = env.expression.make_mut();
            expr.push_front("unwrap".into());
            expr.push_front(coll::List::from_iter([item2, item1]).into());
            env.append_expression(program)
        }
        Err(e) =&gt; env.push(e.into()),
    }
    .into()
}

pub fn take(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    // TODO: handle Nothing case
    let coll = {
        let stack = env.stack.make_mut();
        stack.pop_front()
    };
    match coll {
        Some(i) =&gt; {
            let i2 = i.clone();
            let r = coll::Dispenser::try_from(i);
            match r {
                Ok(it) =&gt; {
                    let f = it.take();
                    Box::pin(async move {
                        let (c, i) = f.await;
                        let stack = env.stack.make_mut();
                        stack.push_front(c.into());
                        stack.push_front(i.unwrap_or_default());
                        env
                    })
                }
                Err(e) =&gt; {
                    let stack = env.stack.make_mut();
                    stack.push_front(i2);
                    stack.push_front(e.into());
                    env.into()
                }
            }
        }
        None =&gt; {
            let stack = env.stack.make_mut();
            stack.push_front(Error::stack_underflow().into());
            env.into()
        }
    }
}

pub fn pop(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let coll = {
        let stack = env.stack.make_mut();
        stack.pop_front()
    };
    match coll {
        Some(i) =&gt; {
            let i2 = i.clone();
            let r = coll::List::try_from(i);
            match r {
                Ok(mut it) =&gt; {
                    let itm = it.make_mut();
                    let i = itm.pop_back();
                    let stack = env.stack.make_mut();
                    stack.push_front(it.into());
                    stack.push_front(i.unwrap_or_default());
                    env.into()
                }
                Err(e) =&gt; {
                    let stack = env.stack.make_mut();
                    stack.push_front(i2);
                    stack.push_front(e.into());
                    env.into()
                }
            }
        }
        None =&gt; {
            let stack = env.stack.make_mut();
            stack.push_front(Error::stack_underflow().into());
            env.into()
        }
    }
}

fn is_truthy(i: Item) -&gt; bool {
    coll::Sized::try_from(i).map_or(true, |s| !s.is_empty())
}

// fn boolean_value(b: bool) -&gt; Item {
//     if b {
//         "true".into()
//     } else {
//         coll::NOTHING
//     }
// }

pub fn branch(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    match (
        coll::List::try_from(env.pop()),
        coll::List::try_from(env.pop()),
    ) {
        (Ok(false_branch), Ok(true_branch)) =&gt; {
            let b = env.pop();

            env.append_expression(if is_truthy(b) {
                true_branch
            } else {
                false_branch
            })
        }
        (Err(e), _) =&gt; env.push(e.into()),
        (_, Err(e)) =&gt; env.push(e.into()),
    }
    .into()
}

pub fn step(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let p = coll::List::try_from(env.pop()).unwrap();
    let it = coll::Dispenser::try_from(env.pop()).unwrap();
    Box::pin(async move {
        if let (it, Some(litem)) = it.take().await {
            let expr = env.expression.make_mut();
            // prepare the next iteration, even if the iterator is now
            // empty
            expr.push_front("step".into());
            expr.push_front(p.clone().into());
            expr.push_front(it.into());
            expr.push_front("execute".into());

            env.push(litem).push(p.into()).into()
        } else {
            env.into()
        }
    })
}

pub fn range(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let stepby = Int::try_from(env.pop()).unwrap();
    let to = Int::try_from(env.pop()).unwrap();
    let from = Int::try_from(env.pop()).unwrap();
    env.push(
        coll::List::from_iter((from..to).step_by(stepby as usize).map(|i| Item::Int(i))).into(),
    )
    .into()
}

// (effect [rec2 rec1 then pred]
//                   ['[if]
//[(concat rec1
//         [[pred then rec1 rec2 'recur]] rec2)
// then pred]])

pub fn recur(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let mut rec2 = coll::List::try_from(env.pop()).unwrap();
    let mut rec1 = coll::List::try_from(env.pop()).unwrap();
    let then = coll::List::try_from(env.pop()).unwrap();
    let pred = coll::List::try_from(env.pop()).unwrap();
    env = env.push_expr("if".into());
    let r = coll::List::from_iter([
        Item::from(pred.clone()),
        then.clone().into(),
        rec1.clone().into(),
        rec2.clone().into(),
        "recur".into(),
    ])
    .into();
    // I think i did this right - used to create a new list and extend
    // it with rec1, then push r, then extend again with rec2. now
    // start with rec1 (copied on write), then push r, then extend
    // with rec2.  That should be equivalent.
    let rm = rec1.make_mut();
    rm.push_back(r);
    rm.extend(rec2.make_mut().drain(..));

    env.push(pred.into())
        .push(then.into())
        .push(rec1.into())
        .into()
}

//(fn [{[l &amp; others] 'stack :as env}]
//            (assoc env 'stack (apply list (vec others) l)))

pub fn evert(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let mut l = coll::List::try_from(env.pop()).unwrap();
    mem::swap(&amp;mut env.stack, &amp;mut l);
    env.push(l.into()).into()
}

fn assoc_in(i: Item, ks: &amp;[assoc::KeyItem], v: Item) -&gt; Result&lt;Item, Error&gt; {
    if let [k, ks @ ..] = ks {
        if ks.is_empty() {
            match (i, k) {
                (
                    Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                    assoc::KeyItem::Int(k),
                ) =&gt; {
                    // vector set by index
                    let lm = coll::Arc::make_mut(&amp;mut l);
                    let idx = *k as usize;
                    // extend the size of the vector to be big enough to set
                    // the given index, pad with 'nothing' values.
                    if lm.len() &lt;= idx {
                        lm.resize(idx + 1, coll::NOTHING);
                    }
                    lm[*k as usize] = v;
                    Ok(l.into())
                }
                (i, k) =&gt; {
                    //println!("assoc_in: {:?} {:?}", i, k);
                    let a = assoc::Associative::try_from(i)?;
                    Ok(a.insert(k.clone(), v).0.into())
                }
            }
            //hm.insert(k.clone(), v);
        } else {
            match (i, k) {
                (
                    Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                    assoc::KeyItem::Int(k),
                ) =&gt; {
                    let lm = coll::Arc::make_mut(&amp;mut l);
                    let idx = *k as usize;
                    // extend the size of the vector to be big enough to set
                    // the given index, pad with 'nothing' values.
                    if lm.len() &lt;= idx {
                        lm.resize(idx + 1, coll::NOTHING);
                    }
                    let inner = &amp;lm[idx];

                    lm[*k as usize] = if let [nextk, ..] = ks {
                        let i: Item = match (inner, nextk) {
                            (
                                Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(l))),
                                assoc::KeyItem::Int(_),
                            ) =&gt; l.clone().into(),
                            (_, assoc::KeyItem::Int(_)) =&gt; coll::List::new().into(),
                            _ =&gt; assoc::Association::new().into(),
                        };
                        assoc_in(i, ks, v)?
                    } else {
                        v
                    };

                    //if the inner value isn't a list, overwrite it
                    Ok(l.into())
                }
                (i, k) =&gt; {
                    //println!("assoc_in morekeys: {:?} {:?}", i, k);
                    let a = assoc::Associative::try_from(i)?;
                    let inner = a.get(&amp;k).unwrap_or_default().clone();
                    // if the inner value isn't a map, we're just overwriting whatever it
                    // is with a new map.

                    let i = match inner {
                        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(a))) =&gt; {
                            a.clone().into()
                        }
                        _ =&gt; assoc::Association::new().into(),
                    };
                    Ok(a.insert(k.clone(), assoc_in(i, ks, v)?).0.into())
                }
            }
        }
    } else {
        Ok(i)
    }
}

fn unassoc_in(i: Item, ks: &amp;[assoc::KeyItem]) -&gt; Result&lt;Item, Error&gt; {
    if let [k, ks @ ..] = ks {
        if ks.is_empty() {
            let a = assoc::Associative::try_from(i)?;
            Ok(a.remove(&amp;k).0.into())
        } else {
            match (i, k) {
                (
                    Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                    assoc::KeyItem::Int(k),
                ) =&gt; {
                    let lm = l.make_mut();
                    let old_value = if let Some(item) = lm.get_mut(*k as usize) {
                        mem::replace(item, coll::NOTHING)
                    } else {
                        return Err(Error::short_list(k.clone())); // replace with your error
                    };
                    let new_value = unassoc_in(old_value, ks)?;
                    lm[*k as usize] = new_value;
                    Ok(l.into())
                }
                (a, k) =&gt; {
                    let a: assoc::Associative = a.try_into()?;
                    let mut a: assoc::Association = a.into_iter().collect();
                    let am = a.make_mut();
                    let mut res: Option&lt;Result&lt;_, Error&gt;&gt; = None;
                    am.entry(k.clone()).and_modify(|v| {
                        let new_value = unassoc_in(v.clone(), ks);
                        res = Some(new_value.map(|nv| {
                            *v = nv;
                        }));
                    });
                    if let Some(Err(e)) = res {
                        return Err(e);
                    }
                    Ok(a.into())
                }
            }
        }
    } else {
        Ok(i)
    }
}

pub fn assign(m: Item, ks: Item, v: Item) -&gt; ItemResult {
    let mut kit = coll::List::try_from(ks)?;
    let mut ksvec: assoc::KeyList = assoc::KeyList::try_from_iter(kit.inner().into_iter())?;
    ksvec.make_mut().make_contiguous();
    let (ks, _) = ksvec.as_slices();
    assoc_in(m, ks, v)
}

pub fn unassign(m: Item, ks: Item) -&gt; ItemResult {
    let mut kit = coll::List::try_from(ks)?;
    let mut ksvec: assoc::KeyList = assoc::KeyList::try_from_iter(kit.inner().into_iter())?;
    ksvec.make_mut().make_contiguous();
    let (ks, _) = ksvec.as_slices();
    unassoc_in(m, ks)
}

pub fn association(m: Item) -&gt; ItemResult {
    match assoc::Associative::try_from(m) {
        Ok(m) =&gt; Ok(m.into()),
        Err(e) =&gt; Err(e),
    }
}

pub fn lookup(i: Item, k: Item) -&gt; ItemResult {
    //println!("lookup {:?} \n {:?}", m, k);
    let k = assoc::KeyItem::try_from(k)?;
    match (i, k) {
        (Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(l))), assoc::KeyItem::Int(k)) =&gt; {
            Ok(l.get(k as usize)
                .and_then(|x| Some(x.clone()))
                .unwrap_or_default())
        }
        (i, k) =&gt; {
            let m = assoc::Associative::try_from(i)?;
            Ok(m.get(&amp;k).unwrap_or_default())
        }
    }
}

pub fn contains(c: Item, i: Item) -&gt; ItemResult {
    let s = coll::Sized::try_from(c)?;
    Ok(s.contains(&amp;i).into())
}

pub fn or(i: Item, j: Item) -&gt; ItemResult {
    Ok(if is_truthy(i.clone()) {
        i
    } else {
        if is_truthy(j.clone()) {
            j
        } else {
            coll::NOTHING
        }
    })
    //Ok(Item::from(is_truthy(i) || is_truthy(j)))
}

pub fn and(i: Item, j: Item) -&gt; ItemResult {
    Ok(if is_truthy(i) &amp;&amp; is_truthy(j.clone()) {
        j
    } else {
        coll::NOTHING
    })
}

pub fn not(i: Item) -&gt; ItemResult {
    Ok(Item::from(!is_truthy(i)))
}

pub fn is_association(i: Item) -&gt; ItemResult {
    Ok(coll::Sized::try_from(i)
        .map(|s| matches!(s, coll::Sized::Associative(_) | coll::Sized::Nothing))
        .unwrap_or(false)
        .into())
}

pub fn is_set(i: Item) -&gt; ItemResult {
    Ok(coll::Sized::try_from(i)
        .map(|s| matches!(s, coll::Sized::Set(_) | coll::Sized::Nothing))
        .unwrap_or(false)
        .into())
}

pub fn is_odd(i: Item) -&gt; ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::from(i &amp; 1 == 1))
}

pub fn is_even(i: Item) -&gt; ItemResult {
    let i = Int::try_from(i)?;
    Ok(Item::from(i &amp; 1 == 0))
}

pub fn decide(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let mut clauses = coll::List::try_from(env.pop()).unwrap();
    let clauses_data = coll::Arc::make_mut(&amp;mut clauses);
    let clause = clauses_data.pop_front();

    if let Some(clause) = clause {
        let clause: Result&lt;coll::List, Error&gt; = clause.try_into();
        match clause {
            Ok(mut clause) =&gt; {
                if clause.len() != 2 {
                    env.push(Error::list_count(2).into()).into()
                } else {
                    let clause_data = clause.make_mut();
                    let test: Result&lt;coll::List, Error&gt; = clause_data
                        .pop_front()
                        .ok_or(Error::list_count(2))
                        .and_then(|i| i.try_into());
                    let expr: Result&lt;coll::List, Error&gt; = clause_data
                        .pop_front()
                        .ok_or(Error::list_count(2))
                        .and_then(|i| i.try_into());

                    match (test, expr) {
                        (Ok(test), Ok(expr)) =&gt; {
                            // construct if
                            let testp = coll::List::from_iter([Item::from(test), "shield".into()]);
                            let elsep =
                                coll::List::from_iter([Item::from(clauses), "decide".into()]);
                            let newexpr = coll::List::from_iter([
                                Item::from(testp),
                                expr.into(),
                                elsep.into(),
                                "if".into(),
                            ]);
                            env.append_expression(newexpr).into()
                        }
                        (Err(test), _) =&gt; env.push(test.into()).into(),
                        (_, Err(expr)) =&gt; env.push(expr.into()).into(),
                    }
                }
            }
            Err(e) =&gt; env.push(e.into()).into(),
        }
    } else {
        // clauses empty, return nothing
        env.push(coll::NOTHING).into()
    }
}

pub fn read(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let s = String::try_from(env.pop()).unwrap();
    let parsed = serialize::parse(s);
    env.push(match parsed {
        Ok(l) =&gt; l.into(),
        Err(e) =&gt; e.into(),
    })
    .into()
}

pub fn emit(i: Item) -&gt; ItemResult {
    Ok(Item::Dispenser(coll::Dispenser::Sized(
        coll::Sized::String(serialize::emit(&amp;i)),
    )))
}

fn check_type(i: &amp;Item, w: Word) -&gt; Result&lt;(), Error&gt; {
    match (w, i) {
        (w, _) if w == *S_ITEM =&gt; Ok(()),
        (w, Item::Dispenser(_) | Item::Receptacle(_)) if w == *S_DISPENSER =&gt; Ok(()),
        (w, Item::Int(_)) if w == *S_INTEGER || w == *S_NUMBER =&gt; Ok(()),
        (w, Item::Float(_)) if w == *S_FLOAT || w == *S_NUMBER =&gt; Ok(()),
        // TODO: also handle cases where bytes/string is a list
        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_))),
        ) if w == *S_BYTES || w == *S_ORDERED =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_))),
        ) if w == *S_STRING =&gt; Ok(()),
        (w, Item::Word(_)) if w == *S_WORD =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Out(_))
            | Item::Dispenser(coll::Dispenser::Tunnel(_))
            | Item::Receptacle(coll::Receptacle::Tunnel(_))
            | Item::Receptacle(coll::Receptacle::In(_)),
        ) if w == *S_PIPE =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::List(_)))
            | Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Nothing))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Nothing)),
        ) if w == *S_LIST || w == *S_PROGRAM =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(_)))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(_))),
        ) if w == *S_ASSOC =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                assoc::Associative::Error(_),
            )))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
                assoc::Associative::Error(_),
            ))),
        ) if w == *S_ERROR =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(_))
            | Item::Receptacle(coll::Receptacle::Sized(_)),
        ) if w == *S_SIZED || w == *S_ORDERED =&gt; Ok(()),

        (
            w,
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                assoc::Associative::Env(_),
            )))
            | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
                assoc::Associative::Env(_),
            ))),
        ) if w == *S_ENVIRONMENT =&gt; Ok(()),
        (w, i) =&gt; {
            //println!("Type check failed! wanted {} got {:?}", w, i);
            Err(Error::expected(&amp;w, i.clone()))
        }
    }
}

fn check_stack_depth(env: &amp;Environment, min_depth: usize) -&gt; Result&lt;(), Error&gt; {
    //println!("Checking stack has at least {} items", min_depth);
    if env.stack.len() &lt; min_depth {
        Err(Error::stack_underflow())
    } else {
        Ok(())
    }
}

fn check_input_spec(spec: &amp;coll::List, env: &amp;Environment) -&gt; Result&lt;(), Error&gt; {
    let specs: coll::List = spec
        .front()
        .ok_or(Error::expected("specs", Default::default()))
        .and_then(|i| i.clone().try_into())?;

    check_stack_depth(env, specs.len())?;
    let indexes = Range {
        start: 0,
        end: specs.len(),
    };

    indexes
        .into_iter()
        .map(|i| {
            let item = env.stack.get(i).unwrap();
            let spec = specs.get(i).unwrap();

            match spec {
                Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(named))) =&gt; {
                    match named.get(0).unwrap() {
                        Item::Word(w) =&gt; check_type(item, *w),
                        i =&gt; {
                            println!("Expected word, got {:?}", i);
                            Err(Error::expected("list", i.clone()))
                        }
                    }
                }
                Item::Word(w) =&gt; check_type(item, *w),
                // the type might happen to also be a defined
                // word, like 'association'
                i =&gt; Err(Error::expected("list", i.clone())),
            }
        })
        .collect::&lt;Result&lt;(), Error&gt;&gt;()
}

pub fn eval_step(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    //println!("{:?}", env);
    let next_item = env.expression.front();

    if let Some(val) = next_item {
        match val {
            Item::Word(word) =&gt; {
                if let Some(dfn) = env.dictionary.get(word) {
                    {
                        if let Some(spec) = &amp;dfn.spec {
                            if let Err(e) = check_input_spec(&amp;spec, &amp;env) {
                                env = env.push(e.into());
                                return env.into();
                            }
                        } else {
                            println!("No spec for {}!", word);
                        }
                        let expr = coll::Arc::make_mut(&amp;mut env.expression);
                        expr.pop_front();

                        match &amp;dfn.definition {
                            dict::Definition::Axiom(a) =&gt; {
                                // we can't keep borrowing the env, so we
                                // clone the axiom def to release it and then
                                // we can pass the env to the axiom def fn
                                let f = a.clone();
                                (f)(env)
                            }
                            dict::Definition::Derived(d) =&gt; {
                                let items = d.clone();
                                env.append_expression(items).into()
                            }
                        }
                    }
                } else {
                    let w = *word;
                    env.push(Error::undefined(w).into()).into()
                }
            }
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                assoc::Associative::DictEntry(entry),
            ))) =&gt; {
                if let Some(spec) = &amp;entry.spec {
                    if let Err(e) = check_input_spec(&amp;spec, &amp;env) {
                        env = env.push(e.into());
                        return env.into();
                    }
                }
                let expr = coll::Arc::make_mut(&amp;mut env.expression);
                let e: dict::Entry = expr.pop_front().unwrap().try_into().unwrap();

                match e.definition {
                    dict::Definition::Axiom(builtin) =&gt; {
                        //let b = dict::Axiom::try_from(env.pop_expr()).unwrap();
                        (builtin)(env)
                    }
                    dict::Definition::Derived(d) =&gt; {
                        let d = d.clone();
                        env.append_expression(d).into()
                    }
                }
            }
            _ =&gt; {
                // not a word, just push onto stack
                let i = env.pop_expr();
                env.push(i).into()
            }
        }
    } else {
        env.push(Error::short_list(1).into()).into()
    }
}

fn reverse(i: Item) -&gt; ItemResult {
    let mut l = coll::List::try_from(i).unwrap();
    Ok(coll::List::from_iter(l.inner().into_iter().rev()).into())
}

fn bytes(i: Item) -&gt; ItemResult {
    match i {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(s))) =&gt; {
            Ok(s.as_bytes().to_vec().into())
        }
        Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(s))) =&gt; {
            Ok(s.as_bytes().to_vec().into())
        }
        i =&gt; Ok(Bytes::from(serialize::emit(&amp;i)).into()),
    }
}

fn string(i: Item) -&gt; ItemResult {
    match i {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(b))) =&gt; {
            Ok(Item::Dispenser(coll::Dispenser::Sized(
                coll::Sized::String(std::str::from_utf8(&amp;b).unwrap().to_string()),
            )))
        }
        Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(b))) =&gt; {
            Ok(Item::Receptacle(coll::Receptacle::Sized(
                coll::Sized::String(std::str::from_utf8(&amp;b).unwrap().to_string()),
            )))
        }
        i =&gt; Ok(Item::Dispenser(coll::Dispenser::Sized(
            coll::Sized::String(serialize::emit(&amp;i)),
        ))),
    }
}

fn get_error(env: &amp;Environment) -&gt; Option&lt;Error&gt; {
    env.stack.front().and_then(|i| match i {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Error(e),
        ))) =&gt; Some(e.clone()),
        Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
            assoc::Associative::Error(e),
        ))) =&gt; Some(e.clone()),
        _ =&gt; None,
    })
}

fn unwind(mut env: Environment) -&gt; Environment {
    let err = env.pop();
    let w: &amp;Item = &amp;"handle".into();

    let err = match err {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Error(mut e),
        ))) =&gt; {
            let mut next = env.expression.front();
            let mut unwound = Vec::&lt;Item&gt;::new();
            while next.is_some() &amp;&amp; next.unwrap() != w {
                let i = env.pop_expr();
                unwound.push(i);
                next = env.expression.front();
            }
            if next.is_some() {
                env.pop_expr();
            }
            // set the is_handled bit
            e.is_handled = true;
            let em = coll::Arc::make_mut(&amp;mut e.data);
            em.insert("unwound".into(), coll::List::from_iter(unwound).into());
            e.into()
        }
        i =&gt; i,
    };
    env = env.push(err);
    return env;
}

pub async fn eval(mut env: Environment) -&gt; Environment {
    loop {
        if let Some(err) = get_error(&amp;env) {
            if !err.is_handled {
                env = unwind(env); // TODO: this should be done in eval_step
            };
        }
        if !env.expression.is_empty() {
            env = eval_step(env).await;
        } else {
            break;
        }
    }
    env
}

pub fn standard_env(program: Option&lt;coll::List&gt;, stack: Option&lt;coll::List&gt;) -&gt; Environment {
    let prog_expr = match program {
        Some(p) =&gt; Stack::from(p),
        _ =&gt; Stack::new(),
    };

    let env = Environment {
        stack: stack.unwrap_or(Stack::new()),
        expression: prog_expr,
        dictionary: coll::Arc::wrap(HashMap::&lt;Word, dict::Entry&gt;::new()),
    };
    add_standard_dictionary(env)
}

fn environment(p: Item) -&gt; ItemResult {
    Environment::try_from(p).map(|e| e.into())
}

pub fn eval_step_outer(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let tos = env.pop();
    let inner_env = Environment::try_from(tos);
    match inner_env {
        Ok(inner) =&gt; Box::pin(eval_step(inner).map(|inner_next| env.push(inner_next.into()))),
        Err(e) =&gt; env.push(e.into()).into(),
    }
}

pub fn evaluate(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let tos = env.pop();
    let inner_env = Environment::try_from(tos);
    match inner_env {
        Ok(inner) =&gt; Box::pin(eval(inner).map(|inner_done| env.push(inner_done.into()))),
        Err(e) =&gt; env.push(e.into()).into(),
    }
}

pub fn identity(env: Environment) -&gt; Future&lt;Environment&gt; {
    env.into()
}

pub fn dictionary(env: Environment) -&gt; Future&lt;Environment&gt; {
    let d = env.dictionary.clone();
    env.push(d.into()).into()
}

fn ceil(i: Item) -&gt; ItemResult {
    let f = Float::try_from(i)?;
    Ok(Item::Float(f.ceil()))
}

fn sqrt(i: Item) -&gt; ItemResult {
    match i {
        Item::Int(i) =&gt; Ok(Item::Int(i.sqrt())),
        Item::Float(f) =&gt; Ok(Item::Float(f.sqrt())),
        i =&gt; number_type_error(i),
    }
}

fn abs(i: Item) -&gt; ItemResult {
    match i {
        Item::Int(i) =&gt; Ok(Item::Int(i.abs())),
        Item::Float(f) =&gt; Ok(Item::Float(f.abs())),
        i =&gt; number_type_error(i),
    }
}

fn handle(i: Item) -&gt; ItemResult {
    match i {
        Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
            assoc::Associative::Error(mut e),
        ))) =&gt; Ok({
            e.is_handled = true;
            e.into()
        }),
        i =&gt; Ok(i),
    }
}

// fn inscription(env: &amp;mut Environment) -&gt; Result&lt;(Word, dict::Entry), Error&gt; {
//     let d = env.pop();
//     let mut wl = coll::List::try_from(env.pop())?;
//     let w1 = coll::Arc::make_mut(&amp;mut wl).pop_front();
//     let x = w1.ok_or(Error::short_list(1))?;
//     let w = Word::try_from(x.clone())?;
//     Ok((w, dict::Entry::try_from(d)?))
// }

// pub fn inscribe(mut env: Environment) -&gt; Environment {
//     let r = inscription(&amp;mut env);
//     match r {
//         Ok((w, def)) =&gt; {
//             let d = coll::Arc::make_mut(&amp;mut env.dictionary);
//             d.insert(assoc::KeyItem::Word(w), Item::Entry(def));
//             env
//         }
//         Err(e) =&gt; env.push(e.into()),
//     }
// }

// make 'true' a word that doesn't have to be quoted, just pushes
// itself onto the stack.
pub fn true_(env: Environment) -&gt; Future&lt;Environment&gt; {
    env.push("true".into()).into()
}

pub fn fail(e: Item) -&gt; ItemResult {
    let mut e: Error = e.try_into().unwrap();
    e.is_handled = false;
    Err(e)
}

// fn normalize_dictionary(mut d: dict::Dictionary) -&gt; Result&lt;dict::Dictionary, Error&gt; {
//     let dm = coll::Arc::make_mut(&amp;mut d);
//     for (k, v) in dm.iter_mut() {
//         match v {
//             Item::Assoc(a) =&gt; {
//                 let aa = a.clone();
//                 let (aa, _) = aa.insert("word".into(), Item::try_from(k.clone()).unwrap());
//                 *v = Item::Entry(aa.try_into()?)
//             }
//             Item::List(l) =&gt; {
//                 let a: assoc::Associative = l.clone().try_into()?;
//                 let (a, _) = a.insert("word".into(), Item::try_from(k.clone()).unwrap());
//                 *v = Item::Entry(a.try_into()?)
//             }
//             Item::Entry(_) =&gt; {}
//             _ =&gt; {
//                 return Err(Error::expected("dictionary"));
//             }
//         }
//     }
//     Ok(d)
// }

pub fn redefine(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let d = dict::Dictionary::try_from(env.pop());
    match d {
        Ok(d) =&gt; {
            env.dictionary = d;
            env
        }
        Err(e) =&gt; {
            env = env.push(e.into());
            env
        }
    }
    .into()
}

// Takes an inner environment from the top of the stack, and spawns a
// tokio task to evaluate that environment.
pub fn animate(mut env: Environment) -&gt; Future&lt;Environment&gt; {
    let tos = env.pop();
    let inner_env = Environment::try_from(tos);
    println!("Animating: {:?}", inner_env);
    match inner_env {
        Ok(inner) =&gt; {
            tokio::spawn(async move { eval(inner).await });
            env.into()
        }
        Err(e) =&gt; env.push(e.into()).into(),
    }
}
fn xor_(i: Bytes, j: Bytes) -&gt; Bytes {
    let len = std::cmp::max(i.len(), j.len());
    let mut result = Vec::with_capacity(len);
    for (byte_i, byte_j) in i
        .iter()
        .chain(std::iter::repeat(&amp;0).take(len - i.len()))
        .zip(j.iter().chain(std::iter::repeat(&amp;0).take(len - j.len())))
    {
        result.push(byte_i ^ byte_j);
    }
    result
}
pub fn xor(i: Item, j: Item) -&gt; ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) =&gt; Ok(Item::Int(i ^ j)),
        (
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(i))),
            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(j))),
        ) =&gt; Ok(xor_(i, j).into()),
        (
            Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(i))),
            Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(j))),
        ) =&gt; Ok(xor_(i, j).into()),
        (i, j) =&gt; Err(Error::expected("integers", pair(i, j))),
    }
}

pub fn inspect(i: Item) -&gt; ItemResult {
    let s = format!("{:?}", i);
    Ok(Item::Dispenser(coll::Dispenser::Sized(
        coll::Sized::String(s),
    )))
}

pub fn timestamps(env: Environment) -&gt; Future&lt;Environment&gt; {
    env.push(Item::Dispenser(coll::Dispenser::Out(pipes::Out::Time)))
        .into()
}

pub fn standard(env: Environment) -&gt; Future&lt;Environment&gt; {
    env.push(Item::Dispenser(coll::Dispenser::Tunnel(
        pipes::Tunnel::Standard,
    )))
    .into()
}

pub fn set(i: Item) -&gt; ItemResult {
    coll::Set::try_from(i).map(|s| Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Set(s))))
}

pub fn compare(i: Item, j: Item) -&gt; ItemResult {
    let ki = assoc::KeyItem::try_from(i)?;
    let kj = assoc::KeyItem::try_from(j)?;
    match ki.partial_cmp(&amp;kj) {
        Some(std::cmp::Ordering::Less) =&gt; Ok("less".into()),
        Some(std::cmp::Ordering::Equal) =&gt; Ok("equal".into()),
        Some(std::cmp::Ordering::Greater) =&gt; Ok("greater".into()),
        None =&gt; Err(Error::expected("comparable", pair(ki.into(), kj.into()))),
    }
}

fn as_pair(i: Item) -&gt; Result&lt;(Item, assoc::KeyItem), Error&gt; {
    let mut i = coll::List::try_from(i)?;
    let im = i.make_mut();
    let j = im.pop_front().ok_or(Error::short_list(1))?;
    let k = im
        .pop_front()
        .ok_or(Error::short_list(2))
        .and_then(assoc::KeyItem::try_from)?;
    Ok((j, k))
}

pub fn sort_by_key(i: Item) -&gt; ItemResult {
    let mut l = coll::List::try_from(i)?;
    let it = l.inner().into_iter().map(as_pair);
    let mut it = it.collect::&lt;Result&lt;Vec&lt;(Item, assoc::KeyItem)&gt;, Error&gt;&gt;()?;
    it.sort_unstable_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
    Ok(coll::List::from_iter(it.into_iter().map(|(k, _)| k)).into())
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc5288a1" class="outline-4">
<h4 id="orgc5288a1"><span class="section-number-4">1.4.5.</span> Top level execution</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
We'll define the main module which reads input for the kcats
interpreter process, and prints output.
</p>

<p>
We'll also define how to run unit tests.
</p>
<div class="org-src-container">
<pre class="src src-rust">mod axiom;
mod crypto;
mod pipes;
mod serialize;
mod types;

use crate::types::{environment::Environment, error, *};
use std::io;
use std::io::{BufRead, Read};
use std::sync::Arc;
use tokio;

fn print_result(env: Environment) {
    if env.expression.is_empty() {
        println!("{}", serialize::emit_all(&amp;env.stack));
    } else {
        println!(
            "stack: {}\nexpression: {}",
            serialize::emit(&amp;Item::from(env.stack)),
            serialize::emit(&amp;Item::from(env.expression))
        )
    }
}

fn get_stdin() -&gt; String {
    let mut buf = String::new();
    for line in io::stdin().lock().lines() {
        buf.push_str(&amp;line.unwrap());
        buf.push('\n');
    }
    buf
}

// A function that takes a handle to stdin. It reads a length from
// stdin, then reads that many bytes and returns a string.
async fn read_input() -&gt; Option&lt;String&gt; {
    //spawn a thread to read from stdin
    //println!("Reading input");
    tokio::spawn(async move {
        let mut stdin = io::stdin().lock();
        let mut buf = String::new();
        if let Err(e) = stdin.read_line(&amp;mut buf) {
            println!("Error reading content length {:?}", e);
            return None;
        }
        // parse an integer from buf
        let read_len = buf.trim();
        //println!("Read length {}", read_len);
        let len = read_len.parse::&lt;usize&gt;().unwrap_or(0 as usize);
        if len == 0 {
            return None;
        }
        // read len bytes from stdin
        let mut buf = vec![0; len];
        stdin.read_exact(&amp;mut buf).unwrap();

        // convert the bytes to a string
        Some(String::from_utf8(buf).unwrap())
    })
    .await
    .unwrap()
}

async fn print(env: &amp;Environment) {
    let result = serialize::emit_all(&amp;env.stack);
    // first print the length of the result
    println!("{}\n{}", result.len(), result);
}

// a function that takes an env, and an input string. Parses the
// string, if it parses, returns the env with the input added to the
// expression. Otherwise returns Error.
fn parse_input(mut env: Environment, input: String) -&gt; Result&lt;Environment, error::Error&gt; {
    let mut parsed = serialize::parse(input)?;
    let expr = Arc::make_mut(&amp;mut env.expression);
    expr.extend(Arc::make_mut(&amp;mut parsed).drain(..));
    Ok(env)
}

//It converts the bytes to a
// string, and then evaluates that string as a kcats program. It then
// prints the length of the result, and then the result itself.
async fn interactive_mode() {
    let mut env = axiom::standard_env(None, None);

    loop {
        if let Some(program) = read_input().await {
            if let Ok(parsed_env) = parse_input(env, program) {
                //env = parsed_env;
                env = axiom::eval(parsed_env).await;
                print(&amp;env).await;
            } else {
                println!("Could not parse input");
                break;
            }
        } else {
            //println!("Blank input received, exiting");
            continue;
        }
    }
}

#[tokio::main]
async fn main() {
    // read command line options, to look for -i switch
    let args: Vec&lt;String&gt; = std::env::args().collect();
    // if args contains "-i", read via handle_stdin
    if args.contains(&amp;"-i".to_string()) {
        interactive_mode().await;
    } else {
        // otherwise, read from stdin
        match parse_input(axiom::standard_env(None, None), get_stdin()) {
            Ok(env) =&gt; {
                print_result(axiom::eval(env).await);
            }
            Err(e) =&gt; {
                println!("Error parsing input: {:?}", e);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::error::Error;
    use super::*;
    use crate::types::collection as coll;
    use internment::Intern;
    use std::borrow::Borrow;
    use test_case::test_case;
    use tokio;

    pub fn get_item(i: Item, index: usize) -&gt; Option&lt;Item&gt; {
        coll::List::try_from(i)
            .ok()
            .and_then(|l| match l.get(index) {
                Some(x) =&gt; Some(x.clone()),
                None =&gt; None,
            })
    }

    #[tokio::main]
    async fn test_example(
        mut prog_env: Environment,
        program: coll::List,
        expected: coll::List,
    ) -&gt; Option&lt;Error&gt; {
        let mut exp_env = prog_env.clone();
        prog_env = prog_env.append_expression(program.clone());
        exp_env = exp_env.append_expression(expected.clone());

        let p_fut = tokio::spawn(async move { axiom::eval(prog_env).await });

        let exp_fut = tokio::spawn(async move { axiom::eval(exp_env).await });
        let (prog_env, exp_env) = tokio::join!(p_fut, exp_fut);
        let prog_env = prog_env.unwrap();
        let exp_env = exp_env.unwrap();

        if prog_env.stack == exp_env.stack {
            println!(
                "Nice expected {} got {}",
                serialize::emit_all(exp_env.stack.borrow()),
                serialize::emit_all(prog_env.stack.borrow())
            );
            None
        } else {
            println!(
                "uh oh expected {} got {}",
                serialize::emit_all(exp_env.stack.borrow()),
                serialize::emit_all(prog_env.stack.borrow())
            );
            // println!(
            //     "Debug: expected {:?} got {:?}",
            //     exp_env.stack, prog_env.stack
            // );
            Some(Error::test_assertion(program, expected, prog_env.stack))
        }
    }

    fn test_word(standard_env: Environment, w: Word) -&gt; Vec&lt;Error&gt; {
        if let Some(d) = standard_env.dictionary.get(&amp;w) {
            d.examples
                .clone()
                .unwrap()
                .iter()
                .filter_map(|ex| {
                    match (
                        get_item(ex.clone(), 0).unwrap(),
                        get_item(ex.clone(), 1).unwrap(),
                    ) {
                        (
                            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(p))),
                            Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(exp))),
                        ) =&gt; test_example(standard_env.clone(), p.clone(), exp.clone()),
                        (i, _) =&gt; Some(Error::expected("list", i.into())),
                    }
                })
                .collect::&lt;Vec&lt;Error&gt;&gt;()
        } else {
            println!("Empty!");
            Vec::new()
        }
    }

    #[test_case("+" ; "plus")]
    #[test_case("-" ; "minus")]
    #[test_case("=" ; "eq")]
    #[test_case("&gt;" ; "gt")]
    #[test_case("&gt;=" ; "gte")]
    #[test_case("&lt;" ; "lt")]
    #[test_case("&lt;=" ; "lte")]
    #[test_case("*" ; "mult")]
    #[test_case("/" ; "divide")]
    #[test_case("abs")]
    #[test_case("and")]
    #[test_case("any?" ; "is_any")]
    #[test_case("assign")]
    #[test_case("association")]
    #[test_case("association?" ; "is_association")]
    #[test_case("bail")]
    #[test_case("both?" ; "is_both")]
    #[test_case("branch")]
    #[test_case("breaker")]
    #[test_case("bytes")]
    #[test_case("bytes?" ; "is_bytes")]
    #[test_case("ceil")]
    #[test_case("clone")]
    #[test_case("collect")]
    #[test_case("compare")]
    #[test_case("contains?" ; "contains")]
    #[test_case("count")]
    #[test_case("dec")]
    #[test_case("decide")]
    #[test_case("decorate")]
    #[test_case("decorated")]
    #[test_case("dip")]
    #[test_case("dipdown")]
    #[test_case("drop")]
    #[test_case("dropper")]
    #[test_case("each")]
    #[test_case("emit")]
    #[test_case("environment")]
    #[test_case("evaluate")]
    #[test_case("eval_step")]
    #[test_case("even?" ; "is_even")]
    #[test_case("evert")]
    #[test_case("every?" ; "is_every")]
    #[test_case("execute")]
    #[test_case("filter")]
    #[test_case("first")]
    #[test_case("float")]
    #[test_case("functional")]
    #[test_case("future")]
    #[test_case("generate")]
    #[test_case("if")]
    #[test_case("inc")]
    #[test_case("inject")]
    #[test_case("inscribe")]
    #[test_case("join")]
    #[test_case("joiner")]
    #[test_case("keep")]
    #[test_case("let")]
    #[test_case("lingo")]
    #[test_case("list?" ; "is_list")]
    #[test_case("lookup")]
    #[test_case("loop")]
    #[test_case("map")]
    #[test_case("max")]
    #[test_case("min")]
    #[test_case("mod")]
    #[test_case("not")]
    #[test_case("nothing?" ; "is_nothing")]
    #[test_case("number?" ; "is_number")]
    #[test_case("odd?" ; "is_odd")]
    #[test_case("or")]
    #[test_case("pop")]
    #[test_case("put")]
    #[test_case("prepend")]
    #[test_case("primrec")]
    #[test_case("range")]
    #[test_case("reduce")]
    #[test_case("recover")]
    #[test_case("recur")]
    #[test_case("rest")]
    #[test_case("retry")]
    #[test_case("reverse")]
    #[test_case("set")]
    #[test_case("set?" ; "is_set")]
    #[test_case("shield")]
    #[test_case("shielddown")]
    #[test_case("shielddowndown")]
    #[test_case("sink")]
    #[test_case("snapshot")]
    #[test_case("something?" ; "is_something")]
    #[test_case("sqrt")]
    #[test_case("step")]
    #[test_case("string")]
    #[test_case("string?" ; "is_string")]
    #[test_case("swap")]
    #[test_case("swapdown")]
    #[test_case("take")]
    #[test_case("taker")]
    #[test_case("times")]
    #[test_case("type")]
    #[test_case("unassign")]
    #[test_case("until")]
    #[test_case("unwrap")]
    #[test_case("update")]
    #[test_case("value")]
    #[test_case("while")]
    #[test_case("within?" ; "is_within")]
    #[test_case("word?")]
    #[test_case("wrap")]
    #[test_case("xor")]
    #[test_case("zero?" ; "is_zero")]
    #[test_case("zip")]
    fn test_lexicon(word: &amp;str) {
        let e = axiom::standard_env(None, None);

        let r = test_word(e.clone(), Intern::new(word.to_string()));
        assert!(r.is_empty(), "{:?}", r);
    }
}

// if let (Item::List(program), Item::List(expected)) = (program, expected) {

//     } else {
//         Err(Error::from("Example should be a pair"))
//     }

// for ex in d.examples().iter() {
//             let e = List::try_from(*ex).ok().unwrap();
//             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
//             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

//             test_example(axiom::standard_env.clone(), w, p,exp)
//         }.retain(|i| i.is_some()).collect::&lt;Vec&lt;Error&gt;&gt;()
</pre>
</div>
</div>
</div>
<div id="outline-container-org591aea7" class="outline-4">
<h4 id="org591aea7"><span class="section-number-4">1.4.6.</span> Pipes (input/output)</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
Kcats will confine all i/o to pipes. You can put values into pipes and
they emerge elsewhere. Words that act on pipes are the only ones that
can be impure. Everything else is a value.
</p>
</div>
<ol class="org-ol">
<li><a id="org0f67507"></a>Basic Types<br />
<div class="outline-text-6" id="text-1-4-6-0-1">
<p>
The basic pipe contracts.
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::types::collection as coll;
use crate::types::error::Error;
use crate::types::{self, Item};
use std::sync::Arc;
use tokio::sync::RwLock;

use futures::executor;
pub mod channel;
pub mod fs;
pub mod net;
pub mod standard;
pub mod time;

#[derive(Debug, Clone)]
pub enum In {
    StaticFile(Arc&lt;RwLock&lt;fs::StaticFile&gt;&gt;),
    Socket(Arc&lt;RwLock&lt;net::Socket&gt;&gt;),
    Handoff(channel::Handoff&lt;Item&gt;),
    Standard,
}

impl PartialEq for In {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (In::StaticFile(s1), In::StaticFile(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (In::Socket(s1), In::Socket(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (In::Handoff(h1), In::Handoff(h2)) =&gt; h1 == h2,
            _ =&gt; false,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Out {
    StaticFile(Arc&lt;RwLock&lt;fs::StaticFile&gt;&gt;),
    Socket(Arc&lt;RwLock&lt;net::Socket&gt;&gt;),
    ServerSocket(Arc&lt;RwLock&lt;net::ServerSocket&gt;&gt;),
    Handoff(channel::Handoff&lt;Item&gt;),
    Time,
    Standard,
}

impl PartialEq for Out {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (Out::StaticFile(s1), Out::StaticFile(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (Out::Socket(s1), Out::Socket(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (Out::ServerSocket(s1), Out::ServerSocket(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (Out::Handoff(h1), Out::Handoff(h2)) =&gt; h1 == h2,
            (Out::Time, Out::Time) =&gt; true,
            (Out::Standard, Out::Standard) =&gt; true,
            _ =&gt; false,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Tunnel {
    StaticFile(Arc&lt;RwLock&lt;fs::StaticFile&gt;&gt;),
    Socket(Arc&lt;RwLock&lt;net::Socket&gt;&gt;),
    Handoff(channel::Handoff&lt;Item&gt;),
    Standard,
}

impl PartialEq for Tunnel {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (Tunnel::StaticFile(s1), Tunnel::StaticFile(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (Tunnel::Socket(s1), Tunnel::Socket(s2)) =&gt; Arc::ptr_eq(s1, s2),
            (Tunnel::Handoff(h1), Tunnel::Handoff(h2)) =&gt; h1 == h2,
            (Tunnel::Standard, Tunnel::Standard) =&gt; true,
            _ =&gt; false,
        }
    }
}

impl From&lt;Tunnel&gt; for Out {
    fn from(t: Tunnel) -&gt; Self {
        match t {
            Tunnel::StaticFile(f) =&gt; Out::StaticFile(f),
            Tunnel::Socket(s) =&gt; Out::Socket(s),
            Tunnel::Handoff(h) =&gt; Out::Handoff(h),
            Tunnel::Standard =&gt; Out::Standard,
        }
    }
}

impl From&lt;Tunnel&gt; for In {
    fn from(t: Tunnel) -&gt; Self {
        match t {
            Tunnel::StaticFile(f) =&gt; In::StaticFile(f),
            Tunnel::Socket(s) =&gt; In::Socket(s),
            Tunnel::Handoff(h) =&gt; In::Handoff(h),
            Tunnel::Standard =&gt; In::Standard,
        }
    }
}

impl In {
    pub fn put(&amp;mut self, i: Item) -&gt; types::Future&lt;Result&lt;(), Error&gt;&gt; {
        match self {
            In::StaticFile(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.put(i).await })
            }
            In::Socket(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.put(i).await })
            }
            In::Handoff(ref mut h) =&gt; Box::pin(h.put(i)), //_ =&gt; Err(Error::expected("foo")),
            In::Standard =&gt; standard::put(i),
        }
    }
}

impl Tunnel {
    pub fn put(&amp;mut self, i: Item) -&gt; types::Future&lt;Result&lt;(), Error&gt;&gt; {
        match self {
            Tunnel::StaticFile(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.put(i).await })
            }
            Tunnel::Socket(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.put(i).await })
            }
            Tunnel::Handoff(ref mut h) =&gt; Box::pin(h.put(i)),
            Tunnel::Standard =&gt; standard::put(i),
        }
    }

    pub fn take(&amp;mut self) -&gt; types::Future&lt;Result&lt;Option&lt;Item&gt;, Error&gt;&gt; {
        match self {
            Tunnel::StaticFile(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.take().await })
            }
            Tunnel::Socket(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.take().await })
            }
            Tunnel::Handoff(ref mut h) =&gt; Box::pin(h.take()),
            Tunnel::Standard =&gt; standard::take(),
        }
    }
}

impl Out {
    pub fn take(&amp;mut self) -&gt; types::Future&lt;Result&lt;Option&lt;Item&gt;, Error&gt;&gt; {
        match self {
            Out::StaticFile(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.take().await })
            }
            Out::Socket(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.take().await })
            }
            Out::ServerSocket(f) =&gt; {
                let f = f.clone();
                Box::pin(async move { f.write().await.take().await })
            }
            Out::Handoff(ref mut h) =&gt; Box::pin(h.take()),
            Out::Time =&gt; Box::pin(time::take()),
            Out::Standard =&gt; standard::take(),
        }
    }
}

impl crate::serialize::Display for In {
    fn representation(&amp;self) -&gt; Item {
        match self {
            In::StaticFile(f) =&gt; executor::block_on(async move { f.read().await.representation() }),
            In::Socket(f) =&gt; executor::block_on(async move { f.read().await.representation() }),
            In::Handoff(h) =&gt; h.representation(),
            In::Standard =&gt; standard::representation(),
        }
    }
}

impl crate::serialize::Display for Out {
    fn representation(&amp;self) -&gt; Item {
        match self {
            Out::StaticFile(f) =&gt; {
                executor::block_on(async move { f.read().await.representation() })
            }
            Out::Socket(f) =&gt; executor::block_on(async move { f.read().await.representation() }),
            Out::ServerSocket(f) =&gt; {
                executor::block_on(async move { f.read().await.representation() })
            }
            Out::Handoff(h) =&gt; h.representation(),
            Out::Time =&gt; time::representation(),
            Out::Standard =&gt; standard::representation(),
        }
    }
}

impl crate::serialize::Display for Tunnel {
    fn representation(&amp;self) -&gt; Item {
        match self {
            Tunnel::StaticFile(f) =&gt; {
                executor::block_on(async move { f.read().await.representation() })
            }
            Tunnel::Socket(f) =&gt; executor::block_on(async move { f.read().await.representation() }),
            Tunnel::Handoff(h) =&gt; h.representation(),
            Tunnel::Standard =&gt; standard::representation(),
        }
    }
}
/* Pipes can be "closed", from either end to signal that either the
 * putter or taker has gone away. Sometimes the type of pipe
 * may not really support this concept but an implementation is
 * required.  For example, files. When you open a file for writing and
 * then "close" it, that doesn't really do anything. Rust doesn't have
 * an explicit file close. You have to drop the reference to it, which
 * in kcats you can do by popping the pipe off the stack. Rust will
 * clean up automatically, other impls might have to reference count.
 *
 * The contract here is as follows:
 * 1. After calling close, put on the pipe returns an error
 *
 * 2. After calling close, take on the pipe will return still-buffered
 * items (if the pipe has a buffer), but once buffer is exhausted it
 * will return error.
 *
 * 2. Errors cannot be put into a pipe (the taker can't distinguish
 * between io error and an error value). To work around this, wrap the
 * error value in a list to quote it. Putting error into a pipe will
 * return an io error.
 *
 * 3. Once closed pipes cannot be ever be put into again. closed? will always
 * return true thereafter.
 *
 * One use case that has to be handled specially is a file we've fully
 * read but later someone else might write more bytes to the end. Does
 * the pipe close when we reach EOF? I think we might need to support
 * both types (a type that closes when hitting eof and one that
 * doesn't). The former is the "normal" use case, which will be the
 * default.
 *
 * These two types are basically static vs dynamic content. Either all
 * the content is known now, or it isn't.
 *
*/

fn closed_error(on_take: bool) -&gt; Error {
    Error::create(
        coll::List::from_iter([
            Item::from("close"),
            if on_take { "take" } else { "put" }.into(),
        ]),
        "attempt to use closed pipe",
        None,
    )
}

impl From&lt;Tunnel&gt; for Item {
    fn from(t: Tunnel) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Tunnel(t))
    }
}

impl From&lt;Out&gt; for Item {
    fn from(t: Out) -&gt; Self {
        Item::Dispenser(coll::Dispenser::Out(t))
    }
}

impl From&lt;In&gt; for Item {
    fn from(t: In) -&gt; Self {
        Item::Receptacle(coll::Receptacle::In(t))
    }
}
</pre>
</div>
</div>
</li>
<li><a id="orge79f449"></a>Files<br />
<div class="outline-text-6" id="text-1-4-6-0-2">
<p>
How to interact with files on disk
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::axiom::ItemResult;
use crate::types::associative as assoc;
use crate::types::error::Error;
use crate::types::*;
use futures::Stream;
use std::future;
use std::pin::Pin;
use std::ptr;
use std::sync::Arc;
use std::task::{Context, Poll};
use tokio::fs::File;
use tokio::io::{AsyncRead, ReadBuf};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::sync::RwLock;

#[derive(Debug)]
pub struct StaticFile {
    pub file: File,
    pub path: String,
}

impl PartialEq for StaticFile {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // Check if the 'file' fields of both structs are the same by reference
        ptr::eq(&amp;self.file, &amp;other.file)
    }
}

impl StaticFile {
    pub fn put&lt;'a&gt;(
        &amp;'a mut self,
        i: Item,
    ) -&gt; Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;(), Error&gt;&gt; + Send + 'a&gt;&gt; {
        let b = Bytes::try_from(i);

        match b {
            Ok(bs) =&gt; Box::pin(async move { self.file.write_all(&amp;bs).await.map_err(|e| e.into()) }),
            Err(e) =&gt; Box::pin(future::ready(Err(e))),
        }
    }

    pub fn take&lt;'a&gt;(
        &amp;'a mut self,
    ) -&gt; Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;Option&lt;Item&gt;, Error&gt;&gt; + Send + 'a&gt;&gt; {
        let mut bs = [0u8; 1024];
        Box::pin(async move {
            let ct = self.file.read(&amp;mut bs).await?;
            if ct == 0 {
                // EOF, no more takes since it's static
                Ok(None)
            } else {
                Ok(Some(bs[0..ct].to_vec().into()))
            }
        })
    }
}

impl Stream for StaticFile {
    type Item = Result&lt;Item, Error&gt;;

    fn poll_next(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {
        let mut buf = vec![0u8; 1024];
        let mut read_buf = ReadBuf::new(&amp;mut buf);

        match Pin::new(&amp;mut self.file).poll_read(cx, &amp;mut read_buf) {
            Poll::Ready(Ok(())) =&gt; {
                let bytes_read = read_buf.filled().len();
                if bytes_read == 0 {
                    Poll::Ready(None)
                } else {
                    Poll::Ready(Some(Ok(read_buf.filled().to_owned().into())))
                }
            }
            Poll::Ready(Err(e)) =&gt; Poll::Ready(Some(Err(e.into()))),
            Poll::Pending =&gt; Poll::Pending,
        }
    }
}

impl crate::serialize::Display for StaticFile {
    fn representation(&amp;self) -&gt; Item {
        assoc::Association::from_iter([
            ("type".into(), "tunnel".into()),
            (
                "values".into(),
                assoc::Association::from_iter([("type".into(), "bytes".into())]).into(),
            ),
            (
                "to".into(),
                assoc::Association::from_iter([("file".into(), self.path.clone().into())]).into(),
            ),
        ])
        .into()
    }
}

pub fn file_in(i: Item) -&gt; ItemResult {
    let path = String::try_from(i)?;
    let file = std::fs::File::options()
        .read(true)
        .write(true)
        .create_new(true)
        .open(path.clone())?;
    Ok(super::In::StaticFile(Arc::new(RwLock::new(StaticFile {
        file: File::from_std(file),
        path,
    })))
    .into())
}

pub fn file_out(i: Item) -&gt; ItemResult {
    let path = String::try_from(i)?;
    let file = std::fs::File::open(path.clone())?;
    Ok(super::Out::StaticFile(Arc::new(RwLock::new(StaticFile {
        file: File::from_std(file),
        path,
    })))
    .into())
}

impl From&lt;StaticFile&gt; for Item {
    fn from(f: StaticFile) -&gt; Self {
        super::Out::StaticFile(Arc::new(RwLock::new(f))).into()
    }
}
</pre>
</div>
</div>
</li>
<li><a id="orgf4433bb"></a>Network<br />
<div class="outline-text-6" id="text-1-4-6-0-3">
<p>
How to interact with the network (TCP/IP sockets)
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::axiom::ItemResult;
use crate::types::associative as assoc;
use crate::types::error::Error;
use crate::types::{self, wrap, Int, Item};
use futures::future::FutureExt;
use std::future::{self};
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
use std::pin::Pin;
use std::ptr;
use std::str::FromStr;
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::RwLock;

#[derive(Debug)]
pub struct Socket {
    pub socket: TcpStream,
    pub addr: SocketAddr,
}

impl PartialEq for Socket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // Check if the 'socket' fields of both structs are the same by reference
        ptr::eq(&amp;self.socket, &amp;other.socket)
    }
}

impl Socket {
    pub fn put&lt;'a&gt;(
        &amp;'a mut self,
        i: Item,
    ) -&gt; Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;(), Error&gt;&gt; + Send + 'a&gt;&gt; {
        println!("Putting {:?}", i);
        let b = types::Bytes::try_from(i);
        match b {
            Ok(bs) =&gt; {
                Box::pin(async move { self.socket.write_all(&amp;bs).await.map_err(|e| e.into()) })
            }
            Err(e) =&gt; Box::pin(future::ready(Err(e))),
        }
    }

    pub fn take&lt;'a&gt;(
        &amp;'a mut self,
    ) -&gt; Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;Option&lt;Item&gt;, Error&gt;&gt; + Send + 'a&gt;&gt; {
        let mut bs = [0u8; 1024];
        Box::pin(async move {
            let n = self.socket.read(&amp;mut bs).await?;
            if n == 0 {
                Ok(None)
            } else {
                Ok(Some(bs[..n].to_vec().into()))
            }
        })
    }
}

impl crate::serialize::Display for Socket {
    fn representation(&amp;self) -&gt; Item {
        assoc::Association::from_iter([
            ("type".into(), "tunnel".into()),
            ("realm".into(), "tcp".into()),
            ("address".into(), self.addr.to_string().into()),
        ])
        .into()
    }
}

// Server sockets
#[derive(Debug)]
pub struct ServerSocket {
    pub socket: TcpListener,
}

impl PartialEq for ServerSocket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // Check if the 'socket' fields of both structs are the same by reference
        ptr::eq(&amp;self.socket, &amp;other.socket)
    }
}

impl ServerSocket {
    pub fn take&lt;'a&gt;(
        &amp;'a mut self,
    ) -&gt; Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;Option&lt;Item&gt;, Error&gt;&gt; + Send + 'a&gt;&gt; {
        Box::pin(async move {
            let (socket, addr) = self.socket.accept().await?;

            Ok(Some(
                super::Tunnel::Socket(Arc::new(RwLock::new(Socket { socket, addr }))).into(),
            ))
        })
    }
}

impl crate::serialize::Display for ServerSocket {
    fn representation(&amp;self) -&gt; Item {
        assoc::Association::from_iter([
            ("type".into(), "pipe".into()),
            (
                "serversocket".into(),
                "todo: fix serversocket local addr async issue".into(), //Item::String(self.socket.lock().await.local_addr().unwrap().to_string()),
            ),
        ])
        .into()
    }
}

fn socket_addr(i: Item, j: Item) -&gt; Result&lt;SocketAddrV4, Error&gt; {
    println!("socket: {:?} {:?}", i, j);
    let addr = Ipv4Addr::from_str(String::try_from(j)?.as_str())?;
    let port = Int::try_from(i)? as u16;
    Ok(SocketAddrV4::new(addr, port))
}

pub fn server_socket(i: Item, j: Item) -&gt; types::Future&lt;ItemResult&gt; {
    match socket_addr(i, j) {
        Ok(addr) =&gt; {
            Box::pin(TcpListener::bind(addr).map(|l| {
                Ok(super::Out::ServerSocket(Arc::new(RwLock::new(ServerSocket {
                    socket: l.unwrap(),
                })))
                .into())
            }))
        }
        Err(e) =&gt; Box::pin(future::ready(Err(e))),
    }
}

// pub fn server_socket(env: Environment) -&gt; environment::Future {
//     let addr = env.pop();

//     let inner_env = Environment::try_from(tos);
//     match inner_env {
//         Ok(inner) =&gt; Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),
//         Err(e) =&gt; env.push(Item::Error(e)).into(),
//     }
// }

impl From&lt;std::net::AddrParseError&gt; for Error {
    fn from(err: std::net::AddrParseError) -&gt; Error {
        Error::create(wrap("addrparse".into()), &amp;err.to_string(), None)
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org0d81194"></a>Time<br />
<div class="outline-text-6" id="text-1-4-6-0-4">
<div class="org-src-container">
<pre class="src src-rust">use crate::types::associative as assoc;
use crate::types::error::Error;
use crate::types::*;
use std::{
    future,
    time::{SystemTime, UNIX_EPOCH},
};

pub fn take() -&gt; Future&lt;Result&lt;Option&lt;Item&gt;, Error&gt;&gt; {
    let t = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as Int;
    Box::pin(future::ready(Ok(Some(Item::Int(t)))))
}

pub fn representation() -&gt; Item {
    assoc::Association::from_iter([
        ("type".into(), "out".into()),
        ("from".into(), "systemtime".into()),
        (
            "values".into(),
            assoc::Association::from_iter([
                ("type".into(), "integer".into()),
                ("units".into(), "milliseconds".into()),
            ])
            .into(),
        ),
    ])
    .into()
}
</pre>
</div>
</div>
</li>
<li><a id="orgd5755d4"></a>Standard in/out<br />
<div class="outline-text-6" id="text-1-4-6-0-5">
<div class="org-src-container">
<pre class="src src-rust">use crate::types::associative as assoc;
use crate::types::error::Error;
use crate::types::{self, *};
use std::future;
use std::io::{self, Read, Write};

pub fn take() -&gt; Future&lt;Result&lt;Option&lt;Item&gt;, Error&gt;&gt; {
    let mut buf = [0u8];
    let n = io::stdin().read(&amp;mut buf);
    let f = match n {
        Ok(0) =&gt; Ok(None),
        Ok(n) =&gt; Ok(Some(buf[..n].to_vec().into())),
        Err(e) =&gt; Err(e.into()),
    };
    Box::pin(future::ready(f))
}

pub fn put(i: Item) -&gt; types::Future&lt;Result&lt;(), Error&gt;&gt; {
    let bs = Bytes::try_from(i);
    match bs {
        Ok(bs) =&gt; {
            let f = io::stdout().write(&amp;bs);
            Box::pin(future::ready(f.map_err(|e| e.into()).map(|_| ())))
        }
        Err(e) =&gt; Box::pin(future::ready(Err(e))),
    }
}

pub fn representation() -&gt; Item {
    assoc::Association::from_iter([
        ("type".into(), "tunnel".into()),
        ("peer".into(), "standard".into()),
    ])
    .into()
}
</pre>
</div>
</div>
</li>
<li><a id="orgd15c7df"></a>Channels<br />
<div class="outline-text-6" id="text-1-4-6-0-6">
<p>
Implement the <code>handoff</code> type
</p>
<div class="org-src-container">
<pre class="src src-rust">use crate::pipes;
use crate::types::associative as assoc;
use crate::types::environment::Environment;
use crate::types::error::Error;
use crate::types::{self, Item};
use flume;
use std::future;
use std::ptr;

#[derive(Debug, Clone)]
// Use Option because we want to be able to drop senders/receivers to
// close the channel
pub struct Handoff&lt;T&gt; {
    pub receiver: Option&lt;flume::Receiver&lt;T&gt;&gt;,
    pub sender: Option&lt;flume::Sender&lt;T&gt;&gt;,
}

impl&lt;T&gt; PartialEq for Handoff&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // Check if the 'file' fields of both structs are the same by reference
        match (&amp;self.receiver, &amp;other.receiver, &amp;self.sender, &amp;other.sender) {
            (Some(sr), Some(or), Some(ss), Some(os)) =&gt; ptr::eq(&amp;sr, &amp;or) &amp;&amp; ptr::eq(&amp;ss, &amp;os),
            _ =&gt; false,
        }
    }
}

impl Handoff&lt;Item&gt; {
    pub fn new() -&gt; Handoff&lt;Item&gt; {
        let (sender, receiver) = flume::bounded::&lt;Item&gt;(0);
        Handoff::&lt;Item&gt; {
            sender: Some(sender),
            receiver: Some(receiver),
        }
    }

    pub fn put(&amp;mut self, i: Item) -&gt; types::Future&lt;Result&lt;(), Error&gt;&gt; {
        if let Some(ch) = self.sender.clone() {
            // Can't send and receive in the same channel in same thread
            if !self.receiver.is_none() {
                //println!("Dropping receiver");
                self.receiver = None;
            }
            Box::pin(async move {
                ch.send_async(i)
                    .await
                    .map_err(|_| pipes::closed_error(false))
            })
        } else {
            Box::pin(future::ready(Err(pipes::closed_error(false))))
        }
    }

    pub fn take(&amp;mut self) -&gt; types::Future&lt;Result&lt;Option&lt;Item&gt;, Error&gt;&gt; {
        if let Some(ch) = self.receiver.clone() {
            // Can't send and receive in the same channel in same thread
            if !self.sender.is_none() {
                //println!("Dropping sender");
                self.sender = None;
            }
            Box::pin(async move {
                //println!("Receiving");
                ch.recv_async().await.map(Some).or_else(|_| Ok(None))
            })
        } else {
            Box::pin(future::ready(Ok(None)))
        }
    }
}

impl crate::serialize::Display for Handoff&lt;Item&gt; {
    fn representation(&amp;self) -&gt; Item {
        assoc::Association::from_iter([
            ("type".into(), "pipe".into()),
            ("handoff".into(), "todo: id-or-hash here".into()),
        ])
        .into()
    }
}

pub fn handoff(env: Environment) -&gt; types::Future&lt;Environment&gt; {
    env.push(pipes::Tunnel::Handoff(Handoff::new()).into())
        .into()
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org32abe9f" class="outline-3">
<h3 id="org32abe9f"><span class="section-number-3">1.5.</span> Issues</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org8685e66" class="outline-4">
<h4 id="org8685e66"><span class="section-number-4">1.5.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
run with <code>kcats -i</code> for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
</p>
</div>
<div id="outline-container-org59deb3f" class="outline-5">
<h5 id="org59deb3f"><span class="section-number-5">1.5.1.1.</span> <span class="todo TODO">TODO</span> Only print the changed part of the stack</h5>
</div>
<div id="outline-container-orgf57e784" class="outline-5">
<h5 id="orgf57e784"><span class="section-number-5">1.5.1.2.</span> <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<ul class="org-ul">
<li>swap / swapdown</li>
<li>clear ([] evert drop)</li>
<li>clone</li>
<li>snapshot?</li>
<li>discard</li>
<li>sink / float</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcf5bdc9" class="outline-4">
<h4 id="orgcf5bdc9"><span class="section-number-4">1.5.2.</span> <span class="done DONE">DONE</span> Install the lexicon in the proper place</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in <code>/usr/share/kcats</code> or <code>~/.local/share/kcats</code> or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.
</p>
</div>
</div>

<div id="outline-container-org368e5e8" class="outline-4">
<h4 id="org368e5e8"><span class="section-number-4">1.5.3.</span> <span class="done CANCELED">CANCELED</span> Add option to read an alternative lexicon file</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
The builtins can stay inside the binary, but we should have a cmdline
option to start without the usual lexicon. Should probably add a word
'lexicon' to add a parsed object as the lexicon.
</p>
</div>
</div>
<div id="outline-container-org9a5698a" class="outline-4">
<h4 id="org9a5698a"><span class="section-number-4">1.5.4.</span> <span class="todo TODO">TODO</span> Package the binary for various platforms</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
</p>
</div>
</div>
<div id="outline-container-orgee59bc3" class="outline-4">
<h4 id="orgee59bc3"><span class="section-number-4">1.5.5.</span> <span class="done DONE">DONE</span> Optimize memory allocation</h4>
<div class="outline-text-4" id="text-1-5-5">
</div>
<div id="outline-container-org22ac4a9" class="outline-5">
<h5 id="org22ac4a9"><span class="section-number-5">1.5.5.1.</span> <span class="done DONE">DONE</span> Lists</h5>
<div class="outline-text-5" id="text-1-5-5-1">
<div class="org-src-container">
<pre class="src src-kcats">[[a b]] [a] lookup
</pre>
</div>

<pre class="example">
b
</pre>
</div>
</div>
</div>
<div id="outline-container-org62da342" class="outline-4">
<h4 id="org62da342"><span class="section-number-4">1.5.6.</span> <span class="done DONE">DONE</span> pack and unpack are not inverse</h4>
<div class="outline-text-4" id="text-1-5-6">
<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] unpack pack
</pre>
</div>

<pre class="example">

[[2 3 1]]
</pre>


<p>
It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.
</p>

<p>
Solution: rename to put take
</p>
</div>
</div>
<div id="outline-container-orgaf74919" class="outline-4">
<h4 id="orgaf74919"><span class="section-number-4">1.5.7.</span> <span class="done DONE">DONE</span> true and false are not words?</h4>
<div class="outline-text-4" id="text-1-5-7">
<div class="org-src-container">
<pre class="src src-kcats">[<span style="font-weight: bold;">true</span>] <span style="font-weight: bold;">unwrap</span> word?
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span style="font-weight: bold;">true</span>
</pre>
</div>

<p>
If you didn't know <code>true</code> was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).
</p>

<p>
It's messy because true/false are the only "words" you can put onto
the stack without wrapping.
</p>

<p>
There are several ways to deal with this:
</p>

<ul class="org-ul">
<li>just leave as is (these look like words but don't act like them)</li>

<li>Use something else for boolean values, like 0b 1b or something (ugly, no)</li>

<li>Revert to allowing bare words (that aren't actions) to go onto the
stack unwrapped, so that true/false aren't different</li>
</ul>

<p>
Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.
</p>
</div>
</div>
<div id="outline-container-orgab28aca" class="outline-4">
<h4 id="orgab28aca"><span class="section-number-4">1.5.8.</span> <span class="done DONE">DONE</span> Division by zero panics</h4>
</div>
<div id="outline-container-org454563e" class="outline-4">
<h4 id="org454563e"><span class="section-number-4">1.5.9.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-9">
</div>
<div id="outline-container-orgcd91184" class="outline-5">
<h5 id="orgcd91184"><span class="section-number-5">1.5.9.1.</span> <span class="done DONE">DONE</span> Write to a file</h5>
<div class="outline-text-5" id="text-1-5-9-1">
<div class="org-src-container">
<pre class="src src-kcats">[[file <span style="font-style: italic;">"/tmp/bar4"</span>]] pipe-in

[<span style="font-style: italic;">"hello world!"</span>
 <span style="font-style: italic;">"Nice to meet you!"</span>
 <span style="font-style: italic;">"My name is kcats"</span>]

[<span style="font-style: italic;">"\n"</span> <span style="font-weight: bold;">join</span> bytes <span style="font-weight: bold;">put</span>]

<span style="font-weight: bold;">step</span>
</pre>
</div>

<pre class="example">
[[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[file <span style="font-style: italic;">"/tmp/bar101r7"</span>]] pipe-in

<span style="font-style: italic;">"hello world!"</span>

bytes <span style="font-weight: bold;">put</span>

</pre>
</div>

<pre class="example">
[[type pipe] [file "/tmp/bar101r7"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[file <span style="font-style: italic;">"/tmp/bar101r7"</span>]] pipe-out

<span style="font-weight: bold;">take</span>

string

</pre>
</div>

<pre class="example">
"hello world!" [[type pipe] [file "/tmp/bar101r7"]]
</pre>
</div>
</div>

<div id="outline-container-org926b9fd" class="outline-5">
<h5 id="org926b9fd"><span class="section-number-5">1.5.9.2.</span> <span class="done DONE">DONE</span> Read from a file</h5>
<div class="outline-text-5" id="text-1-5-9-2">
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">""</span> [string <span style="font-weight: bold;">join</span>] [[file <span style="font-style: italic;">"/tmp/bar2"</span>]] pipe-out

collect 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
stack: [[[reason <span style="font-style: italic;">"type mismatch"</span>] [asked [pipe]] [type error]] [[file <span style="font-style: italic;">"/tmp/bar2"</span>] [type pipe]] <span style="font-style: italic;">""</span>]
expression: [<span style="font-weight: bold;">swap</span> [string <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> [closed? not] <span style="font-weight: bold;">shield</span> [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> [string <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> [closed? not] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">loop</span> discard]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [collect spec] lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
[[[type error] [reason <span style="font-style: italic;">"word is not defined"</span>] [asked [fail]]]
 <span style="font-style: italic;">"Lookup attempted on non association value"</span>
 [spec]
 [[definition [<span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> [[closed? not]] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">while</span> discard]]
  [spec [[pipe program] [item]]]]]
</pre>
</div>
</div>
</div>
<div id="outline-container-org10c9a66" class="outline-5">
<h5 id="org10c9a66"><span class="section-number-5">1.5.9.3.</span> <span class="done DONE">DONE</span> Close a pipe</h5>
<div class="outline-text-5" id="text-1-5-9-3">
<div class="org-src-container">
<pre class="src src-kcats">[[file <span style="font-style: italic;">"/tmp/foopytoop"</span>]] pipe-in <span style="font-style: italic;">"foo"</span> bytes <span style="font-weight: bold;">put</span> close <span style="font-style: italic;">"bar"</span> bytes <span style="font-weight: bold;">put</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[type pipe] [file <span style="font-style: italic;">"/tmp/foopytoop"</span>]]
</pre>
</div>
</div>
</div>
<div id="outline-container-org796493c" class="outline-5">
<h5 id="org796493c"><span class="section-number-5">1.5.9.4.</span> <span class="done DONE">DONE</span> Serialize pipes with something sane</h5>
<div class="outline-text-5" id="text-1-5-9-4">
<p>
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
</p>
</div>
</div>
<div id="outline-container-org9a22f87" class="outline-5">
<h5 id="org9a22f87"><span class="section-number-5">1.5.9.5.</span> <span class="done DONE">DONE</span> Sockets</h5>
<div class="outline-text-5" id="text-1-5-9-5">
</div>
<ol class="org-ol">
<li><a id="org5e3ee6c"></a><span class="done DONE">DONE</span> Server Sockets<br />
<div class="outline-text-6" id="text-1-5-9-5-1">
<div class="org-src-container">
<pre class="src src-kcats">[[type ip-port] [address <span style="font-style: italic;">"127.0.0.1"</span>] [port 11211]] pipe-out 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(11211) String(<span style="font-style: italic;">"127.0.0.1"</span>)
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"127.0.0.1"</span> 12345 serversocket 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(12345) String(<span style="font-style: italic;">"127.0.0.1"</span>)
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[type ip-port] [address <span style="font-style: italic;">"127.0.0.1"</span>] [port 11211]] pipe-out <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">server socket</span>
<span style="font-weight: bold;">take</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">accept connection by taking a socket out of the pipe</span>
<span style="font-style: italic;">"foo\n"</span> bytes <span style="font-weight: bold;">put</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">write a message to the socket</span>
<span style="font-weight: bold;">take</span> string <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">get a message from the socket</span>
[discard <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">close the socket</span>
 discard] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">close the server socket</span>
<span style="font-weight: bold;">dip</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[asked [string]] [unwound [<span style="font-weight: bold;">take</span> <span style="font-style: italic;">"foo\n"</span> bytes <span style="font-weight: bold;">put</span> <span style="font-weight: bold;">take</span> string [discard discard] <span style="font-weight: bold;">dip</span>]] [type error] [reason <span style="font-style: italic;">"type mismatch"</span>]]
</pre>
</div>
</div>
</li>

<li><a id="org2add3b4"></a><span class="done DONE">DONE</span> Sockets<br /></li>

<li><a id="orgcd8a3dc"></a><span class="todo INPROGRESS">INPROGRESS</span> Assemble is broken when reading files<br />
<div class="outline-text-6" id="text-1-5-9-5-3">
<p>
I think it's because <code>closed?</code> is broken.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">""</span> [string <span style="font-weight: bold;">join</span>] [[file <span style="font-style: italic;">"bar"</span>]] pipe-out assemble
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">""</span> [string <span style="font-weight: bold;">join</span>] [[file <span style="font-style: italic;">"bar"</span>]] pipe-out <span style="font-weight: bold;">take</span> discard <span style="font-weight: bold;">take</span> discard closed? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">checking file closed <span style="font-weight: bold;">false</span>
Got 3 bytes
checking file closed <span style="font-weight: bold;">false</span>
Got 0 bytes
Closing!
checking file closed <span style="font-weight: bold;">false</span>
[] [string <span style="font-weight: bold;">join</span>] <span style="font-style: italic;">""</span>
</pre>
</div>

<p>
I see the problem. When we clone the pipe, we also clone the <code>closed</code>
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc&lt;Mutex&gt; and not just the
file field. And when we modify the boolean, we shouldn't 
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org2322074" class="outline-5">
<h5 id="org2322074"><span class="section-number-5">1.5.9.6.</span> <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</h5>
<div class="outline-text-5" id="text-1-5-9-6">
<p>
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.
</p>

<p>
I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.
</p>
</div>
</div>

<div id="outline-container-org5a52409" class="outline-5">
<h5 id="org5a52409"><span class="section-number-5">1.5.9.7.</span> <span class="todo TODO">TODO</span> Composable transforms</h5>
<div class="outline-text-5" id="text-1-5-9-7">
<p>
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.
</p>

<p>
I suppose pump could take an optional transducer-like thing, and <b>those</b>
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.
</p>

<p>
Maybe the first thing to do is implement transducers?
</p>
</div>
</div>

<div id="outline-container-org40b0b92" class="outline-5">
<h5 id="org40b0b92"><span class="section-number-5">1.5.9.8.</span> <span class="done CANCELED">CANCELED</span> Filled pipes</h5>
<div class="outline-text-5" id="text-1-5-9-8">
<p>
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] filled <span style="font-weight: bold;">take</span>
</pre>
</div>

<pre class="example">
1 [[type pipe] [filled todo: id-or-hash here]]
</pre>
</div>
</div>

<div id="outline-container-org8598e47" class="outline-5">
<h5 id="org8598e47"><span class="section-number-5">1.5.9.9.</span> <span class="todo TODO">TODO</span> Object pipes</h5>
<div class="outline-text-5" id="text-1-5-9-9">
<p>
These pipes should send serialized kcats objects and each put/take
should transfer 1 object. Maybe use protocol buffers or similar
</p>

<p>
This could be done using a network pipe, and an assemble function that
pulls byte chunks and builds objects when there are enough bytes for
one object, and puts them into a handoff pipe.
</p>

<p>
This should be possible to do entirely in kcats.
</p>
</div>
</div>

<div id="outline-container-org02e7858" class="outline-5">
<h5 id="org02e7858"><span class="section-number-5">1.5.9.10.</span> <span class="done DONE">DONE</span> Time pipe</h5>
<div class="outline-text-5" id="text-1-5-9-10">
<p>
Each take from the pipe return the current unix time in ms.  Should be
a "singleton" - probably using Box::leak, so that we can insert a copy
of this pipe whenever we want and it's always a reference to the same
object. Might be an Arc for compatibility even though we don't need to
ref count. (But I suspect we don't need the Arc).
</p>

<div class="org-src-container">
<pre class="src src-kcats">timestamps <span style="font-weight: bold;">take</span>
</pre>
</div>

<pre class="example">
1687273991929 [[from systemtime] [values [[type integer] [units milliseconds]]] [type out]]
</pre>
</div>
</div>

<div id="outline-container-org88cb6d3" class="outline-5">
<h5 id="org88cb6d3"><span class="section-number-5">1.5.9.11.</span> <span class="done DONE">DONE</span> stdin/stdout pipes</h5>
<div class="outline-text-5" id="text-1-5-9-11">
<p>
Should also be singleton. Should it always be a tunnel or should we
allow separate access to in or out?
</p>

<div class="org-src-container">
<pre class="src src-kcats">standard <span style="font-style: italic;">"foo"</span> bytes <span style="font-weight: bold;">put</span>
</pre>
</div>

<pre class="example">
foo[[type tunnel] [peer standard]]
</pre>


<p>
Stdin is not tested, since currently the interpreter reads the program
from stdin. May need to change that (read the program from filesystem
and let the program itself access stdin).
</p>
</div>
</div>
<div id="outline-container-org7f1e368" class="outline-5">
<h5 id="org7f1e368"><span class="section-number-5">1.5.9.12.</span> <span class="todo TODO">TODO</span> Pipe take outcome</h5>
<div class="outline-text-5" id="text-1-5-9-12">
<p>
There is some inconsistency with what happens when there's nothing
left - empty lists just return nothing on take, but closed pipes
return an error. May need to resolve this inconsistency.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">List</th>
<th scope="col" class="org-left">Handoff</th>
<th scope="col" class="org-left">Socket</th>
<th scope="col" class="org-left">StaticFile</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">take Items</td>
<td class="org-left">Item</td>
<td class="org-left">Item</td>
<td class="org-left">Bytes</td>
<td class="org-left">Bytes</td>
</tr>

<tr>
<td class="org-left">take Past EOF</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
</tr>

<tr>
<td class="org-left">step Past EOF</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org1fd7540" class="outline-4">
<h4 id="org1fd7540"><span class="section-number-4">1.5.10.</span> <span class="done DONE">DONE</span> 'Fail' is not defined</h4>
<div class="outline-text-4" id="text-1-5-10">
<p>
We need to be able to throw our own errors (eg lookup tries to do this)
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 2 [1 <span style="font-style: italic;">"two"</span> +] [fail] recover 3 4 
</pre>
</div>

<pre class="example">
converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
[[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1
</pre>
</div>
</div>

<div id="outline-container-orge8d7c76" class="outline-4">
<h4 id="orge8d7c76"><span class="section-number-4">1.5.11.</span> <span class="done DONE">DONE</span> 'dictionary' doesn't allow access to the data inside definitions</h4>
<div class="outline-text-4" id="text-1-5-11">
<p>
The definition is just shown as the word itself and we can't access
spec, definition etc.
</p>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [<span style="font-weight: bold;">swap</span> spec] lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[[item a] [item b]] [[item b] [item a]]]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf53fe4" class="outline-4">
<h4 id="orgcf53fe4"><span class="section-number-4">1.5.12.</span> <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-12">
<p>
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.
</p>

<p>
Here we use the association shorthand for <code>[[type bytes]]</code>
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> [bytes] derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [bytes] "foo"]
</pre>


<p>
Here's a typical invocation
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> [[type bytes]] derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [[type bytes]] "foo"]
</pre>


<p>
Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span>
[[bytes]
 [[type aes-key]
  [length 128]]]
[derive]
<span style="font-weight: bold;">step</span>
</pre>
</div>

<pre class="example">
No spec for derive!
No spec for derive!

[[] [[type aes-key] [length 128]] [] [bytes] "foo"]
</pre>


<p>
This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.
</p>

<p>
The difficulty is how to implement it. A naive way would just make
<code>derive</code> a multimethod and add lots of methods. The problem is the
<code>decide</code> based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use <code>decide</code> internally).
</p>

<p>
But maybe even that isn't ideal - we could also lookup by <code>[sourcetype
destinationtype]</code> pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.
</p>

<p>
It should be possible to implement the <code>destinationtype</code> based lookup
pretty easily. Make <code>derive</code> a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).
</p>

<p>
Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
</p>
<div class="org-src-container">
<pre class="src src-kcats">[derive]
[[[bytes string] [string]]] association <span style="font-weight: bold;">wrap</span>
[<span style="font-weight: bold;">float</span> type <span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">1 [string] =&gt; [number string]</span>
 lookup <span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">join</span>
[definition] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span>
<span style="font-weight: bold;">wrap</span>
inscribe

<span style="font-style: italic;">"foo"</span> bytes [string] 
derive 
</pre>
</div>

<pre class="example">
No spec for derive!

stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
expression: [lookup execute]
</pre>



<p>
Ok here's the basic impl. Afterward, should change <code>string</code> to
<code>++string</code> to make them non-public, should use <code>[string] derive</code>
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like <code>derivations</code>, but that
sticks out as different - it's a data structure and not an action
word.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">add some conversions</span>
derivations [[bytes string] [string]] assign
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the list of conversions</span>
[[[bytes string] [string]]] association

<span style="font-style: italic;">"foo"</span> bytes [string]


<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">determine the current type and look up the conversion</span>
[[type] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dipdown</span> [<span style="font-weight: bold;">join</span> <span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dip</span> 
<span style="font-weight: bold;">swap</span> lookup <span style="font-weight: bold;">execute</span>
</pre>
</div>

<pre class="example">

["foo"]
</pre>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [assign spec] lookup 
</pre>
</div>

<pre class="example">

[[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[[a b] c]] [[a b]] lookup
</pre>
</div>

<pre class="example">

[c]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[string [foo]]] [string] lookup
</pre>
</div>
<pre class="example">

[[foo]]
</pre>


<p>
Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
</p>
<div class="org-src-container">
<pre class="src src-kcats">[+] <span style="font-weight: bold;">unwrap</span> type
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
[[[reason <span style="font-style: italic;">"type mismatch"</span>] [type error] [unwound [<span style="font-weight: bold;">count</span> 1 = [[+]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">first</span> [[[<span style="font-weight: bold;">first</span> [type] <span style="font-weight: bold;">unwrap</span> =] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">second</span>] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">first</span>] <span style="font-weight: bold;">if</span>] [[]]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">branch</span> [[[[<span style="font-weight: bold;">count</span> 1 =] [[<span style="font-weight: bold;">first</span> [type] <span style="font-weight: bold;">unwrap</span> =] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">second</span>] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">first</span>] <span style="font-weight: bold;">if</span>] [[]] <span style="font-weight: bold;">if</span>] +]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">first</span> <span style="font-weight: bold;">swap</span> discard [[[[association] <span style="font-weight: bold;">unwrap</span>]]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">swap</span> [[]] <span style="font-weight: bold;">unwrap</span> or [[[[<span style="font-weight: bold;">nothing</span>?] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> [or] <span style="font-weight: bold;">shielddown</span>] [] [[<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> [[<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">shielddown</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">dip</span> or] [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">recur</span>] <span style="font-weight: bold;">execute</span> <span style="font-weight: bold;">swap</span> discard <span style="font-weight: bold;">swap</span> discard]] [asked [list]]] +]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[] [] [] [discard [default] <span style="font-weight: bold;">unwrap</span>] <span style="font-weight: bold;">if</span>
</pre>
</div>

<pre class="example">

[default]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[bar 12]]
[
[[foo] lookup]
[[bar] lookup]
[5]
[6]
]
<span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">nothing</span>?] <span style="font-weight: bold;">shield</span>
[[<span style="font-weight: bold;">take</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">execute</span> [<span style="font-weight: bold;">nothing</span>?] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">loop</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">sink discard discard</span>
</pre>
</div>

<pre class="example">

[[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[bar 12]]
[[[foo] lookup]
 [[bar] lookup]]
[<span style="font-weight: bold;">execute</span>] any?
</pre>
</div>

<pre class="example">

[12 [[bar 12]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 or
</pre>
</div>

<pre class="example">

[1]
</pre>


<p>
Now that we have a fairly reliable <code>type</code> implementation, we can
dispatch on both <code>to</code> and <code>from</code> types for <code>derive</code>.
</p>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org5a5bd92" class="outline-4">
<h4 id="org5a5bd92"><span class="section-number-4">1.5.13.</span> <span class="done DONE">DONE</span> Change boolean operators to retain values</h4>
<div class="outline-text-4" id="text-1-5-13">
<p>
<code>or</code> and <code>and</code> should return the actual value if it is truthy, instead
of <code>true</code>. But neither should ever return <code>[]</code>, but use <code>false</code>
instead.
</p>
<div class="org-src-container">
<pre class="src src-kcats">2 [] or
</pre>
</div>

<pre class="example">
2
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 10 inc 1 range <span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> [*] <span style="font-weight: bold;">step</span>
</pre>
</div>

<pre class="example">
3628800
</pre>


<p>
This does bring up the question of whether the boolean type is really
needed. It may be possible to use <code>[]</code> as <code>false</code> and anything else as
<code>true</code> (<code>1</code> for example, or maybe the bare word <code>true</code> which then
wouldn't carry any other meaning). Or possible use some other word
than <code>true</code>, eg <code>something</code>.
</p>

<p>
Does this make sense when applied to boolean logic?
</p>

<pre class="example" id="org0ae8d61">
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
</pre>

<p>
I think it doesn't make sense.
</p>

<p>
Maybe yes/no?
</p>

<pre class="example" id="org80392d3">
yes or no = yes ?
</pre>
<div class="org-src-container">
<pre class="src src-kcats">5 3 =
</pre>
</div>

<pre class="example">

[[]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">5 [[[3 =] [<span style="font-style: italic;">"three"</span>]]
                         [[5 =] [<span style="font-style: italic;">"five"</span>]]
                         [[7 =] [<span style="font-style: italic;">"seven"</span>]]
                         [[<span style="font-weight: bold;">true</span>] [<span style="font-style: italic;">"something else"</span>]]]
                      decide
</pre>
</div>

<pre class="example">

["five" 5]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[3 5 7] [even?] any? <span style="font-weight: bold;">false</span> =
</pre>
</div>

<pre class="example">

stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
expression: [false =]
</pre>
</div>
</div>
<div id="outline-container-org3a052f5" class="outline-4">
<h4 id="org3a052f5"><span class="section-number-4">1.5.14.</span> <span class="done DONE">DONE</span> 'recover' is broken</h4>
<div class="outline-text-4" id="text-1-5-14">
<div class="org-src-container">
<pre class="src src-kcats">[+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
</pre>
</div>

<pre class="example">

[3]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[expression [[+] [3] recover]]] environment advance advance
eval-<span style="font-weight: bold;">step</span>
advance
advance
advance
advance
advance
eval-<span style="font-weight: bold;">step</span>
advance
advance
advance
</pre>
</div>

<pre class="example">
Env: [List([List([])]), Word(0x5a56c7a6c3c0 : "unwrap"), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield"), List([Entry(Entry { word: 0x5a56c7a7ddf0 : "take", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a7ddf0 : "take")]), List([List([String("b"), String("c")]), String("a")])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([Entry(Entry { word: 0x5a56c7a73c80 : "++lookup", examples: None, spec: Some([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x5a56c7a668b0 : "dip", examples: Some([List([List([Int(1), Int(8), List([Word(0x5a56c7a570f0 : "inc")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(2), Int(8)])]), List([List([Int(1), Int(2), List([Word(0x5a56c7a621b0 : "dec")]), Word(0x5a56c7a6c3c0 : "unwrap"), List([Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(3), Word(0x5a56c7a621b0 : "dec")])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program"), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield")]), Word(0x5a56c7a79bd0 : "loop"), List([Word(0x5a56c7a65c40 : "something?")]), List([String("Lookup attempted on non association value"), Entry(Entry { word: 0x5a56c7a55850 : "fail", examples: None, spec: Some([List([Word(0x5a56c7a66340 : "string")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: [] })]), List([Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a89c10 : "if"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Env({ stack: [], expression: [[+] [3] recover] })])]), Word(0x5a56c7a6c3c0 : "unwrap"), Entry(Entry { word: 0x5a56c7a7bf60 : "evert", examples: Some([List([List([Int(1), Int(2), Int(3), List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a7bf60 : "evert")]), List([Int(6), Int(5), Int(4), List([Int(3), Int(2), Int(1)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list"), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a88e20 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a88e20 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "&lt;=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
handle is Word(0x5a56c7a5eab0 : "handle") Word(0x5a56c7a5eab0 : "handle")
expr contains handle? false
unhandled err!

stack: [[[type error] [asked [association (unfinished tryfrom impl)]] [reason "type mismatch"]]]
expression: [[[]] unwrap [[[swap association?] [something?]] [execute] every?] shield [take swap [++lookup] dip [[[swap association?] [something?]] [execute] every?] shield] loop [something?] ["Lookup attempted on non association value" fail] [discard] if count [[[[stack []] [expression [[+] [3] recover]]]]] unwrap evert first swap [[[[expression] lookup count [[positive?] [&lt;=]] [execute] every?] [[errored?] shield not]] [execute] every?] [eval-step] while swap discard advance eval-step advance advance advance advance advance eval-step advance advance advance]
</pre>
</div>
</div>
<div id="outline-container-org7c5c127" class="outline-4">
<h4 id="org7c5c127"><span class="section-number-4">1.5.15.</span> <span class="done DONE">DONE</span> Fix handle in nested env</h4>
<div class="outline-text-4" id="text-1-5-15">
<p>
<code>handle</code> doesn't work properly in a nested environment. That is
because <code>eval</code> has some logic to check for uncaught exceptions, but
the <code>advance</code> self-hosted evaluator doesn't.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 + handle error?
</pre>
</div>

<pre class="example">
Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
expr contains handle? true
Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")

[true 1]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">+ handle type
</pre>
</div>

<pre class="example" id="orgda75e50">
Env: [Word(0x577eb3e95b00 : "handle"), Entry(Entry { word: 0x577eb3ea5000 : "type", examples: Some([List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Int(1)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Float(1.0)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([])]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo"), Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo")]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20780 : "attr"), String("blah")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3f20570 : "attr1"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20640 : "attr2"), String("blah")])]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3f202d0 : "url")]), List([Word(0x577eb3edb6e0 : "value"), String("http://foo.com")])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3f202d0 : "url")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? true
Word(0x577eb3e95b00 : "handle") vs Word(0x577eb3e95b00 : "handle")
Env: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? false
unhandled err!

stack: [[[reason "not enough items on stack"] [asked [consume]] [type error]]]
expression: [[[[nothing?] [[nothing] unwrap]] [[association?] [[[[type] lookup] [[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[association] unwrap]] [execute] any?]] [[list?] [[list] unwrap]] [[number?] [[number] unwrap]] [[word?] [[word] unwrap]] [[bytes?] [[bytes] unwrap]] [[string?] [[string] unwrap]] [[pipe?] [[pipe] unwrap]] [[error?] [[error] unwrap]]] decide swap discard]
</pre>

<p>
Looks like the word <code>error?</code> is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
<code>type</code>, which expects the builtin version of <code>error?</code>).
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[expression [+]]] environment eval-<span style="font-weight: bold;">step</span> 
</pre>
</div>

<pre class="example">

[[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [expression []]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[expression [1 +]]] environment advance advance advance 
</pre>
</div>

<pre class="example">

[[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [expression [+]]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[expression [[[3]] [+ handle] <span style="font-weight: bold;">dip</span>]]] environment advance advance advance
</pre>
</div>

<pre class="example">

[[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [expression [+_handle [[[3]]] unwrap]]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[[expression [+ handle]]] environment eval-<span style="font-weight: bold;">step</span> eval-<span style="font-weight: bold;">step</span>
</pre>
</div>

<pre class="example">
{ stack: [], expression: [[[expression [+ handle]]] environment eval-step eval-step] }
{ stack: [[[expression [+ handle]]]], expression: [environment eval-step eval-step] }
{ stack: [[[stack []] [expression [+ handle]]]], expression: [eval-step eval-step] }
{ stack: [], expression: [+ handle] }
{ stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]], expression: [eval-step] }
{ stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], expression: [+ handle] }

[[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]]
</pre>


<p>
There is a problem in the design where an error (with no <code>handle</code>) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.
</p>

<p>
A possible solution is to have whatever <code>eval</code> we're using halt but
remove the <code>halt</code> bit (in the current design it's the <code>is_handled</code>
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.
</p>

<p>
Also for nested envs we need several words to help deal with errors:
</p>

<ul class="org-ul">
<li>a word that tells whether the env will halt: that there's an error
on ToS with halt bit set, and <code>handle</code> does not appear in the
expression. The word can efficiently return <code>false</code> if ToS isn't an
Error.</li>

<li>A word that removes the halt bit - as the last thing to do before
exiting.</li>
</ul>

<p>
So what about the word <code>advance</code> that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In <code>eval</code> it's pretty obvious if we
halted on error - the expression isn't empty (that's the only other
reason to stop). We could see in <code>advance</code> that the expression got
longer, but isn't very obvious in many cases.
</p>

<p>
Another possibility is letting the expression unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
<code>recover</code> is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the expression that will know what to do. But
there may not be, and the end result is a major unwind of the
expression, at least, all the way to the deepest <code>recover</code>. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 
</p>

<p>
But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong <b>and</b>
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.
</p>

<p>
Maybe another possibility is unwinding the expression <b><b>into</b></b> the
error object. In other words, whatever expression items we lop off, we
save them in the error object, in a field named, say, <code>unwound</code> or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
expression from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
<code>rewind</code> or something, that restores the expression from the error on
ToS and clears the halt bit.
</p>

<p>
I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the expression item that threw the error so
we would still have it to retry. I'm thinking syntax like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[+] [[1 1] <span style="font-weight: bold;">dip</span> retry] recover
</pre>
</div>

<p>
In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [expression [[1 1] <span style="font-weight: bold;">dip</span> retry]]]]
</pre>
</div>

<p>
So we <code>dip</code> the numbers underneath the error, then calling <code>retry</code> on
an error will extract the <code>unwound</code> field (discarding the rest of the
error) and <code>execute</code> it. So then we end up with <code>1 1 +</code>.
</p>

<p>
Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">there needs to be 3 numbers here to add/mult but we forgot!</span>
+ * 1 2 3
handle <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">catch the error here, stack is empty except the error</span>
[5 6 7] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">put numbers underneath</span>
retry <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">rerun what failed before</span>
</pre>
</div>

<pre class="example">

[3 2 1 65]
</pre>


<p>
Now put it together using the higher-level <code>recover</code>
</p>

<div class="org-src-container">
<pre class="src src-kcats">[+ *] [[5 6 7] <span style="font-weight: bold;">dip</span> retry] recover
</pre>
</div>

<pre class="example">

[65]
</pre>
</div>
</div>

<div id="outline-container-org641acdc" class="outline-4">
<h4 id="org641acdc"><span class="section-number-4">1.5.16.</span> <span class="done DONE">DONE</span> Lots of association-like objects that aren't</h4>
<div class="outline-text-4" id="text-1-5-16">
<p>
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait <b>and</b> make the trait object part of the
Item enum.
</p>

<div class="org-src-container">
<pre class="src src-rust">trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box&lt;dyn Foo&gt;), Quux(Quux) }
</pre>
</div>

<p>
Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.
</p>

<div class="org-src-container">
<pre class="src src-rust">trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar&lt;'a&gt; { Int(i32), Foo(&amp;'a dyn Foo), Quux(&amp;'a Quux) }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [advance definition] lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
[[[[expression] lookup <span style="font-weight: bold;">count</span>] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">swap</span> [[expression] lookup <span style="font-weight: bold;">count</span> [[positive?] [&lt;=]] [<span style="font-weight: bold;">execute</span>] every?] [eval-<span style="font-weight: bold;">step</span>] <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">swap</span> discard]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[expression [1 1 +]]] environment eval-<span style="font-weight: bold;">step</span> [stack] lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[1]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[] environment association?
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span style="font-weight: bold;">true</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [fail] lookup
</pre>
</div>

<pre class="example">
[[spec [[string] [*]]] [definition []]]
</pre>
</div>
</div>

<div id="outline-container-orgd7195fd" class="outline-4">
<h4 id="orgd7195fd"><span class="section-number-4">1.5.17.</span> <span class="done DONE">DONE</span> scoping of dictionary entries</h4>
<div class="outline-text-4" id="text-1-5-17">
<p>
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
<code>inscribe</code> (to add words) etc.
</p>

<p>
However I think a better design would be something like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[add1 [1 +]]] [3 add1] augment
</pre>
</div>

<p>
Where the word <code>augment</code> takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.
</p>

<p>
It would be possible to nest calls to <code>augment</code> (where the program has
its own call to <code>augment</code>).
</p>

<p>
As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with <code>augment</code>.
</p>

<p>
There is some overlap in functionality here, between <code>decide</code> and
<code>augment</code> - both are designed to provide context. Maybe <code>decide</code> provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And <code>augment</code> provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where <code>join</code>
is just a common use case. In that case, maybe <code>augment</code> isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like <code>babel</code> - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like <code>lingo</code>.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[<span style="font-weight: bold;">clone</span> *] [square] assign] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">operate on the dictionary - add word 'square'</span>
[3 square]
lingo
</pre>
</div>

<p>
would print 9.
</p>

<p>
The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.
</p>

<p>
Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting <b>that</b> word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. <code>update</code> should help.
</p>
</div>
<div id="outline-container-org2731a05" class="outline-5">
<h5 id="org2731a05"><span class="section-number-5">1.5.17.1.</span> What to call this word</h5>
<div class="outline-text-5" id="text-1-5-17-1">
<ul class="org-ul">
<li>learn (but unlearn after?)</li>
<li>specialize</li>
<li>extend</li>
<li>adapt</li>
<li>augment</li>
<li>refine</li>
<li>supplement</li>
<li>babel</li>
<li>lingo &lt;= front runner.</li>
</ul>
</div>
</div>
<div id="outline-container-org8ef945f" class="outline-5">
<h5 id="org8ef945f"><span class="section-number-5">1.5.17.2.</span> Implementation</h5>
<div class="outline-text-5" id="text-1-5-17-2">
<p>
It seems viable that we could use the stack to hold dictionary changes.
</p>

<p>
We'd have to retain a copy of the original dictionary to restore later.
</p>

<p>
An axiom word like <code>definitions</code> or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.
</p>

<p>
it'd be something like:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[square] [[definition [<span style="font-weight: bold;">clone</span> *]]
          <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">[word square]</span>
           [spec [[number] [number]]]] assign]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">ops-dict</span>
[9 square]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">program-to-run</span>
dictionary <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">fetch the dictionary</span>
<span style="font-weight: bold;">sink</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">p o d</span>
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">p o d d</span>
[<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n=new-dict p n d</span>
<span style="font-weight: bold;">float</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">d p n</span>
<span style="font-weight: bold;">swapdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">d n p</span>
[redefine <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">p</span>
 <span style="font-weight: bold;">execute</span>]
<span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">d</span>
redefine
</pre>
</div>

<pre class="example">
81
</pre>


<p>
A few problems remaining above:
</p>
<ul class="org-ul">
<li class="on"><code>[X]</code> Need to specify the word inside the definition.</li>
<li class="on"><code>[X]</code> Need to explicitly convert the definition to an association.</li>
</ul>

<p>
But I think this proves the concept.
</p>

<p>
Probably want to eventually make a rust implementation.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[square] [[definition [<span style="font-weight: bold;">clone</span> *]]
          <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">[word square]</span>
           [spec [[number] [number]]]] assign]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">ops-dict</span>
[9 square]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">program-to-run</span>
dictionary <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">fetch the dictionary</span>
<span style="font-weight: bold;">sink</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">p o d</span>
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">p o d d</span>
[<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n=new-dict p n d</span>
<span style="font-weight: bold;">float</span>
<span style="font-weight: bold;">swapdown</span>
[redefine] <span style="font-weight: bold;">dip</span> dictionary [square] lookup

</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[square] [[definition [<span style="font-weight: bold;">clone</span> *]]
          <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">[word square]</span>
           [spec [[number] [number]]]] assign]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">ops-dict</span>
[9 square]<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">program-to-run</span>
lingo 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary [square] [[definition [<span style="font-weight: bold;">clone</span> *]]
                     [spec [[number] [number]]]] assign
[square] lookup
</pre>
</div>

<pre class="example">
Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
[]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf5ddf4" class="outline-4">
<h4 id="orgdf5ddf4"><span class="section-number-4">1.5.18.</span> <span class="done DONE">DONE</span> Move environment stuff into own module</h4>
<div class="outline-text-4" id="text-1-5-18">
<div class="org-src-container">
<pre class="src src-kcats">[[expression [1 2 3]]] environment 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">{ stack: [], expression: [[[expression [1 2 3]]] environment] }
{ stack: [[[expression [1 2 3]]]], expression: [environment] }

[[[stack []] [expression [1 2 3]]]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 2 +
</pre>
</div>

<pre class="example">

[3]
</pre>
</div>
</div>

<div id="outline-container-orgdfe78b9" class="outline-4">
<h4 id="orgdfe78b9"><span class="section-number-4">1.5.19.</span> <span class="done DONE">DONE</span> When printing results, don't wrap the stack</h4>
<div class="outline-text-4" id="text-1-5-19">
<p>
Evaling <code>1 1 +</code> should print <code>2</code>, not <code>[2]</code>. We don't have to wrap the
input, so why wrap the output.
</p>
</div>
</div>

<div id="outline-container-org8afa6d4" class="outline-4">
<h4 id="org8afa6d4"><span class="section-number-4">1.5.20.</span> <span class="done DONE">DONE</span> Update pipes to use enums instead of traits</h4>
<div class="outline-text-4" id="text-1-5-20">
<p>
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.
</p>

<p>
Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.
</p>
</div>
</div>

<div id="outline-container-org6087a95" class="outline-4">
<h4 id="org6087a95"><span class="section-number-4">1.5.21.</span> <span class="done CANCELED">CANCELED</span> Recover clears the stack built up in the try program</h4>
<div class="outline-text-4" id="text-1-5-21">
<div class="org-src-container">
<pre class="src src-kcats">[2 3 <span style="font-style: italic;">"four"</span> * +] [] recover
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[reason <span style="font-style: italic;">"type mismatch"</span>] [unwound [* +]] [type error] [asked [number]]]
</pre>
</div>

<p>
Apparently this was my design. I am not so sure about it now, that we
have <code>retry</code>. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of <code>retry</code> because the recovery
can't pick up where the program left off.
</p>

<p>
Maybe <code>recover</code> and <code>retry</code> are mutually exclusive.
</p>

<p>
We could also use <code>retry</code> with <code>handle</code>:
</p>

<div class="org-src-container">
<pre class="src src-kcats">2 3 <span style="font-style: italic;">"four"</span> * + handle [discard 4] <span style="font-weight: bold;">dip</span> retry
</pre>
</div>

<pre class="example">
14
</pre>


<p>
To make this work you have to know which item is the potential problem.
</p>

<p>
Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[2 3 [<span style="font-style: italic;">"four"</span> 4] alternates * +] retry 
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b86e78" class="outline-4">
<h4 id="org0b86e78"><span class="section-number-4">1.5.22.</span> <span class="done DONE">DONE</span> List access and update by index</h4>
<div class="outline-text-4" id="text-1-5-22">
<p>
I think re-using <code>lookup</code> and <code>assign</code> for lists, using their index, makes sense here:
</p>
<div class="org-src-container">
<pre class="src src-kcats">[5 10 15 20] [1] lookup
</pre>
</div>
<p>
should print 10.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[5 10 15 20] [1] 30 assign
</pre>
</div>

<pre class="example">
[5 30 15 20]
</pre>


<p>
would leave <code>[5 30 15 20]</code>.
</p>

<p>
The problem here is that this is ambiguous:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[a b] [c d]] [0] [d e] assign

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">is it (assigned as a hashmap by key)</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[[a b] [c d] [0 [d e]]]</span>

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">or is it (assigned as a vector by index)</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[[d e] [c d]]</span>
</pre>
</div>

<pre class="example">
[[d e] [c d]]
</pre>


<p>
We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify <code>association</code>
first.
</p>

<p>
lets check some corner cases - creating nested lists
</p>
<div class="org-src-container">
<pre class="src src-kcats">  [1 2 3] [1 0 0] <span style="font-style: italic;">"foo"</span> assign
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">should be [1 [[foo]] 3]</span>
</pre>
</div>

<pre class="example">
[1 [["foo"]] 3]
</pre>


<p>
What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with <code>Nothing</code>, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] [1 2] <span style="font-style: italic;">"foo"</span> assign
</pre>
</div>

<pre class="example">
[1 [[] [] "foo"] 3]
</pre>


<p>
Now let's test mixed list/assoc
</p>

<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] [1 foo baz 0] <span style="font-style: italic;">"bar"</span> assign
</pre>
</div>

<pre class="example">
[1 [[foo [[baz [[0 "bar"]]]]]] 3]
</pre>


<p>
Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.
</p>

<p>
Now check the changes for <code>lookup</code>
</p>

<div class="org-src-container">
<pre class="src src-kcats">[1 4 [34 6 45] 99 23] [2 2] lookup
</pre>
</div>

<pre class="example">
45
</pre>


<p>
make sure update works too
</p>

<div class="org-src-container">
<pre class="src src-kcats">[1 4 [34 6 45] 99 23] [2 2] [inc] update
</pre>
</div>

<pre class="example">
[1 4 [34 6 46] 99 23]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold;">true</span> not
</pre>
</div>

<pre class="example">
[]
</pre>
</div>
</div>

<div id="outline-container-orge9b4234" class="outline-4">
<h4 id="orge9b4234"><span class="section-number-4">1.5.23.</span> <span class="done DONE">DONE</span> write 'let'</h4>
<div class="outline-text-4" id="text-1-5-23">
<div class="org-src-container">
<pre class="src src-kcats">[[a [1 1 1]]
 [b [6 7 *]]]
[a b +]
[<span style="font-weight: bold;">wrap</span>
 [[[1] [<span style="font-weight: bold;">shield</span>
        <span style="font-weight: bold;">wrap</span>
        [[[spec [[] [item]]]]
         [definition]] <span style="font-weight: bold;">dip</span>
        assign] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">build a full entry</span>
   update]
  <span style="font-weight: bold;">map</span> association <span style="font-weight: bold;">join</span>]
 <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span>
lingo
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">43
</pre>
</div>

<p>
i am not sure if just taking the top value is correct here.
</p>


<div class="org-src-container">
<pre class="src src-kcats">dictionary
[[a [1 1 1]]
 [b [6 7 *]]]
[[1] [<span style="font-weight: bold;">shield</span>] update] <span style="font-weight: bold;">map</span> association <span style="font-weight: bold;">join</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[reason <span style="font-style: italic;">"type mismatch"</span>] [type error] [unwound [lingo]] [asked [program]]] [a b +] [[- [[examples [[[2 1 -] [1]] [[1.1 2.2 -] [-1.1]] [[2.2 1 -] [1.2]]]] [spec [[number number] [number]]]]] [read [[spec [[string] [item]]] [examples [[[<span style="font-style: italic;">"[1 [2] 3]"</span> read] [[1 [2] 3]]]]]]] [<span style="font-weight: bold;">first</span> [[spec [[list] [item]]] [examples [[[[4 5 6] <span style="font-weight: bold;">first</span>] [4]]]]]] [close [[spec [[[pipe p]] [[pipe p]]]]]] [<span style="font-weight: bold;">if</span> [[definition [[<span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold;">branch</span>]] [spec [[[program <span style="font-weight: bold;">false</span>-<span style="font-weight: bold;">branch</span>] [program <span style="font-weight: bold;">true</span>-<span style="font-weight: bold;">branch</span>] [program condition]] [*]]] [examples [[[5 [5 =] [3 *] [4 +] <span style="font-weight: bold;">if</span>] [15]] [[6 [5 =] [3 *] [4 +] <span style="font-weight: bold;">if</span>] [10]]]]]] [assemble [[definition [<span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> [[closed? not]] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">while</span> discard]] [spec [[pipe program] [item]]]]] [<span style="font-weight: bold;">dip</span> [[examples [[[1 8 [inc] <span style="font-weight: bold;">dip</span>] [2 8]] [[1 2 [dec] <span style="font-weight: bold;">unwrap</span> [+] <span style="font-weight: bold;">dip</span>] [3 dec]]]] [spec [[program [item a]] [[item a] *]]]]] [<span style="font-weight: bold;">nothing</span>? [[examples [[[[] <span style="font-weight: bold;">nothing</span>?] [<span style="font-weight: bold;">true</span>]] [[1 <span style="font-weight: bold;">nothing</span>?] [<span style="font-weight: bold;">false</span>]] [[<span style="font-weight: bold;">false</span> <span style="font-weight: bold;">nothing</span>?] [<span style="font-weight: bold;">false</span>]]]] [spec [[item] [boolean]]] [definition [[] =]]]] [sqrt [[spec [[number] [number]]]]] [lookup [[examples [[[[[a b] [c d]] [a] lookup] [[b] <span style="font-weight: bold;">unwrap</span>]] [[[[a b] [c d]] [e] lookup] [[]]] [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] <span style="font-weight: bold;">unwrap</span>]]]] [spec [[[list keys] list] [item]]] [definition [[[[<span style="font-weight: bold;">swap</span> list?] [something?]] [<span style="font-weight: bold;">execute</span>] every?] [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> [++lookup] <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">while</span> [something?] [[[type error] [asked [association]] [reason <span style="font-style: italic;">"Lookup attempted on non-associative value"</span>]] fail] [discard] <span style="font-weight: bold;">if</span>]]]] [filled [[spec [[list] [pipe]]] [definition []]]] [assign [[spec [[[item value] [list keys] association] [association]]] [examples [[[[[a b] [c d]] [a] 5 assign] [[[a 5] [c d]] association]] [[[[a b] [c d]] [e] 5 assign] [[[a b] [c d] [e 5]] association]] [[[[a b] [c [[d e]]]] [c d] 5 assign] [[[a b] [c [[d 5]]]] association]] [[[[a b] [c [[d e]]]] [1 0] 5 assign] [[[a b] [c [5]]]]] [[[1 2 3] [1 0 0] <span style="font-style: italic;">"foo"</span> assign] [[1 [[<span style="font-style: italic;">"foo"</span>]] 3]]] [[[1 2 3] [1 2] <span style="font-style: italic;">"foo"</span> assign] [[1 [[] [] <span style="font-style: italic;">"foo"</span>] 3]]] [[[1 2 3] [1 foo baz 0] <span style="font-style: italic;">"bar"</span> assign] [[1 [[foo [[baz [[0 <span style="font-style: italic;">"bar"</span>]]]]]] 3]]]]]]] [pipe-out [[spec [[item] [pipe]]] [definition [[[[type [file] <span style="font-weight: bold;">unwrap</span> =] [value file-out]] [[type [ip-port] <span style="font-weight: bold;">unwrap</span> =] [<span style="font-weight: bold;">clone</span> [address] lookup [[port] lookup] <span style="font-weight: bold;">dip</span> serversocket]] [[list?] [+kcats.pipe/-&gt;filled]]] decide]]]] [association [[spec [[item] [association]]] [examples [[[[[a b] [c d]] association [[c d] [a b]] association =] [<span style="font-weight: bold;">true</span>]] [[[[a b] [c d]] [[c d] [a b]] association =] [<span style="font-weight: bold;">false</span>]] [[[[a b] [c d]] [[a b] [c d]] association =] [<span style="font-weight: bold;">false</span>]]]]]] [<span style="font-weight: bold;">shield</span> [[definition [[<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">inject</span> <span style="font-weight: bold;">first</span>]] [examples [[[1 2 3 [=] <span style="font-weight: bold;">shield</span>] [1 2 3 <span style="font-weight: bold;">false</span>]]]] [spec [[program] [item]]]]] [&lt; [[spec [[number number] [boolean]]]]] [pair [[examples [[[1 2 pair] [[1 2]]] [[[<span style="font-style: italic;">"hi"</span>] [<span style="font-style: italic;">"there"</span> <span style="font-style: italic;">"foo"</span>] pair] [[[<span style="font-style: italic;">"hi"</span>] [<span style="font-style: italic;">"there"</span> <span style="font-style: italic;">"foo"</span>]]]]]] [spec [[item item] [list]]] [definition [[<span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">put</span>]]]] [buffer [[spec [[integer] [pipe]]] [definition []]]] [<span style="font-weight: bold;">swapdown</span> [[examples [[[1 2 3 <span style="font-weight: bold;">swapdown</span>] [2 1 3]]]] [spec [[[item a] [item b] [item c]] [[item a] [item c] [item b]]]]]] [string [[examples [[[1 string] [<span style="font-style: italic;">"1"</span>]] [[[1 2 3] string] [<span style="font-style: italic;">"[1 2 3]"</span>]] [[[] string] [<span style="font-style: italic;">"[]"</span>]]]] [spec [[item] [string]]]]] [eval-<span style="font-weight: bold;">step</span> [[examples [[[[[expression [1 inc]]] environment eval-<span style="font-weight: bold;">step</span> eval-<span style="font-weight: bold;">step</span> [stack] lookup] [[2]]]]] [spec [[list] [list]]]]] [<span style="font-weight: bold;">inject</span> [[examples [[[1 2 3 [4 5 6] [* +] <span style="font-weight: bold;">inject</span>] [1 2 3 [26]]]]] [definition [<span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">take</span> <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">evert</span>]] [spec [[program list] [list]]]]] [association? [[spec [[item] [boolean]]] [examples [[[[[a b] [c d]] association?] [<span style="font-weight: bold;">true</span>]]]]]] [b 42] [serversocket [[spec [[string integer] [pipe]]]]] [every? [[spec [[program list] boolean]] [definition [[<span style="font-weight: bold;">shielddown</span>] <span style="font-weight: bold;">swap</span> prepend [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> not] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">dip</span> or] <span style="font-weight: bold;">join</span> [[] [[[<span style="font-weight: bold;">nothing</span>?] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> [or] <span style="font-weight: bold;">shielddown</span>] [not]] <span style="font-weight: bold;">dip</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">recur</span> <span style="font-weight: bold;">swap</span> discard]] [examples [[[[2 4 6] [even?] every?] [<span style="font-weight: bold;">true</span>]] [[[2 4 5] [even?] every?] [<span style="font-weight: bold;">false</span>]] [[[] [even?] every?] [<span style="font-weight: bold;">true</span>]] [[[2 4 6] [] every?] [<span style="font-weight: bold;">true</span>]] [[11 [2 4 6] [+ odd?] every?] [<span style="font-weight: bold;">true</span> 11]] [[12 [[even?] [positive?] [3 rem 0 =]] [<span style="font-weight: bold;">execute</span>] every?] [<span style="font-weight: bold;">true</span> 12]]]]]] [both? [[definition [<span style="font-weight: bold;">sink</span> pair <span style="font-weight: bold;">swap</span> every?]] [examples [[[1 2 [odd?] both?] [<span style="font-weight: bold;">false</span>]] [[1 3 [odd?] both?] [<span style="font-weight: bold;">true</span>]]]] [spec [[program item item] [boolean]]]]] [<span style="font-weight: bold;">filter</span> [[definition [[<span style="font-weight: bold;">snapshot</span> [] <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">dipdown</span> [[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swapdown</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">join</span> <span style="font-weight: bold;">inject</span> <span style="font-weight: bold;">first</span> [[<span style="font-weight: bold;">put</span>]] [[discard]] <span style="font-weight: bold;">branch</span> <span style="font-weight: bold;">swapdown</span> <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">step</span> discard]] [examples [[[[1 2 3] [odd?] <span style="font-weight: bold;">filter</span>] [[1 3]]] [[[2 4 6] [odd?] <span style="font-weight: bold;">filter</span>] [[]]] [[33 [1 2 3] [+ odd?] <span style="font-weight: bold;">filter</span>] [[2] 33]]]] [spec [[program list] [list]]]]] [file-in [[spec [[string] [pipe]]]]] [shielddowndown [[definition [<span style="font-weight: bold;">shield</span> [discard discard] <span style="font-weight: bold;">dip</span>]] [spec [[[program p] [item consumed] [item consumed]] [[item result]]]] [examples [[[1 2 3 [+ +] shielddowndown] [1 6]]]]]] [<span style="font-weight: bold;">snapshot</span> [[examples [[[1 2 3 <span style="font-weight: bold;">snapshot</span>] [1 2 3 [3 2 1]]] [[<span style="font-weight: bold;">snapshot</span>] [[]]]]] [spec [[] [list]]] [definition [[] <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">unwrap</span>]]]] [* [[spec [[number number] [number]]]]] [dictionary [[spec [[] [list]]]]] [word? [[examples [[[foo word?] [<span style="font-weight: bold;">true</span>]] [[[foo] <span style="font-weight: bold;">unwrap</span> word?] [<span style="font-weight: bold;">true</span>]] [[<span style="font-weight: bold;">true</span> word?] [<span style="font-weight: bold;">false</span>]]]] [spec [[item] [boolean]]]]] [<span style="font-weight: bold;">put</span> [[spec [[item [pipe in]] [[pipe in]]]]]] [max [[spec [[number number] [number]]] [definition []]]] [positive? [[spec [[number] [boolean]]] [definition [0 &gt;]]]] [<span style="font-weight: bold;">float</span> [[examples [[[1 2 3 <span style="font-weight: bold;">float</span>] [2 3 1]]]] [spec [[[item a] [item b] [item c]] [[item c] [item a] [item b]]]]]] [zip [[examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]] [spec [[[list values] [list keys]] [association]]] [definition [[[]] <span style="font-weight: bold;">dipdown</span> [[<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">put</span> <span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">step</span> discard]]]] [quot [[definition []] [spec [[number number] [number]]]]] [<span style="font-weight: bold;">reverse</span> [[spec [[list] [list]]] [examples [[[[1 2 3] <span style="font-weight: bold;">reverse</span>] [[3 2 1]]]]]]] [string? [[examples [[[<span style="font-style: italic;">"hi"</span> string?] [<span style="font-weight: bold;">true</span>]] [[<span style="font-style: italic;">""</span> string?] [<span style="font-weight: bold;">true</span>]] [[[<span style="font-style: italic;">"hi"</span>] string?] [<span style="font-weight: bold;">false</span>]] [[<span style="font-weight: bold;">true</span> string?] [<span style="font-weight: bold;">false</span>]]]] [spec [[item] [boolean]]]]] [disassemble [[definition [[<span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> [<span style="font-weight: bold;">nothing</span>? not] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">while</span> discard]] [spec [[program item [pipe in]] [[pipe in]]]]]] [<span style="font-weight: bold;">step</span> [[examples [[[1 [2 3 4] [*] <span style="font-weight: bold;">step</span>] [24]] [[1 [] [*] <span style="font-weight: bold;">step</span>] [1]]]] [spec [[program list] [*]]]]] [<span style="font-weight: bold;">wrap</span> [[examples [[[1 <span style="font-weight: bold;">wrap</span>] [[1]]] [[[1 2] <span style="font-weight: bold;">wrap</span>] [[[1 2]]]]]] [spec [[item] [list]]]]] [&gt; [[spec [[number number] [boolean]]] [examples [[[2 1 &gt;] [<span style="font-weight: bold;">true</span>]] [[1.1 2.2 &gt;] [<span style="font-weight: bold;">false</span>]] [[2.2 1 &gt;] [<span style="font-weight: bold;">true</span>]]]]]] [zero? [[spec [[number] [boolean]]] [definition [0 =]] [examples [[[0 zero?] [<span style="font-weight: bold;">true</span>]] [[0 zero?] [<span style="font-weight: bold;">true</span>]] [[-0.00001 zero?] [<span style="font-weight: bold;">false</span>]] [[1.1 zero?] [<span style="font-weight: bold;">false</span>]]]]]] [addmethod [[spec [[[pair condition] [program combinator] word] []]] [definition [<span style="font-weight: bold;">float</span> [<span style="font-weight: bold;">wrap</span> dictionary <span style="font-weight: bold;">swap</span> lookup] <span style="font-weight: bold;">shield</span> [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold;">float</span> [<span style="font-weight: bold;">float</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">inject</span> <span style="font-weight: bold;">swap</span> inscribe]]]] [lingo [[definition [dictionary <span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dipdown</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">float</span> <span style="font-weight: bold;">swapdown</span> [redefine <span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> redefine]] [examples [[[[[square] [[definition [<span style="font-weight: bold;">clone</span> *]] [spec [[number] [number]]]] assign] [9 square] lingo] [81]]]] [spec [[[program enriched-lexicon] [program dictionary-modifier]] [*]]]]] [redefine [[spec [[association] []]]]] [unassign [[spec [[[item key] association] [association]]] [examples [[[[[a b] [c d]] [a] <span style="font-weight: bold;">unwrap</span> unassign] [[[c d]] association]] [[[[a b] [c d]] [e] <span style="font-weight: bold;">unwrap</span> unassign] [[[a b] [c d]] association]]]]]] [<span style="font-weight: bold;">swap</span> [[examples [[[1 2 3 <span style="font-weight: bold;">swap</span>] [1 3 2]]]] [spec [[[item a] [item b]] [[item b] [item a]]]]]] [prepend [[spec [[item list] [list]]] [examples [[[[1 2] 3 prepend] [[3 1 2]]]]] [definition [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span>]]]] [spawn [[spec [[program] []]] [definition []]]] [<span style="font-weight: bold;">recur</span> [[spec [[[program rec2] [program rec1] [program <span style="font-weight: bold;">true</span>-<span style="font-weight: bold;">branch</span>] [program pred]] [*]]] [examples [[[3 [1 &lt;=] [] [<span style="font-weight: bold;">clone</span> dec] [<span style="font-weight: bold;">execute</span> *] <span style="font-weight: bold;">recur</span>] [6]]]]]] [closed? [[spec [[pipe] [boolean]]]]] [<span style="font-weight: bold;">sink</span> [[spec [[[item a] [item b] [item c]] [[item b] [item c] [item a]]]] [examples [[[1 2 3 <span style="font-weight: bold;">sink</span>] [3 1 2]]]]]] [negative? [[spec [[number] [boolean]]] [definition [0 &lt;]]]] [evaluate [[examples [[[[[expression [1 2 3 4 + *]]] environment evaluate [stack] lookup] [[14 1]]]]] [spec [[list] [list]]]]] [not [[examples [[[1 even? not] [<span style="font-weight: bold;">true</span>]] [[<span style="font-weight: bold;">false</span> not] [<span style="font-weight: bold;">true</span>]] [[<span style="font-weight: bold;">true</span> not] [<span style="font-weight: bold;">false</span>]] [[[] not] [<span style="font-weight: bold;">true</span>]]]] [spec [[item] [boolean]]]]] [timeout [[definition []] [spec [[integer] [pipe]]]]] [environment [[examples [[[[[expression [1 2 3]]] environment eval-<span style="font-weight: bold;">step</span> [stack] lookup] [[1]]]]] [spec [[association] [list]]]]] [bytes? [[spec [[item] [boolean]]]]] [update [[examples [[[[[a 1] [b 2]] [b] [inc] update] [[[a 1] [b 3]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update] [[[a [[c 4] [d 5]]] [b 2]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update] [[[a [[c 15] [d 5]]] [b 2]] association]] [[[[a 1] [b 2]] [d] [5] update] [[[a 1] [b 2] [d 5]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update] [[[a [[c 3] [d 5] [e 11]]] [b 2]] association]]]] [definition [[[lookup] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">shielddown</span> assign]] [spec [[program [list keys] association] [association]]]]] [tunnel [[definition [[[[type [ip-port] <span style="font-weight: bold;">unwrap</span> =] [<span style="font-weight: bold;">clone</span> [port] lookup [[address] lookup] <span style="font-weight: bold;">dip</span> !**java.net.Socket.]]] decide]] [spec [[item] [pipe]]]]] [number? [[spec [[item] [boolean]]] [examples [[[[1] number?] [<span style="font-weight: bold;">false</span>]] [[[] number?] [<span style="font-weight: bold;">false</span>]] [[5 number?] [<span style="font-weight: bold;">true</span>]] [[5.01 number?] [<span style="font-weight: bold;">true</span>]]]]]] [<span style="font-weight: bold;">loop</span> [[spec [[program [item flag]] [*]]] [examples [[[10 <span style="font-weight: bold;">true</span> [-2 * <span style="font-weight: bold;">clone</span> 50 &lt;] <span style="font-weight: bold;">loop</span>] [160]]]]]] [select [[definition []] [spec [[[list pipes]] [item pipe [list pipes]]]]]] [<span style="font-weight: bold;">evert</span> [[spec [[list] [list *]]] [examples [[[1 2 3 [4 5 6] <span style="font-weight: bold;">evert</span>] [6 5 4 [3 2 1]]]]]]] [advance [[spec [[environment] [environment]]] [definition [[[expression] lookup <span style="font-weight: bold;">count</span>] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">swap</span> [[expression] lookup <span style="font-weight: bold;">count</span> [[positive?] [&lt;=]] [<span style="font-weight: bold;">execute</span>] every?] [eval-<span style="font-weight: bold;">step</span>] <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">swap</span> discard]]]] [<span style="font-weight: bold;">dipdown</span> [[spec [[program [item a] [item b]] [[item a] [item b] *]]] [examples [[[1 2 3 [inc] <span style="font-weight: bold;">dipdown</span>] [2 2 3]]]]]] [<span style="font-weight: bold;">map</span> [[spec [[program list] [list]]] [examples [[[[1 2 3] [inc] <span style="font-weight: bold;">map</span>] [[2 3 4]]] [[1 [1 2 3] [+] <span style="font-weight: bold;">map</span>] [[2 3 4] 1]] [[7 9 [1 2 3] [+ *] <span style="font-weight: bold;">map</span>] [[70 77 84] 9 7]] [[7 9 [+] [] <span style="font-weight: bold;">map</span>] [[+] 9 7]]]] [definition [[<span style="font-weight: bold;">snapshot</span> [] <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">dipdown</span> [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold;">float</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [[<span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">inject</span> <span style="font-weight: bold;">first</span> <span style="font-weight: bold;">swap</span> [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">step</span> discard]]]] [primrec [[examples [[[5 [1] [*] primrec] [120]]]] [spec [[[program rec1] [program exit] [number data]] [*]]] [definition [[<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span> [[discard] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> [[zero?]] <span style="font-weight: bold;">dipdown</span> [[<span style="font-weight: bold;">clone</span> dec]] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">recur</span>]]]] [<span style="font-weight: bold;">execute</span> [[spec [[program] [*]]] [examples [[[[1 2 +] <span style="font-weight: bold;">execute</span>] [3]] [[2 [+] 4 <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">execute</span>] [6]]]]]] [<span style="font-weight: bold;">clone</span> [[examples [[[1 2 3 <span style="font-weight: bold;">clone</span>] [1 2 3 3]]]] [spec [[[item a]] [[item a] [item a]]]]]] [or [[examples [[[1 odd? 3 even? or] [<span style="font-weight: bold;">true</span>]] [[1 2 or] [1]] [[[] 2 or] [2]] [[[] [] or] [<span style="font-weight: bold;">false</span>]]]] [spec [[item item] [item]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 2 =] [[]]] [[1 1 =] [<span style="font-weight: bold;">true</span>]] [[[] [] =] [<span style="font-weight: bold;">true</span>]] [[[1] [] =] [[]]] [[[1 [<span style="font-weight: bold;">false</span>]] [1 [<span style="font-weight: bold;">false</span>]] =] [<span style="font-weight: bold;">true</span>]] [[[1 [<span style="font-style: italic;">"foo"</span>]] [1 [<span style="font-style: italic;">"foo"</span>]] =] [<span style="font-weight: bold;">true</span>]] [[<span style="font-style: italic;">"hi"</span> <span style="font-style: italic;">"hi"</span> =] [<span style="font-weight: bold;">true</span>]] [[<span style="font-style: italic;">"hi"</span> <span style="font-style: italic;">"there"</span> =] [[]]] [[[] <span style="font-weight: bold;">true</span> =] [[]]] [[[1 [<span style="font-style: italic;">"foo"</span>]] [1 [<span style="font-style: italic;">"bar"</span>]] =] [[]]] [[[[] [] association =] [<span style="font-weight: bold;">true</span>]]]]]]] [<span style="font-weight: bold;">take</span> [[spec [[[pipe out]] [item [pipe out]]]]]] [something? [[definition [<span style="font-weight: bold;">nothing</span>? not]] [spec [[item] [boolean]]] [examples [[[1 something?] [<span style="font-weight: bold;">true</span>]] [[<span style="font-weight: bold;">false</span> something?] [<span style="font-weight: bold;">true</span>]] [[[] something?] [<span style="font-weight: bold;">false</span>]]]]]] [type [[examples [[[[[foo 1]] type] [[foo] <span style="font-weight: bold;">unwrap</span>]] [[1] [[number] <span style="font-weight: bold;">unwrap</span>]] [[1] [[number] <span style="font-weight: bold;">unwrap</span>]] [[[]] [[<span style="font-weight: bold;">nothing</span>] <span style="font-weight: bold;">unwrap</span>]] [[<span style="font-style: italic;">"foo"</span> bytes] [[bytes] <span style="font-weight: bold;">unwrap</span>]] [[<span style="font-style: italic;">"foo"</span>] [[string] <span style="font-weight: bold;">unwrap</span>]] [[[[type foo]] [[foo] <span style="font-weight: bold;">unwrap</span>]]] [[[[type foo] [attr <span style="font-style: italic;">"blah"</span>]] [[foo] <span style="font-weight: bold;">unwrap</span>]]] [[[[attr1 foo] [attr2 <span style="font-style: italic;">"blah"</span>]] [[association] <span style="font-weight: bold;">unwrap</span>]]] [[[[foo 1]] [[foo] <span style="font-weight: bold;">unwrap</span>]]] [[[[type url] [value <span style="font-style: italic;">"http://foo.com"</span>]] type] [[url] <span style="font-weight: bold;">unwrap</span>]]]] [spec [[item] [item]]] [definition [[[[<span style="font-weight: bold;">nothing</span>?] [[<span style="font-weight: bold;">nothing</span>] <span style="font-weight: bold;">unwrap</span>]] [[association?] [[[[type] lookup] [[<span style="font-weight: bold;">count</span> 1 =] [[<span style="font-weight: bold;">first</span> [type] <span style="font-weight: bold;">unwrap</span> =] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">second</span>] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">first</span>] <span style="font-weight: bold;">if</span>] [[]] <span style="font-weight: bold;">if</span>] [[association] <span style="font-weight: bold;">unwrap</span>]] [<span style="font-weight: bold;">execute</span>] any?]] [[list?] [[list] <span style="font-weight: bold;">unwrap</span>]] [[number?] [[number] <span style="font-weight: bold;">unwrap</span>]] [[word?] [[word] <span style="font-weight: bold;">unwrap</span>]] [[bytes?] [[bytes] <span style="font-weight: bold;">unwrap</span>]] [[string?] [[string] <span style="font-weight: bold;">unwrap</span>]] [[pipe?] [[pipe] <span style="font-weight: bold;">unwrap</span>]] [[error?] [[error] <span style="font-weight: bold;">unwrap</span>]]] decide <span style="font-weight: bold;">swap</span> discard]]]] [fail [[spec [[association] [*]]]]] [decide [[examples [[[5 [[[3 =] [<span style="font-style: italic;">"three"</span>]] [[5 =] [<span style="font-style: italic;">"five"</span>]] [[7 =] [<span style="font-style: italic;">"seven"</span>]] [[<span style="font-weight: bold;">true</span>] [<span style="font-style: italic;">"something else"</span>]]] decide] [5 <span style="font-style: italic;">"five"</span>]] [[9 [[[3 =] [<span style="font-style: italic;">"three"</span>]] [[5 =] [<span style="font-style: italic;">"five"</span>]] [[7 =] [<span style="font-style: italic;">"seven"</span>]] [[<span style="font-weight: bold;">true</span>] [<span style="font-style: italic;">"something else"</span>]]] decide] [9 <span style="font-style: italic;">"something else"</span>]] [[9 [[[3 =] [<span style="font-style: italic;">"three"</span>]] [[5 =] [<span style="font-style: italic;">"five"</span>]] [[7 =] [<span style="font-style: italic;">"seven"</span>]]] decide] [9 []]]]] [spec [[[association test-expr-pairs]] [*]]]]] [break [[spec [[environment [program condition]] [environment [program condition]]]] [definition [[[[[expression] lookup something?] [<span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">execute</span> not]] [<span style="font-weight: bold;">execute</span>] every?] [eval-<span style="font-weight: bold;">step</span>] <span style="font-weight: bold;">while</span>]]]] [<span style="font-weight: bold;">unwrap</span> [[spec [[list] [*]]] [examples [[[[1] <span style="font-weight: bold;">unwrap</span>] [1]]]]]] [handoff [[spec [[] [pipe]]] [definition []]]] [even? [[spec [[number] [boolean]]]]] [assert [[definition [<span style="font-weight: bold;">snapshot</span> [<span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> [discard] [string [<span style="font-style: italic;">"assertion failed "</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">join</span> fail] <span style="font-weight: bold;">branch</span>]] [spec [[program] [*]]]]] [<span style="font-weight: bold;">rest</span> [[spec [[list] [list]]] [examples [[[[1 2 3] <span style="font-weight: bold;">rest</span>] [[2 3]]]]]]] [<span style="font-weight: bold;">false</span> [[spec [[] [item]]] [definition [<span style="font-weight: bold;">nothing</span>]]]] [pump [[spec [[program [pipe in] [pipe out]] [[pipe in] [pipe out]]]] [definition [<span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">join</span> [[] <span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swapdown</span> [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">dip</span> [[closed?] any?] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>]]]]] [<span style="font-weight: bold;">branch</span> [[examples [[[5 <span style="font-weight: bold;">true</span> [3 *] [4 +] <span style="font-weight: bold;">branch</span>] [15]] [[6 <span style="font-weight: bold;">false</span> [3 *] [4 +] <span style="font-weight: bold;">branch</span>] [10]]]] [spec [[[program <span style="font-weight: bold;">false</span>-<span style="font-weight: bold;">branch</span>] [program <span style="font-weight: bold;">true</span>-<span style="font-weight: bold;">branch</span>] [item condition]] [*]]]]] [rem [[spec [[number number] [number]]] [definition []]]] [/ [[spec [[number number] [number]]]]] [value [[definition [[<span style="font-weight: bold;">count</span> 1 =] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">second</span>] [[value] lookup] <span style="font-weight: bold;">if</span>]] [examples [[[[[foo 1]] value] [1]] [[[[type url] [value <span style="font-style: italic;">"http://foo.com"</span>]] value] [<span style="font-style: italic;">"http://foo.com"</span>]]]] [spec [[association] [item]]]]] [dec [[spec [[number] [number]]]]] [any? [[spec [[program list] boolean]] [definition [[<span style="font-weight: bold;">shielddown</span>] <span style="font-weight: bold;">swap</span> prepend [<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">dip</span> or] <span style="font-weight: bold;">join</span> [[] [[[<span style="font-weight: bold;">nothing</span>?] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> [or] <span style="font-weight: bold;">shielddown</span>] []] <span style="font-weight: bold;">dip</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">recur</span> <span style="font-weight: bold;">swap</span> discard]] [examples [[[[2 4 6] [even?] any?] [<span style="font-weight: bold;">true</span>]] [[[3 5 7] [even?] any?] [<span style="font-weight: bold;">false</span>]] [[[] [even?] any?] [<span style="font-weight: bold;">false</span>]] [[[2 4 6] [] any?] [2]] [[11 [3 5 6] [+ odd?] any?] [<span style="font-weight: bold;">true</span> 11]] [[-15 [[even?] [positive?] [3 rem 0 =]] [<span style="font-weight: bold;">execute</span>] any?] [<span style="font-weight: bold;">true</span> -15]]]]]] [and [[examples [[[1 odd? 2 even? and] [<span style="font-weight: bold;">true</span>]]]] [spec [[item item] [item]]]]] [pipe-in [[spec [[item] [pipe]]] [definition [[[[type [file] <span style="font-weight: bold;">unwrap</span> =] [value file-in]] [[type [stdout] <span style="font-weight: bold;">unwrap</span> =] [stdout]]] decide]]]] [<span style="font-weight: bold;">nothing</span> [[definition [[]]] [spec [[] [item]]]]] [range [[examples [[[1 5 range] [[1 2 3 4]]]]] [spec [[integer integer] [list]]]]] [<span style="font-weight: bold;">take</span> [[spec [[list] [item list]]] [examples [[[[<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span> <span style="font-style: italic;">"c"</span>] <span style="font-weight: bold;">take</span>] [[<span style="font-style: italic;">"b"</span> <span style="font-style: italic;">"c"</span>] <span style="font-style: italic;">"a"</span>]]]]]] [<span style="font-weight: bold;">count</span> [[examples [[[[<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span> <span style="font-style: italic;">"c"</span>] <span style="font-weight: bold;">count</span>] [3]]]] [spec [[list] [number]]]]] [list? [[examples [[[[1] list?] [<span style="font-weight: bold;">true</span>]] [[[] list?] [<span style="font-weight: bold;">true</span>]] [[5 list?] [<span style="font-weight: bold;">false</span>]]]] [spec [[item] [boolean]]]]] [retry [[spec [[error] [*]]] [examples [[[2 3 <span style="font-style: italic;">"four"</span> * + handle [discard 4] <span style="font-weight: bold;">dip</span> retry] [14]]]] [definition [[unwound] lookup <span style="font-weight: bold;">execute</span>]]]] [min [[spec [[number number] [number]]] [definition []]]] [spit [[definition [[pipe-in] <span style="font-weight: bold;">dip</span> bytes <span style="font-weight: bold;">put</span> close discard]] [spec [[item [item target]] []]]]] [ceil [[spec [[number] [integer]]]]] [atom [[definition []] [spec [[item] [pipe]]]]] [<span style="font-weight: bold;">join</span> [[examples [[[[<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span>] [<span style="font-style: italic;">"c"</span> <span style="font-style: italic;">"d"</span>] <span style="font-weight: bold;">join</span>] [[<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span> <span style="font-style: italic;">"c"</span> <span style="font-style: italic;">"d"</span>]]] [[<span style="font-style: italic;">"ab"</span> <span style="font-style: italic;">"cd"</span> <span style="font-weight: bold;">join</span>] [<span style="font-style: italic;">"abcd"</span>]] [[<span style="font-style: italic;">"ab"</span> bytes <span style="font-style: italic;">"cd"</span> bytes <span style="font-weight: bold;">join</span> <span style="font-style: italic;">"abcd"</span> bytes =] [<span style="font-weight: bold;">true</span>]]]] [spec [[item item] [item]]]]] [odd? [[spec [[number] [boolean]]]]] [file-out [[spec [[string] [pipe]]]]] [discard [[spec [[item] []]] [examples [[[1 2 3 discard] [1 2]] [[1 2 3 [a b c] discard] [1 2 3]]]]]] [tos [[examples [[[[[stack [1 2 3]] [expression [[+] <span style="font-weight: bold;">step</span>]]] tos] [1]]]] [definition [[stack] lookup <span style="font-weight: bold;">first</span>]] [spec [[environment] [item]]]]] [+ [[examples [[[1 2 +] [3]] [[1.1 2.2 +] [3.3]] [[1 2.2 +] [3.2]]]] [spec [[number number] [number]]]]] [<span style="font-weight: bold;">second</span> [[spec [[list] [item]]] [examples [[[[4 5 6] <span style="font-weight: bold;">second</span>] [5]]]]]] [recover [[examples [[[[+] [discard 1 [+] [discard 2 +] recover] recover] [3]] [5 [1 2 <span style="font-style: italic;">"oh fudge"</span>] [[+] [discard discard] recover] <span style="font-weight: bold;">map</span>] [5 [6 7 5]] [[<span style="font-weight: bold;">swap</span>] [<span style="font-weight: bold;">swap</span>] recover] [<span style="font-weight: bold;">swap</span>]]] [definition [[[handle] <span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> [<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold;">sink</span> <span style="font-weight: bold;">inject</span> [<span style="font-weight: bold;">first</span> error?] [<span style="font-weight: bold;">first</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">execute</span>] [<span style="font-weight: bold;">evert</span> discard] <span style="font-weight: bold;">if</span>]] [spec [[program program] [*]]]]] [inc [[examples [[[1 inc] [2]] [[-1 inc] [0]] [[99 inc] [100]]]] [spec [[number] [number]]]]] [<span style="font-weight: bold;">put</span> [[examples [[[[] 1 <span style="font-weight: bold;">put</span>] [[1]]] [[[1 2 3] 4 <span style="font-weight: bold;">put</span>] [[1 2 3 4]]] [[<span style="font-style: italic;">"foo"</span> bytes 32 <span style="font-weight: bold;">put</span> string] [<span style="font-style: italic;">"foo "</span>]]]] [spec [[item list] [list]]]]] [<span style="font-weight: bold;">true</span> [[spec [[] [word]]]]] [pipe? [[spec [[item] [boolean]]]]] [error? [[spec [[item] [boolean]]]]] [bytes [[spec [[item] [bytes]]]]] [a 1] [<span style="font-weight: bold;">while</span> [[examples [[[3 [0 &gt;] [<span style="font-weight: bold;">clone</span> dec] <span style="font-weight: bold;">while</span>] [3 2 1 0]]]] [spec [[[program body] [program pred]] [*]]] [definition [<span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">shield</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">loop</span>]]]] [&gt;= [[spec [[number number] [boolean]]]]] [<span style="font-weight: bold;">shielddown</span> [[examples [[[1 2 3 [=] <span style="font-weight: bold;">shielddown</span>] [1 2 <span style="font-weight: bold;">false</span>]]]] [definition [<span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">swap</span> discard]] [spec [[program item] [item]]]]] [derivations [[definition [[]]]]] [<span style="font-weight: bold;">times</span> [[definition [<span style="font-weight: bold;">swap</span> [dec] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [<span style="font-weight: bold;">dip</span>] <span style="font-weight: bold;">join</span> [0 &gt;] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">while</span> discard]] [spec [[[integer howmany] [program body]] [*]]]]] [++lookup [[spec [[item association] [item]]]]] [mod [[spec [[number number] [number]]]]] [&lt;= [[spec [[number number] [boolean]]]]] [toe [[examples [[[[[stack [1 2 3]] [expression [[+] <span style="font-weight: bold;">step</span>]]] toe] [[+]]]]] [definition [[expression] lookup <span style="font-weight: bold;">first</span>]] [spec [[environment] [item]]]]]]
</pre>
</div>

<p>
Need a way of converting an item to an entry that just pushes that item.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span style="font-weight: bold;">wrap</span> [[[spec [[[] [item]]]]] [definition]] <span style="font-weight: bold;">dip</span> assign 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[spec [[[] [item]]]] [definition [1]]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary
[[spec [[] [item]]]
 [definition [23]]]
[fooptoopy] <span style="font-weight: bold;">swap</span> assign
[fooptoopy] lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[spec [[] [item]]] [definition [23]]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[a [1 1 1]]
 [b [6 7 *]]]
[a b +] let
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca3e696" class="outline-4">
<h4 id="orgca3e696"><span class="section-number-4">1.5.24.</span> <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h4>
<div class="outline-text-4" id="text-1-5-24">
<p>
It's still implemented as generic Hashmap data field. 
</p>
</div>
</div>

<div id="outline-container-org9d1f91e" class="outline-4">
<h4 id="org9d1f91e"><span class="section-number-4">1.5.25.</span> <span class="todo TODO">TODO</span> Script</h4>
<div class="outline-text-4" id="text-1-5-25">
</div>
<div id="outline-container-org3c79278" class="outline-5">
<h5 id="org3c79278"><span class="section-number-5">1.5.25.1.</span> <span class="done DONE">DONE</span> Cryptographic primitives</h5>
<div class="outline-text-5" id="text-1-5-25-1">
</div>
<ol class="org-ol">
<li><a id="org23a9bd7"></a><span class="done DONE">DONE</span> SHA256<br />
<div class="outline-text-6" id="text-1-5-25-1-1">
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> bytes hash <span style="font-style: italic;">"fop"</span> bytes hash =
</pre>
</div>

<pre class="example">
[]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[<span style="font-style: italic;">"foo"</span> bytes key] 2 <span style="font-weight: bold;">times</span> =
</pre>
</div>

<pre class="example">
true
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> bytes key
</pre>
</div>

<pre class="example">
[[public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="] [type elliptic-curve-key] [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]
</pre>
</div>
</li>

<li><a id="org0ddc1bc"></a><span class="done DONE">DONE</span> Signing<br />
<div class="outline-text-6" id="text-1-5-25-1-2">
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> bytes key <span style="font-style: italic;">"we attack at dawn"</span> bytes [sign] <span style="font-weight: bold;">shield</span> verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span style="font-weight: bold;">true</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> bytes key <span style="font-style: italic;">"we attack at dawn"</span> bytes [sign] <span style="font-weight: bold;">shield</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">now change the message</span>
[discard <span style="font-style: italic;">"we attack at sunset"</span> bytes] <span style="font-weight: bold;">dip</span>
verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[]
</pre>
</div>
</div>
</li>

<li><a id="org418d7cd"></a><span class="todo TODO">TODO</span> AES Encryption<br /></li>
<li><a id="orgaeebc1b"></a><span class="todo TODO">TODO</span> Random<br /></li>
</ol>
</div>
<div id="outline-container-org47a5c97" class="outline-5">
<h5 id="org47a5c97"><span class="section-number-5">1.5.25.2.</span> <span class="done DONE">DONE</span> Pure functional env</h5>
<div class="outline-text-5" id="text-1-5-25-2">
<div class="org-src-container">
<pre class="src src-kcats">[[pipe-in pipe-out channel timeout handoff file-in file-out timestamps standard serversocket animate future spit tunnel ] [<span style="font-weight: bold;">wrap</span> unassign] <span style="font-weight: bold;">step</span>] [1 2 <span style="font-weight: bold;">swap</span>] lingo
</pre>
</div>

<pre class="example">
1 2
</pre>
</div>
</div>
<div id="outline-container-org53d4ec0" class="outline-5">
<h5 id="org53d4ec0"><span class="section-number-5">1.5.25.3.</span> <span class="todo TODO">TODO</span> Infinite loop protection</h5>
<div class="outline-text-5" id="text-1-5-25-3">
<p>
We need to prevent an attacker presenting <code>true [clone] loop</code> as their
identity proof, which would never halt. It may be easiest to just
remove all the looping words from the dictionary, but that seems
overly restrictive, when the point is just to limit the resources an
attacker can consume, and we already have a direct solution for that:
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[expression [<span style="font-weight: bold;">true</span> [<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">loop</span>]]] environment
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org93d31ce" class="outline-4">
<h4 id="org93d31ce"><span class="section-number-4">1.5.26.</span> <span class="done DONE">DONE</span> Multithreading</h4>
<div class="outline-text-4" id="text-1-5-26">
</div>
<div id="outline-container-org30ea8cf" class="outline-5">
<h5 id="org30ea8cf"><span class="section-number-5">1.5.26.1.</span> Overview</h5>
<div class="outline-text-5" id="text-1-5-26-1">
<p>
There are a few major components here:
</p>
<ul class="org-ul">
<li>Be able to tell whether an environment can advance. It's basically
"if there's nothing in the expression, it's done, otherwise it can
run unless it's currently putting/taking from a pipe"</li>
</ul>
</div>
</div>
<div id="outline-container-orga249a56" class="outline-5">
<h5 id="orga249a56"><span class="section-number-5">1.5.26.2.</span> Pipes</h5>
<div class="outline-text-5" id="text-1-5-26-2">
<p>
It's not clear to me what to do about pipes. As soon as we call <code>take</code>
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need <code>tokio</code>.
</p>

<p>
tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.
</p>

<p>
So then another question is, how to use something like <code>select</code> in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.
</p>

<p>
I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately <code>await</code>. That should yield to allow other envs to run.
</p>

<p>
It looks like the <code>async</code> will creep all the way up to <code>axiom::eval</code>. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to <code>eval</code>
is going to be <code>async</code>.
</p>

<p>
I think that means fns like <code>f_stack1</code> etc will need to be async because
the <code>f</code> it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.
</p>

<p>
We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to <code>join</code> with other environment's tasks.
</p>
</div>
</div>
<div id="outline-container-org77588a9" class="outline-5">
<h5 id="org77588a9"><span class="section-number-5">1.5.26.3.</span> <span class="done DONE">DONE</span> Add tokio as dep</h5>
</div>
<div id="outline-container-org732d969" class="outline-5">
<h5 id="org732d969"><span class="section-number-5">1.5.26.4.</span> <span class="done DONE">DONE</span> Prepare for multithreading</h5>
<div class="outline-text-5" id="text-1-5-26-4">
</div>
<ol class="org-ol">
<li><a id="orgdba380b"></a><span class="done DONE">DONE</span> Use Arc instead of Rc<br />
<div class="outline-text-6" id="text-1-5-26-4-1">
<p>
Does Arc have <code>make_mut</code>?  Yes! So hopefully it will be a drop-in
replacement.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org328099e" class="outline-5">
<h5 id="org328099e"><span class="section-number-5">1.5.26.5.</span> <span class="done DONE">DONE</span> Update pipe types for fs and net to use tokio calls</h5>
<div class="outline-text-5" id="text-1-5-26-5">
<p>
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.
</p>

<p>
If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.
</p>

<p>
Maybe one way to proceed is to make an <code>Item</code> variant <code>Future</code>. So if
we're taking from a pipe, we can just put the <code>Future</code> on the stack and
continue. Of course, very soon we'll need to access the value and call
<code>await</code> on it. 
</p>

<p>
What then, do we do about <code>put</code>? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.
</p>

<p>
Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just discard it. Somewhere we'd need a type <code>Option&lt;Item&gt;</code> for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)
</p>

<p>
So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.
</p>

<p>
If this works then only eval/eval-step will need <code>async</code>.
</p>
</div>
</div>
<div id="outline-container-org67944cd" class="outline-5">
<h5 id="org67944cd"><span class="section-number-5">1.5.26.6.</span> <span class="done DONE">DONE</span> Use channel type to implement handoff pipe</h5>
<div class="outline-text-5" id="text-1-5-26-6">
</div>
<ol class="org-ol">
<li><a id="org3000908"></a><span class="done DONE">DONE</span> Use crossbeam channels<br />
<div class="outline-text-6" id="text-1-5-26-6-1">
<p>
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".
</p>

<div class="org-src-container">
<pre class="src src-kcats">handoff <span style="font-weight: bold;">clone</span>
<span style="font-weight: bold;">wrap</span> [5 <span style="font-weight: bold;">put</span> <span style="font-style: italic;">"hello"</span> <span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">join</span>
[] <span style="font-weight: bold;">swap</span> [[expression]] <span style="font-weight: bold;">dip</span> assign environment animate <span style="font-weight: bold;">take</span> [<span style="font-weight: bold;">take</span>] <span style="font-weight: bold;">dip</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">5 <span style="font-style: italic;">"hello"</span> [[type pipe] [handoff todo: id-or-hash here]]
</pre>
</div>

<pre class="example">

</pre>


<p>
One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 
</p>

<p>
The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.
</p>

<p>
The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot&#x2026; is that
common?)
</p>

<p>
The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.
</p>

<p>
For now I think I'm inclined to leave it as-is and see how it goes.
</p>
</div>
</li>
<li><a id="orgf7cff82"></a><span class="todo TODO">TODO</span> Nonblocking eval-step (for inner envs)<br />
<div class="outline-text-6" id="text-1-5-26-6-2">
<p>
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe <code>try_eval_step</code> which tries to
make progress immediately and if it can't, just returns as-is.
</p>

<p>
There's probably a way to do this by polling the future. using <code>select!</code>
with a short timeout future would do it but there's probably a better
way.
</p>
</div>
</li>
<li><a id="org23f093d"></a><span class="todo TODO">TODO</span> Combine implementations for net and fs<br />
<div class="outline-text-6" id="text-1-5-26-6-3">
<p>
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org1f536a3" class="outline-5">
<h5 id="org1f536a3"><span class="section-number-5">1.5.26.7.</span> <span class="done DONE">DONE</span> Implement 'spawn' or equavalent</h5>
<div class="outline-text-5" id="text-1-5-26-7">
<p>
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
<code>animate</code> seems rather fitting.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[expression [+ 1 1]]] environment animate 
</pre>
</div>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-orgf390ae3" class="outline-5">
<h5 id="orgf390ae3"><span class="section-number-5">1.5.26.8.</span> <span class="done DONE">DONE</span> Implement 'future' or equivalent</h5>
<div class="outline-text-5" id="text-1-5-26-8">
<p>
The idea here is to take an expression and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.
</p>

<p>
I think the new env should probably inherit the current env's stack.
</p>
<div class="org-src-container">
<pre class="src src-kcats">1 2 [+] 
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">make a pipe</span>
handoff <span style="font-weight: bold;">swap</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">save the stack, including pipe</span>
[<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dip</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">prepare the program for the new env</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">end up with [[+ snapshot] dip swap put]</span>
[<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> discard] <span style="font-weight: bold;">join</span>
<span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">;; now we have expr stack</span>
pair
[stack expression] <span style="font-weight: bold;">swap</span> zip environment
animate <span style="font-weight: bold;">take</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[3] [[type pipe] [handoff todo: id-or-hash here]] 2 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 [2 +] future <span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> discard
</pre>
</div>

<pre class="example">
[3] 1
</pre>
</div>
</div>
</div>
<div id="outline-container-orgea066d2" class="outline-4">
<h4 id="orgea066d2"><span class="section-number-4">1.5.27.</span> <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-5-27">
<p>
Currently it expects an error on ToS and then a program beneath. But
it seems like we'd nearly always have to <code>dip</code> the program beneath the
error. I think it would be better if <code>retry</code> expected the program to fix
the issue on top, and the error beneath.
</p>
</div>
</div>
<div id="outline-container-org694995d" class="outline-4">
<h4 id="org694995d"><span class="section-number-4">1.5.28.</span> <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</h4>
<div class="outline-text-4" id="text-1-5-28">
</div>
<div id="outline-container-orgf362ff3" class="outline-5">
<h5 id="orgf362ff3"><span class="section-number-5">1.5.28.1.</span> <span class="done DONE">DONE</span> XOR</h5>
<div class="outline-text-5" id="text-1-5-28-1">
<p>
We have a node id (maybe just the i2p destination address?) and we
want to calculate the distance to another node as the XOR
</p>
</div>
</div>
<div id="outline-container-orga497dad" class="outline-5">
<h5 id="orga497dad"><span class="section-number-5">1.5.28.2.</span> <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</h5>
<div class="outline-text-5" id="text-1-5-28-2">
<p>
Construct a socket listener, and serve something from a trivial local
database. Disable exploitable words.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">create an API service</span>
<span style="font-weight: bold; font-style: italic;">;; </span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">Takes from the stack:</span>
<span style="font-weight: bold; font-style: italic;">;; </span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">* a Database (can be a regular data structure for read-only apis),</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">or a pipe to an actual (sql or other) database that accepts queries for</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">read/write ops</span>
<span style="font-weight: bold; font-style: italic;">;;</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">* a program that modifies the dictionary that clients can</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">access. It should add words to make interaction easier (for</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">example, you might provide a word 'customers' that gets the customers</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">db table). It should also remove words that the clients should not be able</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">to use - for example, they shouldn't be able to create file or network pipes. </span>
<span style="font-weight: bold; font-style: italic;">;;</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">* a server socket pipe to serve from</span>
<span style="font-weight: bold; font-style: italic;">;;</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">The client sends a program to run in a fresh environment where he</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">can expect to find:</span>
<span style="font-weight: bold; font-style: italic;">;;</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">* The database (either a pipe or data structure)</span>
<span style="font-weight: bold; font-style: italic;">;;</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">His program runs and then the resulting stack is returned to him.</span>
<span style="font-weight: bold; font-style: italic;">;; </span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">socket listener</span>
[[type ip-port] [port 12121] [address <span style="font-style: italic;">"127.0.0.1"</span>]] pipe-out

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">sample local db - list of people and their game high</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">scores</span>
[[[name <span style="font-style: italic;">"joe"</span>] [age 25] [score 1000]]
 [[name <span style="font-style: italic;">"jane"</span>] [age 35] [score 1100]]
 [[name <span style="font-style: italic;">"tommy"</span>] [age 9] [score 870]]
 [[name <span style="font-style: italic;">"carter"</span>] [age 59] [score 670]]]
[association] <span style="font-weight: bold;">map</span>

[] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">dictionary modifications </span>

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">API Server code begins here</span>

dictionary <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">execute</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; new-dict db sock</span>

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">start building the environment</span>
[[expression [<span style="font-weight: bold;">take</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the request as bytes (todo: know when the request ends) -&gt; req pipe db</span>
              <span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">we want the pipe on top so we can dip the user's program under it -&gt; pipe req db</span>
              [string <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">translate to a string -&gt; req-str db</span>
               read <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the request program into a data structure -&gt; prog db</span>
               <span style="font-weight: bold;">execute</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the program -&gt; items*</span>
               <span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">under the pipe so the user's code has no access</span>
              <span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; response pipe</span>
              emit <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; response-str pipe</span>
              bytes <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; response-bytes pipe</span>
              <span style="font-weight: bold;">put</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the response into the pipe</span>
              discard <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">close the connection</span>
             ]]] environment <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; env new-dict db sock </span>
[dictionary] <span style="font-weight: bold;">float</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; new-dict [dictionary] env db sock</span>
assign  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; env db sock</span>

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">now just need to assign the stack, which is [pipe db] </span>
<span style="font-weight: bold;">float</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; sock env db</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">loop to accept connections and start new env with the db and a pipe</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">to take requests and reply</span>
[[<span style="font-weight: bold;">float</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; pipe db env</span>
  pair <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; stack env</span>
  [stack] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; stack ks env</span>
  assign <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; env</span>
  environment
  animate <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">let it fly  </span>
 ] <span style="font-weight: bold;">shielddown</span>  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">shielded so as not to consume the db each time</span>
 discard <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">drop whatever the result is of this iteration, we don't need it</span>
]

<span style="font-weight: bold;">step</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">accepts incoming connections until killed</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga3177e4" class="outline-5">
<h5 id="orga3177e4"><span class="section-number-5">1.5.28.3.</span> <span class="todo TODO">TODO</span> Kademlia functions</h5>
</div>
</div>
<div id="outline-container-orgff948d9" class="outline-4">
<h4 id="orgff948d9"><span class="section-number-4">1.5.29.</span> <span class="done DONE">DONE</span> Implement print (opposite of read)</h4>
<div class="outline-text-4" id="text-1-5-29">
<p>
We don't have a way to convert objects to their string serialization
Completed as the word emit
</p>
</div>
</div>
<div id="outline-container-org9ed4873" class="outline-4">
<h4 id="org9ed4873"><span class="section-number-4">1.5.30.</span> <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-5-30">
<p>
read will read all the bytes and return however many objects were read.
emit will take an object and return its serialization.
</p>

<p>
There should be some way of round tripping here, maybe a word <code>read1</code> or
something that just reads one object. 
</p>
</div>
</div>
<div id="outline-container-orgf75f1a6" class="outline-4">
<h4 id="orgf75f1a6"><span class="section-number-4">1.5.31.</span> <span class="todo TODO">TODO</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-5-31">
<p>
Some words pop the arguments off the stack, then if an error is
encountered, throws the error without the args on the stack. Others
leave the args intact. This needs to be consistent.
</p>

<p>
I would lean towards leaving the args intact so that <code>retry</code> is easily applied.
</p>
</div>
<div id="outline-container-org178da2a" class="outline-5">
<h5 id="org178da2a"><span class="section-number-5">1.5.31.1.</span> <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</h5>
<div class="outline-text-5" id="text-1-5-31-1">
<p>
It should attempt to parse before popping the item off the stack.
</p>
</div>
</div>
<div id="outline-container-orgdb9ce69" class="outline-5">
<h5 id="orgdb9ce69"><span class="section-number-5">1.5.31.2.</span> <span class="todo TODO">TODO</span> Division by zero consumes stack items</h5>
<div class="outline-text-5" id="text-1-5-31-2">
<p>
<code>5 0 /</code> shouldn't consume the <code>5</code> and <code>0</code> - compare to <code>1 "2" +</code> behavior
(which leaves items on stack).
</p>
</div>
</div>
</div>

<div id="outline-container-org7382311" class="outline-4">
<h4 id="org7382311"><span class="section-number-4">1.5.32.</span> <span class="done DONE">DONE</span> logical enum hierarchy</h4>
<div class="outline-text-4" id="text-1-5-32">
</div>
<div id="outline-container-org1f824ef" class="outline-5">
<h5 id="org1f824ef"><span class="section-number-5">1.5.32.1.</span> <span class="done DONE">DONE</span> Collection hierarchy</h5>
<div class="outline-text-5" id="text-1-5-32-1">
<p>
There are read (peek/first) and write operations (pack/put/conj).
</p>

<p>
Then there are read/write ops like (take/unpack) that mutate the coll
and also return a value.
</p>

<p>
An In pipe supports only write. An Out pipe supports only
read-write. Pipes in general do not support peeking.
</p>

<p>
Collections (lists, maps, sets etc) support all of them.
</p>

<p>
It's not clear how to support overlapping functionality in an enum.
</p>
</div>
</div>
<div id="outline-container-org85a34cf" class="outline-5">
<h5 id="org85a34cf"><span class="section-number-5">1.5.32.2.</span> <span class="done DONE">DONE</span> pipe as list-like thing</h5>
<div class="outline-text-5" id="text-1-5-32-2">
<p>
Are both words <code>put</code> and <code>pack</code> needed (similarly <code>take</code> and <code>unpack</code>)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).
</p>

<p>
Also take in other langs takes a number arg (how many to take). You
could do this as <code>[take] 5 times</code>, but that's less efficient. Could
maybe create a new word like <code>split</code> or <code>unload</code> or something.
</p>

<p>
The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. (You can ask if the object is a pipe before taking)
</p>

<p>
<code>step</code> should work on pipes. It continues until the pipe closes. How do
we write step in terms of take? The problem is we don't know when to
stop. We know if a collection is empty, but we need to know if a pipe
is closed. The way pipes work now is that if something goes wrong, it
produces an error from the pipe. That's ok for pipes, where we're ok
with the limitation that you can't tell whether the error was
generated during the take or was the actual data sent. However when
dealing with lists, errors are never generated, they're always the
item in the list. We want step to treat both errors and <code>nothing</code> as
actual items and not a flag value for error conditions
</p>

<p>
OK here's a plan: Result&lt;Option&lt;Item&gt;&gt;.  If the pipe is closed, return
Ok(None), if error return Err. The way we differentiate between Errors
in a list and Errors that just happened, is already implemented: via
the 'handled' field of the Error. So if there's a error in the list,
it'll have handled=true and it won't cause the expression to
unwind. If it's an actual error reading from the underlying data,
it'll have handled=false and unwind. This will also allow us to
support Nothing in lists and pipes, we won't reserve it as a sentinel
value.
</p>
</div>
</div>
<div id="outline-container-org2ddde48" class="outline-5">
<h5 id="org2ddde48"><span class="section-number-5">1.5.32.3.</span> <span class="done DONE">DONE</span> Step accepts pipes</h5>
</div>
<div id="outline-container-org6bc7fb6" class="outline-5">
<h5 id="org6bc7fb6"><span class="section-number-5">1.5.32.4.</span> <span class="done DONE">DONE</span> Set close = discard</h5>
</div>
<div id="outline-container-org66b2f0c" class="outline-5">
<h5 id="org66b2f0c"><span class="section-number-5">1.5.32.5.</span> <span class="done DONE">DONE</span> Remove closed?</h5>
<div class="outline-text-5" id="text-1-5-32-5">
</div>
<ol class="org-ol">
<li><a id="org97598ca"></a><span class="done DONE">DONE</span> Write assemble in terms of step<br />
<div class="outline-text-6" id="text-1-5-32-5-1">
<p>
I don't think we actually need assemble anymore, since this is just a
regular <code>step</code> (same as reducing any other iterable).
</p>
</div>
</li>
<li><a id="org1a1cd26"></a><span class="done DONE">DONE</span> Do something with network pipes<br />
<div class="outline-text-6" id="text-1-5-32-5-2">
<p>
I think this does have a notion of closing.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgccf2359" class="outline-5">
<h5 id="orgccf2359"><span class="section-number-5">1.5.32.6.</span> <span class="done DONE">DONE</span> make a polymorphic 'join'</h5>
<div class="outline-text-5" id="text-1-5-32-6">
<p>
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).
</p>

<ul class="org-ul">
<li>list assoc -&gt; list</li>
<li>assoc list -&gt; list</li>
<li>list string -&gt; list</li>
<li>assoc string -&gt; error</li>
<li><p>
assoc assoc -&gt; assoc (merge top into 2nd)
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[a b] [c d]] [[e f]] <span style="font-weight: bold;">join</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[a b] [c d] [e f]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[a b] [c d]] association [[a f]] association <span style="font-weight: bold;">join</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[[a f] [c d]]
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org26e5b62" class="outline-5">
<h5 id="org26e5b62"><span class="section-number-5">1.5.32.7.</span> <span class="done DONE">DONE</span> Update spec types to be more abstract</h5>
<div class="outline-text-5" id="text-1-5-32-7">
<p>
For example, <code>step</code> now accepts not only lists but also out-pipes. So
really the spec type for this argument should be <code>iterable</code> or
something.
</p>

<p>
For ideas of what to call these types, how about <code>in</code> and <code>out</code>? So eg
step takes a program and an out. <code>put</code> takes an <code>in</code>, <code>take</code> takes an <code>out</code>. I
am not sure if the <code>tunnel</code> concept will be necessary.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc0194ec" class="outline-4">
<h4 id="orgc0194ec"><span class="section-number-4">1.5.33.</span> <span class="done DONE">DONE</span> Support char type</h4>
<div class="outline-text-4" id="text-1-5-33">
<p>
If we don't support char, that breaks the abstraction of a String as a
sort of collection. A collection of what? Characters, not 1-length
strings.
</p>

<p>
Might have to do something similar with byte, but a byte array can
also be thought of as an array of ints (8 bit unsigned), and we
already have an integer type (even though it holds more bits).
</p>
</div>
</div>
<div id="outline-container-org9d337ac" class="outline-4">
<h4 id="org9d337ac"><span class="section-number-4">1.5.34.</span> <span class="todo TODO">TODO</span> implement sleep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-34">
<p>
helps with debugging multithreading
</p>
</div>
</div>
<div id="outline-container-orgdc01176" class="outline-4">
<h4 id="orgdc01176"><span class="section-number-4">1.5.35.</span> <span class="done DONE">DONE</span> handoff tests</h4>
<div class="outline-text-4" id="text-1-5-35">
<p>
This should block, not error
</p>
<div class="org-src-container">
<pre class="src src-kcats">handoff <span style="font-weight: bold;">take</span>
</pre>
</div>

<pre class="example">
[[reason "type mismatch"] [unwound [unpack]] [type error] [asked [list]] [actual [[type pipe] [handoff todo: id-or-hash here]]] [handled true]] [[handoff todo: id-or-hash here] [type pipe]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">handoff [1 2 +] future <span style="font-weight: bold;">take</span> 
</pre>
</div>

<pre class="example">
[3 [[type pipe] [handoff todo: id-or-hash here]]] [[handoff todo: id-or-hash here] [type pipe]] [[handoff todo: id-or-hash here] [type pipe]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">handoff <span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> [1 <span style="font-weight: bold;">put</span> 2 <span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">join</span> [[] [expression]] <span style="font-weight: bold;">dip</span> assign environment animate <span style="font-weight: bold;">take</span> [<span style="font-weight: bold;">take</span>] <span style="font-weight: bold;">dip</span> +
</pre>
</div>

<pre class="example">
3 [[type pipe] [handoff todo: id-or-hash here]] [[type pipe] [handoff todo: id-or-hash here]]
</pre>


<p>
Should make a word that creates an inner env with access to a handoff also present in the outer env.
</p>
<div class="org-src-container">
<pre class="src src-kcats">  [[1 2 3] [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">step</span> close] handoff <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">p h h</span>
  [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span> [[] [expression]] <span style="font-weight: bold;">dip</span> assign environment animate] <span style="font-weight: bold;">dip</span>
  0 <span style="font-weight: bold;">swap</span> [+] <span style="font-weight: bold;">step</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[snapshot] dip swap  join [[] [expression]] dip assign environment animate take [take] dip +</span>
</pre>
</div>

<pre class="example">
6
</pre>


<div class="org-src-container">
<pre class="src src-kcats">  [[1 2 3] [<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">step</span> close] handoff <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">p h h</span>
  [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span> [[] [expression]] <span style="font-weight: bold;">dip</span> assign environment animate] <span style="font-weight: bold;">dip</span>
  0 <span style="font-weight: bold;">swap</span> [+] <span style="font-weight: bold;">step</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[snapshot] dip swap  join [[] [expression]] dip assign environment animate take [take] dip +</span>
</pre>
</div>

<p>
Read from one file and write to another 
</p>
<div class="org-src-container">
<pre class="src src-kcats">[[file <span style="font-style: italic;">"/tmp/bar"</span>]] pipe-in
[[file <span style="font-style: italic;">"/tmp/foo"</span>]] pipe-out 
[<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">step</span>
</pre>
</div>

<pre class="example">
[[type pipe] [file "/tmp/bar"]]
</pre>


<p>
As a library function
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"/tmp/bar"</span> <span style="font-style: italic;">"/tmp/foo"</span> file-out [file-in] <span style="font-weight: bold;">dip</span>
[<span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">step</span> close
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Closing In
[[file <span style="font-style: italic;">"/tmp/bar"</span>] [type pipe]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org272a64b" class="outline-4">
<h4 id="org272a64b"><span class="section-number-4">1.5.36.</span> <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h4>
<div class="outline-text-4" id="text-1-5-36">
</div>
<div id="outline-container-orga66ab00" class="outline-5">
<h5 id="orga66ab00"><span class="section-number-5">1.5.36.1.</span> <span class="todo TODO">TODO</span> Compile programs</h5>
<div class="outline-text-5" id="text-1-5-36-1">
<p>
Here is how it could maybe be done. We already have a type StepFn
(which takes an env and returns a new one, in a future).
</p>

<p>
So let's say we have a program [1 2 +], and we want to convert that
into a StepFn. We could have a function <code>compose</code> and another
<code>self_insert</code>, and then call compose([self<sub>insert</sub>(1), self<sub>insert</sub>(2),
plus]), which would return a StepFn.
</p>

<p>
Let's look at something more complex:
</p>

<p>
<code>1 2 3 4 [+ *] dip</code>
</p>

<p>
In this case, the program is the composition of the 5 self-inserts and
dip. But what is self-inserted as the 5th item in this case could be
compiled because we know <code>dip</code> follows it. How we know in advance a list
can be compiled is difficult.
</p>

<p>
Let's try this:
</p>

<p>
<code>0 1 [2 3 4] [[+] dip] step</code>
</p>

<p>
In this case, the program for <code>step</code> is easy to spot, and in turn <code>dip</code>.
</p>

<p>
How about this:
</p>

<p>
<code>[+ *] [2 3 4] swap join execute</code>
</p>

<p>
We can't know the first two programs can be compiled until later on,
unless we look ahead in the expression. Even then we can only know
what arguments end up being passed to join and execute by examining
the words' specs, and even that is not foolproof, as we have wildcard
specs like dip where the stack change is arbitrary.
</p>

<p>
One major issue with this optimization is that it will stop the
debugger from working properly, unless special care is taken: with the
debugger we can go step by step, but if the function composition is
bundled up, we can only "step over" that function and not "into" it. I
am not sure if it's possible to build this such that we preserve
stepping ability and increase performance substantially.
</p>
</div>
</div>
<div id="outline-container-orga423628" class="outline-5">
<h5 id="orga423628"><span class="section-number-5">1.5.36.2.</span> <span class="todo TODO">TODO</span> Programs as their own immutable type</h5>
<div class="outline-text-5" id="text-1-5-36-2">
<p>
Programs executing in a loop are generally not modified (exception -
the <code>recur</code> word, which can modify but usually just calls <code>execute</code>)- so
when we execute a program with <code>loop</code> we don't want to have to clone it
each time through the loop.
</p>

<p>
Instead we'll do the following: when <code>loop</code> places a program into the
expression, instead of joining it, it's just going to put it right on
top as a <code>program</code> - we may need to differentiate programs that are
active vs meant to be run later. When <code>eval-step</code> runs, it sees an
active program on the top of the expression, so it calls <code>next</code> and gets
a reference to the next word (or None if it's at the end, drop the
program). Then we lookup that word. If it's an axiom, we call it. If
it's derived, we place a new program on the top of the expression,
with its PC set to 0. The actual programs are immutable, and behind an
Rc. Each "copy" of the program is just an Rc and a counter. Then all
programs are references except the counter.
</p>


<p>
example expression:
</p>
<div class="org-src-container">
<pre class="src src-kcats">[flip discard] <span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">0 </span>
[<span style="font-weight: bold;">float</span> <span style="font-weight: bold;">swapdown</span>] [flip discard] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">0 1</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-kcats">[[+] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">pc 0</span>
[[+] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">pc 1 </span>
[[<span style="font-weight: bold;">snapshot</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">inject</span> <span style="font-weight: bold;">first</span>] [[+] <span style="font-weight: bold;">shield</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">pc 0 1</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">etc</span>
</pre>
</div>

<p>
So when printing out the expression, we could cheat and only show the
remaining program (instead of a stack of partially executed programs).
</p>
</div>
</div>
</div>


<div id="outline-container-org8a33322" class="outline-4">
<h4 id="org8a33322"><span class="section-number-4">1.5.37.</span> <span class="todo TODO">TODO</span> Debugging method for animated envs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></h4>
<div class="outline-text-4" id="text-1-5-37">
<p>
When we <code>animate</code> an env, we lose all contact with it if anything goes
wrong. It's supposed to send stuff back via pipes, but if it doesn't,
how do we know what went wrong? 
</p>
</div>
</div>
<div id="outline-container-org8a84eff" class="outline-4">
<h4 id="org8a84eff"><span class="section-number-4">1.5.38.</span> <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-38">
</div>
<div id="outline-container-orgb162b52" class="outline-5">
<h5 id="orgb162b52"><span class="section-number-5">1.5.38.1.</span> <span class="done DONE">DONE</span> Basic functionality and generators</h5>
<div class="outline-text-5" id="text-1-5-38-1">
<p>
There's the concept of "lazy sequence" that I think maps nicely to
pipes - you can keep calling 'take' and it keeps calculating new
values. Everything it needs is contained in the object, it's not like
a network or filesystem pipe where the data is coming from somewhere
external. But it acts like a pipe.
</p>

<div class="org-src-container">
<pre class="src src-kcats">0 []
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the producer - infinite seq of integers</span>
[[inc <span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; [1] 1</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the filter condition</span>
[3 mod 0 =] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">divisible by 3</span>

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">filter-xf</span>
[<span style="font-weight: bold;">pop</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [[<span style="font-weight: bold;">put</span>] [discard] <span style="font-weight: bold;">if</span>] <span style="font-weight: bold;">join</span>  

<span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[generation filtration] [] 0 </span>
<span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">generate ;; [3]</span>
<span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">generate ;; [3]</span>
<span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">generate ;; [3]</span>
<span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">generate ;; [3]</span>
</pre>
</div>

<p>
The problem above is <code>generate</code> will not produce a value until one
passes the filter. I think filter needs to keep calling <code>generate</code> on the xf below it?
</p>
<div class="org-src-container results">
<pre class="src src-kcats">[[inc <span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> <span style="font-weight: bold;">pop</span> [3 mod 0 =] [<span style="font-weight: bold;">put</span>] [discard] <span style="font-weight: bold;">if</span>] [3] 4
</pre>
</div>

<pre class="example">
1 [[unwound [[[[inc clone] dip swap put [pop [3 mod 0 =]] [put] [discard] if]] unwrap]] [type error] [asked [packable]] [actual 1] [reason "type mismatch"] [handled true]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the impl of filter-xf</span>
[3 mod 0 =]
[<span style="font-weight: bold;">pop</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [[<span style="font-weight: bold;">put</span>] [discard] <span style="font-weight: bold;">if</span>] <span style="font-weight: bold;">join</span>  
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[<span style="font-weight: bold;">pop</span> [3 mod 0 =] [<span style="font-weight: bold;">put</span>] [discard] <span style="font-weight: bold;">if</span>]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>]
<span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>
discard <span style="font-weight: bold;">clone</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>
</pre>
</div>

<pre class="example">
2 [inc clone] 2
</pre>


<div class="org-src-container">
<pre class="src src-kcats">0 [inc] [] [[generate] <span style="font-weight: bold;">dip</span>] ]
</pre>
</div>

<pre class="example">
[[generate] dip] [] [inc] 1
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[1 2 3 4 6 9] liberate ;; produce from list</span>
1 [2 * <span style="font-weight: bold;">clone</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">infinite list</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">increment each</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">[3 * 3 -] each</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">drop the first few</span>
5 dropper
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">limit the list</span>
10 taker
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">collect into list</span>
collect
] <span style="font-weight: bold;">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[reason <span style="font-style: italic;">"type mismatch"</span>] [unwound [positive? [[[2 * <span style="font-weight: bold;">clone</span>] 1]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">first</span> [[dec discard] [[generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> []]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">branch</span> [[[positive?] [dec discard] [[generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> []] <span style="font-weight: bold;">if</span>]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">swap</span> [8] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">swap</span> [[[positive?] [dec [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] [discard []] <span style="font-weight: bold;">if</span>]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">clone</span> [[[generate [[3 * 3 -] bail] <span style="font-weight: bold;">shielddown</span>]]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> <span style="font-weight: bold;">swap</span> [[generate <span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">loop</span> <span style="font-weight: bold;">pop</span> discard [[]] <span style="font-weight: bold;">unwrap</span> <span style="font-weight: bold;">evert</span> <span style="font-weight: bold;">first</span>]] [type error] [asked [number]] [actual [2 * <span style="font-weight: bold;">clone</span>]] [handled <span style="font-weight: bold;">true</span>]] [2 * <span style="font-weight: bold;">clone</span>] 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>] generate
</pre>
</div>

<pre class="example">
1 [inc clone] 1
</pre>


<p>
Now express the debugger interface in terms of generated environment states!
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the steps of execution</span>
[[expression [0 0 10 1 range [+] <span style="font-weight: bold;">step</span>]]] environment
[[[expression] lookup something?]
 [eval-<span style="font-weight: bold;">step</span> <span style="font-weight: bold;">clone</span>]
 [[]]
 <span style="font-weight: bold;">if</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the generator, which needs to emit 'nothing' once the expression is empty</span>
[[stack] lookup] each
50 taker
laster
generate
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[9] 36] [generate [] <span style="font-weight: bold;">swap</span> [] [<span style="font-weight: bold;">swap</span> discard [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">while</span> discard] [[positive?] [dec [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] [discard []] <span style="font-weight: bold;">if</span>] [generate [[[stack] lookup] bail] <span style="font-weight: bold;">shielddown</span>] [[[expression] lookup something?] [eval-<span style="font-weight: bold;">step</span> <span style="font-weight: bold;">clone</span>] [[]] <span style="font-weight: bold;">if</span>] [[stack [[9] 36]] [expression [[+] <span style="font-weight: bold;">step</span>]]]
</pre>
</div>

<p>
implement 'laster' which returns only the last in the seq
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 100 1 range liberate
laster
generate
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] traversal <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">a generator for the list</span>
[inc] each
collect
</pre>
</div>
<pre class="example">
99 [generate [] swap [] [swap discard [generate] dip swap] while discard] liberate []
</pre>


<p>
Now implement 'keep' which returns only an item that passes the filter
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>] 
[odd?] keep
1 dropper
10 taker
[<span style="font-weight: bold;">clone</span> *] each
collect
</pre>
</div>

<pre class="example">
[9 25 49 81 121 169 225 289 361 441] [generate [[clone *] bail] shielddown] [[positive?] [dec [generate] dip swap] [discard []] if] [[[positive?] [[generate discard] dip dec] while [generate swap] dip swapdown swap] bail] 0 [clone [[generate] dip [discard generate] while] dip swap] [[[something?] [odd? not]] [execute] every?] [inc clone] 21
</pre>

<div class="org-src-container">
<pre class="src src-kcats">[odd?] [something?] <span style="font-weight: bold;">swap</span> pair <span style="font-weight: bold;">wrap</span> [every?] <span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[odd? not]</span>

</pre>
</div>

<pre class="example">
[[[something?] [odd?]] every?]
</pre>


<p>
dropper (almost got it, doesn't detect end of parent stream yet)
</p>
<div class="org-src-container">
<pre class="src src-kcats">[0 20 1 range liberate
 5 dropper
 10 taker
 [5 *] each
 [odd?] keep
 collect] <span style="font-weight: bold;">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[25 35 45 55 65]
</pre>
</div>

<p>
Collect fix
</p>
<div class="org-src-container">
<pre class="src src-kcats">[1 2 3] liberate

generate <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n</span>
[] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n n r</span>
[<span style="font-weight: bold;">put</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">r</span>
 [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">r n</span>
 <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">clone</span>]  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n n r </span>
<span style="font-weight: bold;">loop</span> discard
</pre>
</div>

<pre class="example">
[1 2 3] liberate []
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers 10 taker collect <span style="font-weight: bold;">drop</span> generate 
</pre>
</div>

<pre class="example">
[] [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 9
</pre>
</div>
</div>

<div id="outline-container-org7fc559e" class="outline-5">
<h5 id="org7fc559e"><span class="section-number-5">1.5.38.2.</span> <span class="done DONE">DONE</span> map</h5>
</div>
<div id="outline-container-orgcee0c5e" class="outline-5">
<h5 id="orgcee0c5e"><span class="section-number-5">1.5.38.3.</span> <span class="done DONE">DONE</span> filter</h5>
</div>
<div id="outline-container-org29ff266" class="outline-5">
<h5 id="org29ff266"><span class="section-number-5">1.5.38.4.</span> <span class="done DONE">DONE</span> take</h5>
</div>
<div id="outline-container-org2010666" class="outline-5">
<h5 id="org2010666"><span class="section-number-5">1.5.38.5.</span> <span class="done DONE">DONE</span> drop</h5>
<div class="outline-text-5" id="text-1-5-38-5">
<div class="org-src-container">
<pre class="src src-kcats">integers 15 taker 10 dropper [+] reduce
</pre>
</div>

<pre class="example">
60 [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 14
</pre>
</div>
</div>

<div id="outline-container-orgf65f60b" class="outline-5">
<h5 id="orgf65f60b"><span class="section-number-5">1.5.38.6.</span> <span class="done CANCELED">CANCELED</span> last</h5>
</div>
<div id="outline-container-orgb758dff" class="outline-5">
<h5 id="orgb758dff"><span class="section-number-5">1.5.38.7.</span> <span class="todo TODO">TODO</span> distinct</h5>
<div class="outline-text-5" id="text-1-5-38-7">
<p>
depends on sets
</p>

<p>
The difference between this and just calling <code>set</code> is that the result is
still a list, and it preserves the original order, just removes
duplicates. Should be a similar impl to <code>keep</code>.
</p>
<div class="org-src-container">
<pre class="src src-kcats">[1 1 3] liberate
[] set <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">state</span>
[[generate] <span style="font-weight: bold;">dive</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n seen g</span>

 [contains?]
 [<span style="font-weight: bold;">put</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">seen g</span>
  [generate] <span style="font-weight: bold;">dive</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">n seen g</span>
 <span style="font-weight: bold;">while</span>
]
collect
</pre>
</div>

<pre class="example">
[1 1 3] [[generate] dive [contains?] [put [generate] dive] while] [] [take] []
</pre>
</div>
</div>

<div id="outline-container-org3d59539" class="outline-5">
<h5 id="org3d59539"><span class="section-number-5">1.5.38.8.</span> <span class="todo TODO">TODO</span> partition</h5>
</div>
<div id="outline-container-orgfb14ed6" class="outline-5">
<h5 id="orgfb14ed6"><span class="section-number-5">1.5.38.9.</span> <span class="done DONE">DONE</span> joiner (aka catenate)</h5>
<div class="outline-text-5" id="text-1-5-38-9">
<div class="org-src-container">
<pre class="src src-kcats">[[1 2 3] [4 5 6] [7 8 9]]
liberate
[generate [] <span style="font-weight: bold;">swap</span>
 []
 [<span style="font-weight: bold;">join</span>
  [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold;">swap</span>] 
 <span style="font-weight: bold;">while</span> discard] 
generate
</pre>
</div>

<pre class="example">
[1 2 3 4 5 6 7 8 9] [generate [] swap [] [join [generate] dip swap] while discard] [take] []
</pre>
</div>
</div>

<div id="outline-container-org5d2efb0" class="outline-5">
<h5 id="org5d2efb0"><span class="section-number-5">1.5.38.10.</span> <span class="todo TODO">TODO</span> groupby</h5>
<div class="outline-text-5" id="text-1-5-38-10">
<div class="org-src-container">
<pre class="src src-kcats">[<span style="font-style: italic;">"foo"</span> <span style="font-style: italic;">"bar"</span> <span style="font-style: italic;">"baaz"</span> <span style="font-style: italic;">"quux"</span>]
liberate
[] association <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">state</span>
[<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> discard] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f state</span>
[[generate] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f state i</span>
 <span style="font-weight: bold;">swapdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f i state</span>
 [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">k f v state</span>
 <span style="font-weight: bold;">sink</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f v k state</span>
 [<span style="font-weight: bold;">wrap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[v] k state</span>
  [<span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">unwrap</span> pair <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[[v] join] k state</span>
  [<span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[[v] join] [k] state</span>
  update] <span style="font-weight: bold; font-style: italic;">;; </span>
 <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f state</span>

] generate
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[<span style="font-weight: bold;">take</span> <span style="font-weight: bold;">swap</span> discard]
[[generate] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold;">swapdown</span> [<span style="font-weight: bold;">execute</span>] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">wrap</span> [<span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">unwrap</span> pair [<span style="font-weight: bold;">wrap</span>] <span style="font-weight: bold;">dip</span> update] <span style="font-weight: bold;">dip</span>]
[[o [<span style="font-style: italic;">"foo"</span>]]] [<span style="font-weight: bold;">take</span>] [<span style="font-style: italic;">"bar"</span> <span style="font-style: italic;">"baaz"</span> <span style="font-style: italic;">"quux"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-org1869887" class="outline-5">
<h5 id="org1869887"><span class="section-number-5">1.5.38.11.</span> <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</h5>
<div class="outline-text-5" id="text-1-5-38-11">
</div>
<ol class="org-ol">
<li><a id="org099ede6"></a>Problem<br />
<div class="outline-text-6" id="text-1-5-38-11-1">
<p>
this doesn't work:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 [1 2 3] liberate [+] each
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[generate [[+] bail] <span style="font-weight: bold;">shielddown</span>] [<span style="font-weight: bold;">take</span>] [1 2 3] 10
</pre>
</div>

<p>
We should get <code>[11 12 13]</code> but it errors out.
</p>

<p>
The reason is that when + runs, the generators are still on the stack,
in between this mapping function, and the original stack arguments.
</p>

<p>
We need a way to break out of the generation part of the stack and let
the mapping function access the arguments below it.
</p>

<p>
I can't immediately think of a good way to do it.
</p>

<p>
Actually I think that instead of recursively calling generate, and
passing the values back up the stack, there might be a way to build up
the program recursively, and then execute it in one swoop? 
</p>

<p>
Perhaps we can split each stage into several parts:
</p>

<ul class="org-ul">
<li>Generate from the layer below (in which case we obviously need the
layers below to get the next value)</li>
<li>dip underneath the layers to calculate the next value using lower stack items</li>
<li>swap the new value to the top of stack</li>
<li></li>
</ul>
</div>
</li>
<li><a id="org01acdb6"></a>Debug session<br />
<div class="outline-text-6" id="text-1-5-38-11-2">
<div class="org-src-container">
<pre class="src src-kcats">[[expression [10 [1 2 3] liberate [+] each generate]]] environment
advance advance advance advance eval-<span style="font-weight: bold;">step</span> [advance] 5 <span style="font-weight: bold;">times</span> eval-<span style="font-weight: bold;">step</span>
[advance] 2 <span style="font-weight: bold;">times</span> [eval-<span style="font-weight: bold;">step</span>] 99 <span style="font-weight: bold;">times</span> 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">10 [1 2 3] liberate [+] each generate
</pre>
</div>

<pre class="example">
[[asked [number]] [reason "type mismatch"] [unwound [+ [[1 [take] [2 3] 10]] unwrap evert first swap discard [[generate [[+] bail] shielddown]] unwrap swap]] [actual [take]] [type error] [handled true]] 1 [take] [2 3] 10
</pre>



<div class="org-src-container">
<pre class="src src-kcats">[[expression [[[expression [+]]] environment advance]]] environment advance advance eval-<span style="font-weight: bold;">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[[expression [[[expression] lookup <span style="font-weight: bold;">count</span>] <span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">swap</span> [[expression] lookup <span style="font-weight: bold;">count</span> [[positive?] [&lt;=]] [<span style="font-weight: bold;">execute</span>] every?] [eval-<span style="font-weight: bold;">step</span>] <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">swap</span> discard]] [stack [[[stack []] [expression [+]]]]]]
</pre>
</div>
</div>
</li>
<li><a id="org9213152"></a>Resolution<br />
<div class="outline-text-6" id="text-1-5-38-11-3">
<p>
After thinking about this some more, my conclusion:
</p>

<p>
This is supporting multi-arity mapping functions, which did work in
the original map implementation but they are not supported in other
languages. The way you access multiple values there is by closing over
them. So the way you'd do it in kcats is like so:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 [1 2 3] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the extra arg and the list</span>
[-] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the multi-arity map fn</span>
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dipdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">clone the 10</span>
[<span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">unwrap</span> prepend <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">prepend the word swap to the fn so that the 10 ends up beneath the list item</span>
<span style="font-weight: bold;">float</span> prepend <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">prepend the 10</span>
<span style="font-weight: bold;">map</span>
</pre>
</div>

<pre class="example">
[9 8 7] 10
</pre>


<p>
In theory we could write a helper function called <code>capture1</code> or something that does this for us, so you can write
</p>

<pre class="example">
10 [1 2 3] [-] capture1 map
</pre>

<div class="org-src-container">
<pre class="src src-kcats">10 [1 2 3  4 5 6] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the extra arg and the list</span>
[-] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">the multi-arity map fn</span>

[<span style="font-weight: bold;">swapdown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">f i</span>
 [<span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">unwrap</span> prepend
 <span style="font-weight: bold;">swap</span> prepend] <span style="font-weight: bold;">shielddown</span>
[liberate] <span style="font-weight: bold;">dip</span> each collect
</pre>
</div>

<pre class="example">
[9 8 7] [generate [[10 swap -] bail] shielddown] [take] [] 10
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[1 2 <span style="font-style: italic;">"oh fudge"</span>]
[[5 +]
 [discard 5]
 recover]
<span style="font-weight: bold;">map</span>
</pre>
</div>

<pre class="example">
[6 7 5]
</pre>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3cd2267" class="outline-5">
<h5 id="org3cd2267"><span class="section-number-5">1.5.38.12.</span> <span class="done DONE">DONE</span> Reduce</h5>
<div class="outline-text-5" id="text-1-5-38-12">
<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>] 30 taker [+]
[generate] <span style="font-weight: bold;">dive</span> <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc acc f</span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">drop [generate] divedown [] [float execute clone] [] if</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc f g</span>
[[generate] <span style="font-weight: bold;">divedown</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">i acc f g</span>
 [] [<span style="font-weight: bold;">float</span> <span style="font-weight: bold;">execute</span> <span style="font-weight: bold;">clone</span>] [] <span style="font-weight: bold;">if</span>]  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc acc f g</span>
<span style="font-weight: bold;">loop</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>] 10 taker 
generate <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc acc </span>
<span style="font-weight: bold; font-style: italic;">;;</span><span style="font-weight: bold; font-style: italic;">drop [generate] divedown [] [float execute clone] [] if</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc g</span>
[[generate] <span style="font-weight: bold;">dive</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">i acc g</span>
 [] [+ <span style="font-weight: bold;">clone</span>] [] <span style="font-weight: bold;">if</span>]  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">acc acc f g</span>
<span style="font-weight: bold;">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">55 [[positive?] [dec [generate] <span style="font-weight: bold;">dive</span>] [<span style="font-weight: bold;">drop</span> []] <span style="font-weight: bold;">if</span>] [inc <span style="font-weight: bold;">clone</span>] 10
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 [inc <span style="font-weight: bold;">clone</span>] 3 taker
[*]
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">build the 'then' branch</span>
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">-&gt; [+ clone]</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">build the loop body</span>
[[generate] <span style="font-weight: bold;">dive</span> []] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span> [[] <span style="font-weight: bold;">if</span>] <span style="font-weight: bold;">join</span>
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">generate the first item under the loop body</span>
[generate <span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">dip</span>
<span style="font-weight: bold;">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">6 [[positive?] [dec [generate] <span style="font-weight: bold;">dive</span>] [<span style="font-weight: bold;">drop</span> []] <span style="font-weight: bold;">if</span>] [inc <span style="font-weight: bold;">clone</span>] 3
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 2 3 4 [+] <span style="font-weight: bold;">divedown</span>
</pre>
</div>

<pre class="example">
3 4 3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 <span style="font-weight: bold;">true</span> [ inc <span style="font-weight: bold;">clone</span> 5 &lt; ] <span style="font-weight: bold;">loop</span>
</pre>
</div>

<pre class="example">
5
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers
1 dropper <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">start with 1</span>
1000 taker <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">take items</span>
[3 *] each
[odd?] keep
[+ 37 mod] reduce
</pre>
</div>

<pre class="example">
10 [clone [[generate] dip [drop generate] while] dive] [[[something?] [odd? not]] [execute] every?] [generate [[3 *] bail] shielddown] [[positive?] [dec [generate] dive] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [inc clone] 1000
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1025 8 mod
</pre>
</div>

<pre class="example">
1
</pre>
</div>
</div>
</div>

<div id="outline-container-org30dd496" class="outline-4">
<h4 id="org30dd496"><span class="section-number-4">1.5.39.</span> <span class="done DONE">DONE</span> Investigate simpler map/filter impls</h4>
<div class="outline-text-4" id="text-1-5-39">
<div class="org-src-container">
<pre class="src src-kcats">7 8 [+] [] [] <span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">shielddown</span> <span style="font-weight: bold;">dip</span>] decorate [<span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">unwrap</span> prepend [<span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">put</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[+] 8 7
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">3 [1 2 3 4 5 6] [discard odd?] [] <span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">shield</span> <span style="font-weight: bold;">dip</span>] decorate [<span style="font-weight: bold;">swap</span>] <span style="font-weight: bold;">unwrap</span> prepend [<span style="font-weight: bold;">sink</span> [<span style="font-weight: bold;">put</span>] [discard] <span style="font-weight: bold;">branch</span>] <span style="font-weight: bold;">join</span> <span style="font-weight: bold;">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">[1 2 3 4 5 6] 3
</pre>
</div>
</div>
</div>

<div id="outline-container-org88d015c" class="outline-4">
<h4 id="org88d015c"><span class="section-number-4">1.5.40.</span> <span class="done DONE">DONE</span> Allow generator transforms to work on pipes</h4>
<div class="outline-text-4" id="text-1-5-40">
<p>
pipe + [take] = generator
</p>
</div>
</div>
<div id="outline-container-orgf95a1c5" class="outline-4">
<h4 id="orgf95a1c5"><span class="section-number-4">1.5.41.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement hashset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-41">
<p>
Once we have this, we can implement stuff like the <code>distinct</code> transform
function.
</p>
</div>

<div id="outline-container-org230d2e9" class="outline-5">
<h5 id="org230d2e9"><span class="section-number-5">1.5.41.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement set membership check</h5>
<div class="outline-text-5" id="text-1-5-41-1">
<p>
Could possibly piggyback on <code>lookup</code> here, but the semantics are a
little different (nested sets are not allowed, return value is the
same as the key argument).
</p>

<p>
Another option is to call it <code>contains?</code> and check for membership. The
implementation could accept any Sized type, but it's not obvious how
to handle map types - are we checking just for the key, or key/val
pair? I lean slightly toward just the key, but hard to say. For list
types do we convert or promote to set, or just do a (worst case) full
pass over the elements? Vec[Deque] has a contains method so I'm
inclined to just use that.
</p>
</div>

<ol class="org-ol">
<li><a id="org5e3c620"></a><span class="todo TODO">TODO</span> Substring or subcollection<br />
<div class="outline-text-6" id="text-1-5-41-1-1">
<p>
Included as part of this should be substring and subarray checking. eg
<code>"foobar" "bar" contains?</code> should return <code>true</code>. It's a different behavior
when the member and collection are the same type vs different
types. Should probably error when it's two different collection types,
eg <code>[1 2 3] [2 3] set contains?</code> should error.
</p>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-org158ade1" class="outline-4">
<h4 id="org158ade1"><span class="section-number-4">1.5.42.</span> <span class="done DONE">DONE</span> Implement until</h4>
<div class="outline-text-4" id="text-1-5-42">
<p>
like <code>while</code> but always runs the body once.
</p>

<div class="org-src-container">
<pre class="src src-kcats">64 [50 &gt;] [<span style="font-weight: bold;">clone</span> *] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">until</span>
<span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">pred body</span>
[not] <span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">reverse logic</span>
[<span style="font-weight: bold;">shield</span>] decorate <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">add shield to the pred program -&gt; pred body</span>
<span style="font-weight: bold;">join</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">[body ..  pred]</span>
<span style="font-weight: bold;">true</span> <span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">run at least once</span>
<span style="font-weight: bold;">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">4096
</pre>
</div>

<p>
use until in places I wish i'd had it:
laster:
</p>
<div class="org-src-container">
<pre class="src src-kcats">[1 2 3 4] liberate
[] []
[[<span style="font-weight: bold;">nothing</span>?]
 <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">l sl</span>
 [<span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">sl l</span>
  discard <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">l</span>
  [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">sl l</span>
  <span style="font-weight: bold;">swap</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">l sl </span>
 <span style="font-weight: bold;">until</span> <span style="font-weight: bold;">swap</span>
 [[]] <span style="font-weight: bold;">dipdown</span>] <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">replace the empty state</span>
collect
</pre>
</div>

<p>
joiner
</p>
<div class="org-src-container">
<pre class="src src-kcats">[[1 2 3] [4 5 6] [7 8 9]] liberate
[] []
[<span style="font-weight: bold;">nothing</span>?]
[discard <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">r</span>
 [generate] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">r i</span>
 <span style="font-weight: bold;">swap</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">i r</span>
 <span style="font-weight: bold;">clone</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">i i r</span>
 [<span style="font-weight: bold;">join</span>] <span style="font-weight: bold;">dip</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">i r2</span>
] <span style="font-weight: bold;">until</span>  generate
</pre>
</div>
<div class="org-src-container results">
<pre class="src src-kcats">[1 2 3 4 5 6 7 8 9] [] [<span style="font-weight: bold;">take</span>] []
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">[1 2 3 4] liberate generate
</pre>
</div>

<pre class="example">
1 [take] [2 3 4]
</pre>
</div>
</div>

<div id="outline-container-org3c3f71f" class="outline-4">
<h4 id="org3c3f71f"><span class="section-number-4">1.5.43.</span> <span class="todo TODO">TODO</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-5-43">
</div>
<div id="outline-container-org0c63b13" class="outline-5">
<h5 id="org0c63b13"><span class="section-number-5">1.5.43.1.</span> <span class="todo TODO">TODO</span> Implement partialord</h5>
<div class="outline-text-5" id="text-1-5-43-1">
<p>
Each type needs to be comparable to another.
</p>

<div class="org-src-container">
<pre class="src src-kcats">[[<span style="font-style: italic;">"b"</span> 2][<span style="font-style: italic;">"g"</span> 5][<span style="font-style: italic;">"a"</span>, 1][<span style="font-style: italic;">"d"</span> 4] [<span style="font-style: italic;">"c"</span> 3]] association ++sort
</pre>
</div>

<pre class="example">
[1 2 3 4 5]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[-2 10 -8 -12 8 0 1 20]
[5 - abs]
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span>
[ pair] <span style="font-weight: bold;">join</span>
<span style="font-weight: bold;">map</span>  ++sort 
</pre>
</div>

<pre class="example">
Pair is (Int(-2), Int(7))
Pair is (Int(10), Int(5))
Pair is (Int(-8), Int(13))
Pair is (Int(-12), Int(17))
Pair is (Int(8), Int(3))
Pair is (Int(0), Int(5))
Pair is (Int(1), Int(4))
Pair is (Int(20), Int(15))
[8 1 10 0 -2 -8 20 -12]
</pre>


<p>
UHOH
</p>
<div class="org-src-container">
<pre class="src src-kcats">[<span style="font-style: italic;">"hi"</span> <span style="font-style: italic;">"there"</span> <span style="font-style: italic;">"what"</span> <span style="font-style: italic;">"is"</span> <span style="font-style: italic;">"your"</span> <span style="font-style: italic;">"birthdate"</span> <span style="font-style: italic;">"homeboy"</span>]
[]
[<span style="font-weight: bold;">clone</span>] <span style="font-weight: bold;">swap</span> <span style="font-weight: bold;">join</span>
[pair] <span style="font-weight: bold;">join</span>
<span style="font-weight: bold;">map</span>  ++sort 
</pre>
</div>

<pre class="example">
Pair is (Iterable(Sized(String("hi"))), String("hi"))
Pair is (Iterable(Sized(String("there"))), String("there"))
Pair is (Iterable(Sized(String("what"))), String("what"))
Pair is (Iterable(Sized(String("is"))), String("is"))
Pair is (Iterable(Sized(String("your"))), String("your"))
Pair is (Iterable(Sized(String("birthdate"))), String("birthdate"))
Pair is (Iterable(Sized(String("homeboy"))), String("homeboy"))
["birthdate" "hi" "homeboy" "is" "there" "what" "your"]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">8 5 - 
</pre>
</div>

<pre class="example">
3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 [inc] both
</pre>
</div>

<pre class="example">
[[reason "word is not defined"] [unwound [both]] [type error] [asked [both]] [handled true]] [inc] 2 1
</pre>
</div>
</div>

<div id="outline-container-org720425b" class="outline-5">
<h5 id="org720425b"><span class="section-number-5">1.5.43.2.</span> <span class="todo TODO">TODO</span> Make floats hashable</h5>
<div class="outline-text-5" id="text-1-5-43-2">
<p>
This will allow floats to be added to the <code>KeyItem</code> enum. Floats are not
normally hashable, because mathematically identical numbers are not
always represented the same way in memory and wouldn't hash the
same. But for the purposes of kcats, I think this doesn't matter. We
can document that you can't expect (10.0 + 10.0) and (15.0 + 5.0) to
be the same map key.
</p>

<p>
This will then allow a list that contains floats, to be sorted, or be
able to use float values as a sort-by key.
</p>
</div>
</div>

<div id="outline-container-orgf465ee5" class="outline-5">
<h5 id="orgf465ee5"><span class="section-number-5">1.5.43.3.</span> <span class="todo TODO">TODO</span> Implement compare</h5>
<div class="outline-text-5" id="text-1-5-43-3">
<p>
Should expose Rust's comparison function. That will allow a native
sort function, for max flexibility (but not performance).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"a"</span> compare
</pre>
</div>

<pre class="example">
equal
</pre>


<div class="org-src-container">
<pre class="src src-kcats">[<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"b"</span>] [<span style="font-style: italic;">"a"</span> <span style="font-style: italic;">"c"</span>] compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span style="font-style: italic;">"foo"</span> bytes [1] compare
</pre>
</div>

<pre class="example">
less
</pre>


<p>
This should work - the empty set and map maybe can't be compared but Nothing should be in there.
</p>
<div class="org-src-container">
<pre class="src src-kcats">[] -1000 compare
</pre>
</div>

<pre class="example">
less
</pre>
</div>
</div>
</div>

<div id="outline-container-orga6a93e4" class="outline-4">
<h4 id="orga6a93e4"><span class="section-number-4">1.5.44.</span> <span class="todo INPROGRESS">INPROGRESS</span> CI on github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-org70e47a3" class="outline-4">
<h4 id="org70e47a3"><span class="section-number-4">1.5.45.</span> <span class="done DONE">DONE</span> Add a kcats logo to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-org896035b" class="outline-4">
<h4 id="org896035b"><span class="section-number-4">1.5.46.</span> <span class="done DONE">DONE</span> Add a video snippet of repl interaction to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-org545cc61" class="outline-4">
<h4 id="org545cc61"><span class="section-number-4">1.5.47.</span> <span class="todo INPROGRESS">INPROGRESS</span> Write an alpha release announcement&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
<div class="outline-text-4" id="text-1-5-47">
<div class="org-src-container">
<pre class="src src-fundamental">Announcing the Alpha Release of kcats: A Simple, Beginner-Friendly,
Stack-Based Programming Language

Hello everyone,

I'm excited to introduce the alpha release of kcats, a fresh take on
stack-based programming languages, inspired by the language Joy,
specifically designed with simplicity, learnability, and functionality
in mind.

Our aim with kcats is to make programming languages more accessible to
everyone. We believe that existing languages require learning too many
specialized tools and arcane symbols. kcats addresses these issues by
offering a streamlined, intuitive alternative.

Key features of kcats:

    Simplicity: kcats emphasizes fewer, general-purpose tools instead
    of a complex array of specialized ones. Its syntax uses simple
    words, numbers, and text, completely doing away with cryptic
    symbols - there are no periods, exclamation points, semicolons,
    equals, plusses, ampersands, or asterisks.

    Beginner-friendly: kcats is designed to be easy to learn and
    understand, even for beginner programmers. It uses simple
    programming concepts including stacks, primitive datatypes, lists,
    functions, and pipes.

    Effective Documentation: kcats documentation is crafted to be as
    intuitive as possible, focusing on clear examples rather than
    complex explanations.

    Powerful and Versatile: Despite its simplicity, kcats is designed
    to be a powerful tool capable of handling a wide range of
    programming tasks including API client/server, networking
    applications, and more.

    Interoperability: kcats is designed to interact effectively with
    other systems. It is built around the principle that everything
    should be a value and should be serializable.

    A Focus on Tooling: kcats intends to make tool development,
    including IDEs and debuggers, as easy as possible.

As this is the alpha release, we eagerly welcome all feedback,
contributions, and constructive criticisms from the community. While
the focus of kcats isn't on speed, there's no theoretical reason why
it must be slow, so over time, with your help, we can continue to
optimize and enhance it.

Join us in exploring this new language and contribute to making
programming more accessible to everyone. Your feedback is essential to
making it intuitive and easy to use!

Please check out our alpha release here: (link to the repository)

Happy coding!

Best, (Your Name)

</pre>
</div>
</div>
</div>

<div id="outline-container-orge4ff425" class="outline-4">
<h4 id="orge4ff425"><span class="section-number-4">1.5.48.</span> <span class="todo TODO">TODO</span> Post announcement on various forums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
<div class="outline-text-4" id="text-1-5-48">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> Hacker news</li>
<li class="off"><code>[&#xa0;]</code> Reddit r/concatenative</li>
<li class="off"><code>[&#xa0;]</code> Reddit r/programming</li>
<li class="off"><code>[&#xa0;]</code> r/learnprogramming</li>
<li class="off"><code>[&#xa0;]</code> r/coding</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Skyrod Vactai</p>
<p class="date">Created: 2023-08-07 Mon 02:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>