# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language Lexicon
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Builtin words documentation
** Base words
The actual functionality of axiom words can't be defined in kcats
itself, but we can define some other properties, such as the spec
(what types the word uses and returns), and some example uses.
#+begin_src kcats :tangle src/kcats/builtins.kcats
[= [[spec [[item item] [boolean]]]
    [examples [[[1 2 =] [false]]
               [[1 1 =] [true]]
               [[[] [] =]  [true]]
               [[[1] [] =]  [false]]
               [[[1 [false]] [1 [false]] =]  [true]]
               [[[1.0 ["foo"]] [1.0 ["foo"]] =]  [true]]
               [["hi" "hi" =] [true]]
               [["hi" "there" =] [false]]
               [[[] false =] [false]]
               [[[1.0 ["foo"]] [1.0 ["bar"]] =]  [false]]
               [[[[] [] association =] [true]]]]]]]

[+ [[spec [[number number] [number]]]
    [examples [[[1 2 +] [3]]
               [[1.1 2.2 +] [3.3]]
               [[1 2.2 +] [3.2]]]]]]

[- [[spec [[number number] [number]]]
    [examples [[[2 1 -] [1]]
               [[1.1 2.2 -] [-1.1]]
               [[2.2 1 -] [1.2]]]]]]

[* [[spec [[number number] [number]]]]]
[/ [[spec [[number number] [number]]]]]
[min [[spec [[number number] [number]]]]]
[max [[spec [[number number] [number]]]]]
[quot [[spec [[number number] [number]]]]]
[rem [[spec [[number number] [number]]]]]
[mod [[spec [[number number] [number]]]]]
[< [[spec [[number number] [boolean]]]]]
[<= [[spec [[number number] [boolean]]]]]
[>= [[spec [[number number] [boolean]]]]]

[ceil [[spec [[number] [integer]]]]]
[sqrt [[spec [[number] [number]]]]]

[> [[spec [[number number] [boolean]]]
    [examples [[[2 1 >] [true]]
               [[1.1 2.2 >] [false]]
               [[2.2 1 >] [true]]]]]]

[inc [[spec [[number] [number]]]
      [examples [[[1 inc] [2]]
                 [[-1 inc] [0]]
                 [[99 inc] [100]]]]]]

[dec [[spec [[number] [number]]]]]

[odd? [[spec [[number] [boolean]]]]]
[even? [[spec [[number] [boolean]]]]]
[zero? [[spec [[number] [boolean]]]]]

[discard [[spec [[item] []]]
          [examples [[[1 2 3 discard] [1 2]]
                     [[1 2 3 [a b c] discard] [1 2 3]]]]]]

[clone [[spec [[[item a]]
               [[item a] [item a]]]]
        [examples [[[1 2 3 clone] [1 2 3 3]]]]]]

[swap [[spec [[[item a] [item b]]
              [[item b] [item a]]]]
       [examples [[[1 2 3 swap] [1 3 2]]]]]]

[swapdown [[spec [[[item a] [item b] [item c]]
                  [[item a] [item c] [item b]]]]
           [examples [[[1 2 3 swapdown] [2 1 3]]]]]]

[float [[spec [[[item a] [item b] [item c]]
               [[item c] [item a] [item b]]]]
        [examples [[[1 2 3 float] [2 3 1]]]]]]

[sink [[spec [[[item a] [item b] [item c]]
              [[item b] [item c] [item a]]]]
       [examples [[[1 2 3 sink] [3 1 2]]]]]]

[execute [[spec [[program] [*]]]
          [examples [[[[1 2 +] execute] [3]]
                     [[2 [+] 4 swap execute] [6]]]]]]

[wrap [[spec [[item] [list]]]
       [examples [[[1 wrap] [[1]]]
                  [[[1 2] wrap] [[[1 2]]]]]]]]

[unwrap [[spec [[list] [*]]]
         [examples [[[[1] unwrap] [1]]]]]]

[rest [[spec [[list] [list]]]
       [examples [[[[1 2 3] rest] [[2 3]]]]]]]

[reverse [[spec [[list] [list]]]
          [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]]

[fail [[spec [[string] [*]]]]]

[dip [[spec [[program [item a]] [[item a] *]]]
      [examples [[[1 8 [inc] dip] [2 8]]
                 [[1 2 [dec] unwrap
                   [+] dip] [3 dec]]]]]]

[list? [[spec [[item] [boolean]]]
        [examples [[[[1] list?] [true]]
                   [[[] list?] [true]]
                   [[5 list?] [false]]]]]]

[number? [[spec [[item] [boolean]]]
          [examples [[[[1] number?] [false]]
                     [[[] number?] [false]]
                     [[5 number?] [true]]
                     [[5.01 number?] [true]]]]]]

[string [[spec [[item] [string]]]
         [examples [[[1 string] ["1"]]
                    [[[1 2 3] string] ["[1 2 3]"]]
                    [[[] string] ["[]"]]]]]]

[read [[spec [[string] [item]]]
       [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]]

[inscribe [[spec [[list list] []]]
           [examples [[[[add3] [[definition [3 +]]
                                [spec [[number] [number]]]]
                        inscribe
                        5 add3] [8]]]]]]

[branch [[spec [[[program false-branch]
                 [program true-branch]
                 [item condition]]
                [*]]]
         [examples [[[5 true [3 *] [4 +] branch] [15]]
                    [[6 false [3 *] [4 +] branch] [10]]]]]]

[step [[spec [[program list] [*]]]
       [examples [[[1 [2 3 4] [*] step] [24]]
                  [[1 [] [*] step] [1]]]]]]

[recur [[spec [[[program rec2]
                [program rec1]
                [program true-branch]
                [program pred]]
               [*]]]
        [examples [[[3
                     [1 <=] [] [clone dec] [execute *]
                     recur]
                    [6]]]]]]

[loop [[spec [[program [item flag]] [*]]]
       [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]]

[unpack [[spec [[list] [item list]]]
         [examples [[[["a" "b" "c"] unpack] [["b" "c"] "a"]]]]]]

[range [[spec [[integer integer] [list]]]
        [examples [[[1 5 range] [[1 2 3 4]]]]]]]

[evert [[spec [[list] [list *]]]
        [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]]

[and [[spec [[item item] [item]]]
      [examples [[[1 odd? 2 even? and] [true]]]]]]

[or [[spec [[item item] [item]]]
     [examples [[[1 odd? 3 even? or] [true]]
                [[1 2 or] [1]]
                [[[] 2 or] [2]]
                [[[] [] or] [false]]]]]]

[not [[spec [[item] [boolean]]]
      [examples [[[1 even? not] [true]]
                 [[false not] [true]]
                 [[true not] [false]]
                 [[[] not] [true]]]]]]

[join [[spec [[item item] [item]]]
       [examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]
                  [["ab" "cd" join] ["abcd"]]
                  [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]]]]

[pack [[spec [[item list] [list]]]
       [examples [[[[] 1 pack] [[1]]]
                  [[[1 2 3] 4 pack] [[1 2 3 4]]]
                  ;; [["foo" \d pack] ["food"]] ;; breaks prod, where chars are not valid data
                  [["foo" bytes 32 pack string] ["foo "]]]]]]

[dipdown [[spec [[program
                  [item a]
                  [item b]]
                 [[item a] [item b] *]]]
          [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]]

[count [[spec [[list]
               [number]]]
        [examples [[[["a" "b" "c"] count] [3]]]]]]

[first [[spec [[list] [item]]]
        [examples [[[[4 5 6] first] [4]]]]]]

[second [[spec [[list] [item]]]
         [examples [[[[4 5 6] second] [5]]]]]]

[bytes? [[spec [[item] [boolean]]]]]

[bytes [[spec [[item] [bytes]]]]]

[string? [[spec [[item] [boolean]]]
          [examples [[["hi" string?] [true]]
                     [["" string?] [true]]
                     [[["hi"] string?] [false]]
                     [[true string?] [false]]]]]]

[word? [[spec [[item] [boolean]]]
        [examples [[[foo word?] [true]]
                   [[[foo] unwrap word?] [true]]
                   [[true word?] [false]]]]]] ;; TODO: but arguably 'true' is a word

[environment [[spec [[association] [list]]]]]

[eval-step [[spec [[list] [list]]]
            [examples [[[[[expression [1 inc]]] environment
                         eval-step eval-step
                         [stack] lookup]
                        [[2]]]]]]]

[evaluate [[spec [[list] [list]]]
          [examples [[[[[expression [1 2 3 4 + *]]] environment
                       evaluate
                       [stack] lookup]
                      [[14 1]]]]]]]

[dictionary [[spec [[] [list]]]]]

[handle [[spec [[] []]]]]

[resume [[spec [[] []]]
         [definition []]]]
#+end_src

#+RESULTS:
: 
: [[resume [[spec [[] []]] [definition []]]] [handle [[spec [[] []]]]] [dictionary [[spec [[] [list]]]]] [evaluate [[spec [[list] [list]]]]] [eval-step [[spec [[list] [list]]]]] [environment [[spec [[program] [list]]]]] [word? [[spec [[item] [boolean]]] [examples [[[foo word?] [true]] [[[foo] unwrap word?] [true]] [[true word?] [false]]]]]] [string? [[spec [[item] [boolean]]] [examples [[["hi" string?] [true]] [["" string?] [true]] [[["hi"] string?] [false]] [[true string?] [false]]]]]] [bytes [[spec [[item] [bytes]]]]] [bytes? [[spec [[item] [boolean]]]]] [second [[spec [[list] [item]]] [examples [[[[4 5 6] second] [5]]]]]] [first [[spec [[list] [item]]] [examples [[[[4 5 6] first] [4]]]]]] [count [[spec [[list] [number]]] [examples [[[["a" "b" "c"] count] [3]]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]] [[1 "hi" "hi" =] [true 1]]]]]] [dipdown [[spec [[program [item a] [item b]] [[item a] [item b] *]]] [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]] [pack [[spec [[item list] [list]]] [examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]] [["foo" bytes 32 pack string] ["foo "]]]]]] [join [[spec [[item item] [item]]] [examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]] [["ab" "cd" join] ["abcd"]] [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]]]] [not [[spec [[item] [boolean]]] [examples [[[1 even? not] [true]] [[false not] [true]] [[true not] [false]] [[[] not] [true]]]]]] [or [[spec [[item item] [item]]] [examples [[[1 odd? 3 even? or] [true]]]]]] [and [[spec [[item item] [item]]] [examples [[[1 odd? 2 even? and] [true]]]]]] [evert [[spec [[list] [list *]]] [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]] [range [[spec [[integer integer] [list]]] [examples [[[1 5 range] [[1 2 3 4]]]]]]] [unpack [[spec [[list] [item list]]] [examples [[[["a" "b" "c"] unpack] [["b" "c"] "a"]]]]]] [loop [[spec [[program [item flag]] [*]]] [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]] [recur [[spec [[[program rec2] [program rec1] [program true-branch] [program pred]] [*]]] [examples [[[3 [1 <=] [] [clone dec] [execute *] recur] [6]]]]]] [step [[spec [[program list] [*]]] [examples [[[1 [2 3 4] [*] step] [24]] [[1 [] [*] step] [1]]]]]] [branch [[spec [[[program false-branch] [program true-branch] [item condition]] [*]]] [examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]]]] [inscribe [[spec [[list word] []]] [examples [[[[add3] unwrap [[definition [3 +]] [spec [[number] [number]]]] inscribe 5 add3] [8]]]]]] [read [[spec [[string] [item]]] [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]] [string [[spec [[item] [string]]] [examples [[[1 string] ["1"]] [[[1 2 3] string] ["[1 2 3]"]] [[[] string] ["[]"]]]]]] [number? [[spec [[item] [boolean]]] [examples [[[[1] number?] [false]] [[[] number?] [false]] [[5 number?] [true]] [[5.01 number?] [true]]]]]] [list? [[spec [[item] [boolean]]] [examples [[[[1] list?] [true]] [[[] list?] [true]] [[5 list?] [false]]]]]] [dip [[spec [[program [item a]] [[item a] *]]] [examples [[[1 8 [inc] dip] [2 8]] [[1 2 [dec] unwrap [+] dip] [3 dec]]]]]] [fail [[spec [[string] [*]]]]] [reverse [[spec [[list] [list]]] [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]] [rest [[spec [[list] [list]]] [examples [[[[1 2 3] rest] [[2 3]]]]]]] [unwrap [[spec [[list] [*]]] [examples [[[[1] unwrap] [1]]]]]] [wrap [[spec [[item] [list]]] [examples [[[1 wrap] [[1]]] [[[1 2] wrap] [[[1 2]]]]]]]] [execute [[spec [[program] [*]]] [examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]]]] [sink [[spec [[[item a] [item b] [item c]] [[item b] [item c] [item a]]]] [examples [[[1 2 3 sink] [3 1 2]]]]]] [float [[spec [[[item a] [item b] [item c]] [[item c] [item a] [item b]]]] [examples [[[1 2 3 float] [2 3 1]]]]]] [swapdown [[spec [[[item a] [item b] [item c]] [[item a] [item c] [item b]]]] [examples [[[1 2 3 swapdown] [2 1 3]]]]]] [swap [[spec [[[item a] [item b]] [[item b] [item a]]]] [examples [[[1 2 3 swap] [1 3 2]]]]]] [clone [[spec [[[item a]] [[item a] [item a]]]] [examples [[[1 2 3 clone] [1 2 3 3]]]]]] [discard [[spec [[item] []]] [examples [[[1 2 3 discard] [1 2]] [[1 2 3 [a b c] discard] [1 2 3]]]]]] [zero? [[spec [[number] [boolean]]]]] [even? [[spec [[number] [boolean]]]]] [odd? [[spec [[number] [boolean]]]]] [dec [[spec [[number] [number]]]]] [inc [[spec [[number] [number]]] [examples [[[1 inc] [2]] [[-1 inc] [0]] [[99 inc] [100]]]]]] [> [[spec [[number number] [boolean]]] [examples [[[2 1 >] [true]] [[1.1 2.2 >] [false]] [[2.2 1 >] [true]]]]]] [sqrt [[spec [[number] [number]]]]] [ceil [[spec [[number] [integer]]]]] [>= [[spec [[number number] [boolean]]]]] [<= [[spec [[number number] [boolean]]]]] [< [[spec [[number number] [boolean]]]]] [mod [[spec [[number number] [number]]]]] [rem [[spec [[number number] [number]]]]] [quot [[spec [[number number] [number]]]]] [max [[spec [[number number] [number]]]]] [min [[spec [[number number] [number]]]]] [/ [[spec [[number number] [number]]]]] [* [[spec [[number number] [number]]]]] [- [[spec [[number number] [number]]] [examples [[[2 1 -] [1]] [[1.1 2.2 -] [-1.1]] [[2.2 1 -] [1.2]]]]]] [+ [[spec [[number number] [number]]] [examples [[[1 2 +] [3]] [[1.1 2.2 +] [3.3]] [[1 2.2 +] [3.2]]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 2 =] [false]] [[1 1 =] [true]] [[[] [] =] [true]] [[[1] [] =] [false]] [[[1 [false]] [1 [false]] =] [true]] [[[1 ["foo"]] [1 ["foo"]] =] [true]] [[[1 ["foo"]] [1 ["bar"]] =] [false]]]]]]]

** Association words
#+begin_src kcats :tangle src/kcats/builtins.kcats
[++lookup [[spec [[word association] [item]]]]]

[association? [[spec [[item] [boolean]]]
               [examples [[[[[a b] [c d]] association?] [true]]]]]]

[association [[spec [[item] [association]]]
              [examples [[[[[a b] [c d]] association
                           [[c d] [a b]] association =]
                          [true]]

                         [[[[a b] [c d]]
                           [[c d] [a b]] association =]
                          [false]]

                         [[[[a b] [c d]]
                           [[a b] [c d]] association =]
                          
                          [false]]]]]]

[assign [[spec [[[item value]
                 [list keys]
                 association]
                [association]]]
         [examples [[[[[a b] [c d]] [a] 5 assign]
                     [[[a 5] [c d]] association]]

                    [[[[a b] [c d]] [e] 5 assign]
                     [[[a b] [c d] [e 5]] association]]

                    [[[[a b] [c [[d e]]]] [c d] 5 assign]
                     [[[a b] [c [[d 5]]]] association]]]]]]


[decide [[spec [[[association test-expr-pairs]] [*]]]
         [doc "Takes a list of choices (pairs of test, program) and
                executes the first program whose test passes. if none
                pass, returns 'nothing'. Stack is reset between
                testing conditions."]
         [examples [[[5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide]
                     [5 "five"]]
                    
                    [[9 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide]
                     
                     [9 "something else"]]
                    [[9 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]]
                      decide]
                     [9 []]]]]]]
#+end_src
** Pipes
#+begin_src kcats :tangle src/kcats/builtins.kcats
[atom [[spec [[item] [pipe]]]]]

[buffer [[spec [[integer] [pipe]]]]]

[timeout [[spec [[integer] [pipe]]]]]

[filled [[spec [[list] [pipe]]]]]

[handoff [[spec [[] [pipe]]]]]

[select [[spec [[[list pipes]] [item pipe [list pipes]]]]]]

[take [[spec [[[pipe out]] [item [pipe out]]]]]]

[put [[spec [[item [pipe in]] [[pipe in]]]]]]

[close [[spec [[[pipe p]] [[pipe p]]]]]]

[closed? [[spec [[pipe] [boolean]]]]]

[spawn [[spec [[program] []]]]]

[file-in [[spec [[string] [pipe]]]]]

[file-out [[spec [[string] [pipe]]]]]

[serversocket [[spec [[string integer] [pipe]]]]]
#+end_src
* Lexicon
** Base standard library
#+begin_src kcats :tangle src/kcats/lexicon.kcats
[shield [[spec [[program]
                [item]]]
         [doc "Runs program keeping top of stack produced but protects existing items from being consumed."]
         [definition [[snapshot] dip inject first]]
         [examples [[[1 2 3 [=] shield] [1 2 3 false]]]]]]

[shielddown [[spec [[program item]
                    [item]]]
             [definition [shield swap discard]]
             [examples [[[1 2 3 [=] shielddown] [1 2 false]]]]]]

[shielddowndown [[spec [[[program p] [item consumed] [item consumed]]
                        [[item result]]]]
                 [definition [shield [discard discard] dip]]
                 [examples [[[1 2 3 [+ +] shielddowndown] [1 6]]]]]]

[if [[spec [[[program false-branch]
             [program true-branch]
             [program condition]]
            [*]]]
     [definition [[shield] dipdown branch]]
     [examples [[[5 [5 =] [3 *] [4 +] if] [15]]
                [[6 [5 =] [3 *] [4 +] if] [10]]]]]]


[every? [[spec [[program list] boolean]]
         [definition [[shielddown] swap prepend ;; building r1, run pred with unary
                      [unpack swap] swap pack ;; add rest of dip program
                      [dip swap not] join ;; add the rest of outer dip
                      wrap [dip or] join ;; add rest of r1
                      ;; put the other recur clauses under r1
                      [false
                       [[[nothing?] shield] dip
                        swap [or] shielddown] ;; the 'if' 
                       [not]] ;; then
                      dip ;; underneath the r1
                      [execute] recur ;; r2 and recur!
                      swap discard]]
         [examples [[[[2 4 6] [even?] every?] [true]]
                    [[[2 4 5] [even?] every?] [false]]
                    [[[] [even?] every?] [true]]
                    [[[2 4 6] [] every?] [true]]
                    [[11 [2 4 6] [+ odd?] every?] [true 11]]
                    [[12 [[even?] [positive?] [3 rem 0 =]] [execute] every?] [true 12]]]]]]

[any? [[spec [[program list] boolean]]
       [definition [[shielddown] swap prepend ;; building r1, run pred with unary
                    [unpack swap] swap pack ;; add rest of dip program
                    [dip swap] join ;; add the rest of outer dip
                    wrap [dip or] join ;; add rest of r1
                    ;; put the other recur clauses under r1
                    [false
                     [[[nothing?] shield] dip
                      swap [or] shielddown] ;; the 'if' 
                     []] ;; then
                    dip ;; underneath the r1
                    [execute] recur ;; r2 and recur!
                    swap discard]]
       [examples [[[[2 4 6] [even?] any?] [true]]
                  [[[3 5 7] [even?] any?] [false]]
                  [[[] [even?] any?] [false]]
                  [[[2 4 6] [] any?] [2]]
                  [[11 [3 5 6] [+ odd?] any?] [true 11]]
                  [[-15 [[even?] [positive?] [3 rem 0 =]] [execute] any?] [true -15]]]]]]

[primrec [[spec [[[program rec1]
                  [program exit]
                  [number data]]
                 [*]]]
          [definition [[execute] swap join ;; add execute to rec1 to be recurs rec2
                       [[discard] swap join] dip ;; add discard to exit condition
                       [[zero?]] dipdown  ;; put the condition on bottom
                       [[clone dec]] dip ;; add the r1
                       recur]] ;; now its generic recur
          [examples [[[5 [1] [*] primrec] [120]]]]]]
[prepend [[spec [[item list]
                 [list]]]
          [definition [wrap swap join]]
          [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]]

[assert [[spec [[program]
                [*]]]
         [definition [snapshot ;; save stack to print in err message
                      [shield] dip swap ;; run the assertion under the saved stack
                      [discard] ;; if passes, drop the saved stack, dont need
                      [string ["assertion failed "] dip join fail] ;; else throw err
                      branch]]]]

[inject [[spec [[program list]
                [list]]]
         [doc "Inject the quoted program into the list below
                   it (runs the program with the list as its
                   stack).  Does not affect the rest of the stack."]
         [definition [swap evert unpack dip evert]]
         [examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]]]]

[snapshot [[spec [[] [list]]]
           [doc "Save the whole stack as a list on the stack"]
           [definition [[] evert clone evert unwrap]]
           [examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]]
                      [[snapshot] [[]]]]]]]

[map [[spec [[program list] [list]]]
      [definition [[snapshot [] swap] ;; save original stack, and
                   ;; add an empty list to
                   ;; hold results
                   dipdown ;; do this underneath the program and list
                   [wrap swap clone float] ;; program snippet a to
                   ;; copy the original stack
                   ;; that we saved, will make
                   ;; new copy for each item
                   ;; in the list

                   swap pack ;; pack the map program into the
                   ;; partial program a above

                   ;; inject the map program into the stack copy,
                   ;; take the first item and pack it into the
                   ;; result list. the join here is to literally
                   ;; add the list item to the stack copy,
                   ;; without actually executing it, in case its
                   ;; a bare word
                   [[swap join] dip inject first swap [pack] dip]
                   join ;; add the program snippet b above to the
                   ;; snippet a, to get a program for step
                   step ;; step through the above program, using
                   ;; the list as data
                   discard ;; we dont need the copy of the
                   ;; original stack anymore
                  ]]
      [examples [[[[1 2 3] [inc] map] [[2 3 4]]]
                 [[1 [1 2 3] [+] map] [[2 3 4] 1]]
                 [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]]
                 [[7 9 [+] [] map] [[+] 9 7]]]]]]

[filter [[spec [[program list] [list]]]
         [definition [[snapshot [] swap]
                      dipdown
                      ;; clone the original value so we can save it in results if needed
                      [[clone] dip clone wrap swapdown]
                      swap pack
                      [join inject first
                       ;; if passes filter, pack it into results
                       [[pack]]
                       ;; othewise discard it
                       [[discard]]
                       branch
                       swapdown
                       dip]
                      join step discard]]
         [examples [[[[1 2 3] [odd?] filter] [[1 3]]]
                    [[[2 4 6] [odd?] filter] [[]]]
                    [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]]]]

[nothing? [[spec [[item] [boolean]]]
           [definition [[] =]]
           [examples [[[[] nothing?] [true]]
                      [[1 nothing?] [false]]
                      [[false nothing?] [false]]]]]]

[something? [[spec [[item] [boolean]]]
             [definition [nothing? not]]
             [examples [[[1 something?] [true]]
                        [[false something?] [true]]
                        [[[] something?] [false]]]]]]

[while [[spec [[[program body]
                [program pred]]
               [*]]]
        [definition [swap wrap [shield] join ;; add shield to the pred program
                     clone dipdown ;; run it on the previous ToS
                     join loop]]
        [examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]]]]

[times [[spec [[[program body]
                [integer howmany]]
               [*]]]
        [definition [[dec] swap pack [dip] join ;; build [dec body dip]
                     [0 >] swap
                     while
                     discard]]]]

[pair [[spec [[item item] [list]]]
       [definition [[wrap] dip pack]]
       [examples [[[1 2 pair] [[1 2]]]
                  [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]]]]

[both? [[spec [[program item item] [boolean]]]
        [definition [sink pair swap every?]]
        [examples [[[1 2 [odd?] both?] [false]]
                   [[1 3 [odd?] both?] [true]]]]]]

[positive? [[spec [[number] [boolean]]]
            [definition [0 >]]]]

[negative? [[spec [[number] [boolean]]]
            [definition [0 <]]]]

[zero? [[spec [[number] [boolean]]]
        [definition [0 =]]
        [examples [[[0 zero?] [true]]
                   [[0.0 zero?] [true]]
                   [[-0.00001 zero?] [false]]
                   [[1.1 zero?] [false]]]]]]

[error? [[spec [[item] [boolean]]]
         [definition [[[association?]
                       [type [error] unwrap =]]
                      [execute] every?
                      swap discard]]]]

[recover [[spec [[program program] [*]]]
          [definition [[[handle] join] dip ;; add handle to the end of test
                       [snapshot] dipdown ;; rec test ss
                       sink inject ;; res rec
                       [first error?] ;; err? res rec
                       [first swap execute];; drop the snapshot and run recovery
                       [evert discard] ;; use snapshot as stack
                       if]]
         [examples [[[[+]
                      [discard 1
                       [+] [discard 2 +]
                       recover]
                      recover]
                     [3]]
                    
                    [5
                     [1 2 "oh fudge"]
                     [[+]
                      [discard discard]
                      recover]
                     map]
                    [5 [6 7 5]]

                    [[swap] [swap] recover]
                    [swap]]]]]
#+end_src

#+RESULTS:
: 
: [[recover [[spec [[program program] [*]]] [definition [[[handle] join] dip [snapshot] dipdown sink inject [first error?] [first swap execute] [evert discard] if]] [examples [[[[+] [discard 1 [+] [discard 2 +] recover] recover] [3]] [5 [1 2 "oh fudge"] [[+] [discard discard] recover] map] [5 [6 7 5]]]]]] [error? [[spec [[item] [boolean]]] [definition [[[association?] [type [error] unwrap =]] [execute] every? swap discard]]]] [zero? [[spec [[number] [boolean]]] [definition [0 =]] [examples [[[0 zero?] [true]] [[0 zero?] [true]] [[-0.00001 zero?] [false]] [[1.1 zero?] [false]]]]]] [negative? [[spec [[number] [boolean]]] [definition [0 <]]]] [positive? [[spec [[number] [boolean]]] [definition [0 >]]]] [both? [[spec [[program item item] [boolean]]] [definition [sink pair swap every?]] [examples [[[1 2 [odd?] both?] [false]] [[1 3 [odd?] both?] [true]]]]]] [pair [[spec [[item item] [list]]] [definition [[wrap] dip pack]] [examples [[[1 2 pair] [[1 2]]] [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]]]] [times [[spec [[[program body] [integer howmany]] [*]]] [definition [[dec] swap pack [dip] join [0 >] swap while discard]]]] [while [[spec [[[program body] [program pred]] [*]]] [definition [swap wrap [shield] join clone dipdown join loop]] [examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]]]] [something? [[spec [[item] [boolean]]] [definition [nothing? not]] [examples [[[1 something?] [true]] [[false something?] [true]] [[[] something?] [false]]]]]] [nothing? [[spec [[item] [boolean]]] [definition [[] =]] [examples [[[[] nothing?] [true]] [[1 nothing?] [false]] [[false nothing?] [false]]]]]] [filter [[spec [[program list] [list]]] [definition [[snapshot [] swap] dipdown [[clone] dip clone wrap swapdown] swap pack [join inject first [[pack]] [[discard]] branch swapdown dip] join step discard]] [examples [[[[1 2 3] [odd?] filter] [[1 3]]] [[[2 4 6] [odd?] filter] [[]]] [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]]]] [map [[spec [[program list] [list]]] [definition [[snapshot [] swap] dipdown [wrap swap clone float] swap pack [[swap join] dip inject first swap [pack] dip] join step discard]] [examples [[[[1 2 3] [inc] map] [[2 3 4]]] [[1 [1 2 3] [+] map] [[2 3 4] 1]] [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]] [[7 9 [+] [] map] [[+] 9 7]]]]]] [snapshot [[spec [[] [list]]] [doc "Save the whole stack as a list on the stack"] [definition [[] evert clone evert unwrap]] [examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]] [[snapshot] [[]]]]]]] [inject [[spec [[program list] [list]]] [doc "Inject the quoted program into the list below\n                   it (runs the program with the list as its\n                   stack).  Does not affect the rest of the stack."] [definition [swap evert unpack dip evert]] [examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]]]] [assert [[spec [[program] [*]]] [definition [snapshot [shield] dip swap [discard] [string ["assertion failed "] dip join fail] branch]]]] [prepend [[spec [[item list] [list]]] [definition [wrap swap join]] [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]] [primrec [[spec [[[program rec1] [program exit] [number data]] [*]]] [definition [[execute] swap join [[discard] swap join] dip [[zero?]] dipdown [[clone dec]] dip recur]] [examples [[[5 [1] [*] primrec] [120]]]]]] [any? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [unpack swap] swap pack [dip swap] join wrap [dip or] join [false [[[nothing?] shield] dip swap [or] shielddown] []] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] any?] [true]] [[[3 5 7] [even?] any?] [false]] [[[] [even?] any?] [false]] [[[2 4 6] [] any?] [2]] [[11 [3 5 6] [+ odd?] any?] [true 11]] [[-15 [[even?] [positive?] [3 rem 0 =]] [execute] any?] [true -15]]]]]] [every? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [unpack swap] swap pack [dip swap not] join wrap [dip or] join [false [[[nothing?] shield] dip swap [or] shielddown] [not]] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] every?] [true]] [[[2 4 5] [even?] every?] [false]] [[[] [even?] every?] [true]] [[[2 4 6] [] every?] [true]] [[11 [2 4 6] [+ odd?] every?] [true 11]] [[12 [[even?] [positive?] [3 rem 0 =]] [execute] every?] [true 12]]]]]] [if [[spec [[[program false-branch] [program true-branch] [program condition]] [*]]] [definition [[shield] dipdown branch]] [examples [[[5 [5 =] [3 *] [4 +] if] [15]] [[6 [5 =] [3 *] [4 +] if] [10]]]]]] [shielddowndown [[spec [[[program p] [item consumed] [item consumed]] [[item result]]]] [definition [shield [discard discard] dip]] [examples [[[1 2 3 [+ +] shielddowndown] [1 6]]]]]] [shielddown [[spec [[program item] [item]]] [definition [shield swap discard]] [examples [[[1 2 3 [=] shielddown] [1 2 false]]]]]] [shield [[spec [[program] [item]]] [doc "Runs program keeping top of stack produced but protects existing items from being consumed."] [definition [[snapshot] dip inject first]] [examples [[[1 2 3 [=] shield] [1 2 3 false]]]]]]]

** Associative words
#+begin_src kcats :tangle src/kcats/lexicon.kcats
;; Associative words
[update [[spec [[program [list keys] association]
                [association]]]
         [definition [[[lookup] shield] dip ;; m ks v p
                      shielddown
                      assign]]
         [examples [[[[[a 1] [b 2]] [b] [inc] update]
                     [[[a 1] [b 3]] association]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update]
                     [[[a [[c 4] [d 5]]] [b 2]] association]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update]
                     [[[a [[c 15] [d 5]]] [b 2]] association]]

                    [[[[a 1] [b 2]] [d] [5] update]
                     [[[a 1] [b 2] [d 5]] association]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update]
                     [[[a [[c 3] [d 5] [e 11]]] [b 2]] association]]]]]]

[lookup [[spec [[[list keys] association] [item]]]
         [definition [[[[swap association?] ;; it's a map
                        ;; [swap something?] ;; it's not empty
                        [something?]] ;; the keylist is not empty
                       [execute]
                       every?]
                      [unpack swap [++lookup] dip] ;; extract the first key and lookup
                      while

                      [something?]
                      ;; fail if we could not drill down all the way
                      ["Lookup attempted on non association value" fail]
                      [discard]  ;; get rid of remaining keylist
                      if]]
         [examples [[[[[a b] [c d]] [a] lookup] [[b] unwrap]]
                    [[[[a b] [c d]] [e] lookup] [[]]]
                    [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] unwrap]]]]]]

[unassign [[spec [[[item key] association] [association]]]
           [examples [[[[[a b] [c d]] a unassign]
                       [[[c d]]]]
                      
                      [[[[a b] [c d]] e unassign]
                       [[[a b] [c d]]]]]]]]

;; TODO: fix the case where you just want a value [[type foo]] - only
;; one item but you want the value, not key
[type [[spec [[association] [item]]]
       [definition [[count 1 =] ;; if it's a single item
                    [first first] ;; the type is the key of that first item
                    [[type] lookup] ;; otherwise look up the key 'type'
                    if]]
       [examples [[[[[foo 1]] type] [[foo] unwrap]]
                  [[[[type url] [value "http://foo.com"]] type] [[url] unwrap]]]]]]

[value [[spec [[association] [item]]]
        [definition [[count 1 =] ;; if it's a single item
                     [first second] ;; the value is the value of that first item
                     [[value] lookup] ;; otherwise look up the key 'value'
                     if]]
        [examples [[[[[foo 1]] value] [1]]
                   
                   [[[[type url] [value "http://foo.com"]] value]
                    ["http://foo.com"]]]]]]
[zip [[spec [[[list values] [list keys]] [association]]]
      [definition [[[]] dipdown ;; add empty result below ToS
                   [[unpack wrap] ;; unpack the next key, wrap it
                    ;; to make a "pair" (adding
                    ;; value later)
                    dip ;; run that underneath the current value
                    pack ;; the value into the "pair" we created earlier
                    swap [pack] dip] ;; add the new pair to the results
                   step ;; through all the values
                   discard]] ;; the now-empty list of keys
      [examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]]]]
#+end_src

** Methods
We want a way of adding methods to a word that's already set up as a
simple 'decide' form. This will add the method at the beginning -
adding it at the end is not good because often there's a catchall
condition at the end, and adding beyond that means the new condition
is unreachable. Adding at the beginning is not always what the user
wants either, though. So maybe this could be improved by taking
another argument: a program to combine the item and the existing list
(that defaults to =prepend= here).
#+begin_src kcats :tangle src/kcats/lexicon.kcats
[addmethod [[spec [[[pair condition] [program combinator] word] []]]
            [definition [float ;; work with the word first to get definition: w c b
                         [wrap dictionary swap lookup] shield ;; leave the word and put def on top: def w c b
                         [wrap swap pack] dipdown float ;; [c b] def w 
                         [  ;; b c decide cs
                         float ;; decide b c cs
                         [execute] dip] ;; run combinator which will work on c cs 
                         join inject ;; join with [c b], the above program to run on the definition
                         swap inscribe]]]] ;; redefine word
#+end_src

** Programmable Runtime
We can make some handy words to help debug programs.

#+begin_src kcats :tangle src/kcats/lexicon.kcats
[tos [[spec [[environment] [item]]]
      [definition [[stack] lookup first]]
      [examples [[[[[stack [1 2 3]]
                    [expression [[+] step]]]
                   tos]
                  [1]]]]]]

[toe [[spec [[environment] [item]]]
      [definition [[expression] lookup first]]
      [examples [[[[[stack [1 2 3]]
                    [expression [[+] step]]]
                   toe]
                  [[+]]]]]]]

[break [[spec [[environment [program condition]]
               [environment [program condition]]]]
        [definition [[[[[expression] lookup something?] ;; something still in the expression
                       [swap execute not]] ;; check condition not true yet
                      [execute]
                      every?] ;; break?
                     [eval-step]  ;; evaluate the environment one step
                     while]]]]

[advance [[spec [[environment] [environment]]]
          [definition [[[expression] lookup count] shield swap ;; count up the expression length, we'll run until it's smaller than this
                       
                       [[expression] lookup count
                        [[positive?] [<=]] [execute] every?] ;; only stop if expr empty or shorter than we started off
                       [eval-step]  ;; evaluate the environment one step
                       while
                       swap discard ;; drop the expression length item
                      ]]]]
#+end_src

#+begin_src kcats
[[expression [1 [4 6 64 34 5] [+] step]]]
environment

[toe [+] unwrap =] swap
break
#+end_src

#+RESULTS:
: 
: [[[stack [4 1]] [expression [+ [6 64 34 5] [+] step]]] [toe [+] unwrap =]]

*** Other examples
**** Count the number of times each word is executed while running a program.
#+begin_src kcats
[[expression [10 [0 >] [clone dec] while]]]  ;; the sample program to run
environment
evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [0 1 2 3 4 5 6 7 8 9 10]] [expression []]]]

#+begin_src kcats
10 [0 >] [clone dec] while
#+end_src
#+RESULTS:
: 
: [0 1 2 3 4 5 6 7 8 9 10]

#+begin_src kcats
[swap] unwrap  word?
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
[] ;; empty list to put word counts in
[[expression [3 [0 >] [clone dec] while]]]  ;; the sample program to run
environment 
[[expression] lookup something?] ;; something still in the expression, keep running
[[[expression] lookup first] shield ;; get the item we're about to execute
 swap ;; put it under the environment
 [[word?] ; if it's a word
  [wrap
   [[something?] ;; if word count not empty
    [inc] ;; increment the counter
    [1] ;; if it is empty start the counter at 1
    if]
   update] ;; the results, the count for the word about to execute
  [discard] ;; if it's not a word, do nothing
  if] dip
 eval-step] ;; evaluate the environment one step
while 
discard ;; drop the environment and just report the word counts
#+end_src

#+RESULTS:
: 
: [[[evert 16] [first 4] [loop 4] [swap 5] [snapshot 4] [unwrap 13] [unpack 4] [dec 3] [join 2] [dipdown 1] [clone 8] [inject 4] [wrap 1] [while 1] [dip 8] [> 4] [shield 4]]]

**** TODO spec checking
clojure spec check can be replaced with predicate programs, that will
be run with =shield= before the actual word and if it returns false,
will raise an error. 
**** TODO Trace output
#+begin_src kcats :results code
[] ;; results
[[expression [1 [2 3 4 5] [*] step]]]  ;; the sample program to run
environment

[[expression] lookup something?] ;; break?
[eval-step clone [pack] dip]  ;; evaluate the environment one step
while

#+end_src

#+RESULTS:
#+begin_src kcats

[[[stack [120]] [expression []]]
 [[[stack [1]] [expression [[2 3 4 5] [*] step]]]
  [[stack [[2 3 4 5] 1]] [expression [[*] step]]]
  [[stack [[*] [2 3 4 5] 1]] [expression [step]]]
  [[stack [[*] 2 1]] [expression [execute [3 4 5] [*] step]]]
  [[stack [2 1]] [expression [* [3 4 5] [*] step]]]
  [[stack [2]] [expression [[3 4 5] [*] step]]]
  [[stack [[3 4 5] 2]] [expression [[*] step]]]
  [[stack [[*] [3 4 5] 2]] [expression [step]]]
  [[stack [[*] 3 2]] [expression [execute [4 5] [*] step]]]
  [[stack [3 2]] [expression [* [4 5] [*] step]]]
  [[stack [6]] [expression [[4 5] [*] step]]]
  [[stack [[4 5] 6]] [expression [[*] step]]]
  [[stack [[*] [4 5] 6]] [expression [step]]]
  [[stack [[*] 4 6]] [expression [execute [5] [*] step]]]
  [[stack [4 6]] [expression [* [5] [*] step]]]
  [[stack [24]] [expression [[5] [*] step]]]
  [[stack [[5] 24]] [expression [[*] step]]]
  [[stack [[*] [5] 24]] [expression [step]]]
  [[stack [[*] 5 24]] [expression [execute]]]
  [[stack [5 24]] [expression [*]]]
  [[stack [120]] [expression []]]]]
#+end_src


**** DONE Step count limiting
When testing or debugging, limit the number of steps to avoid a
possible infinite loop.
#+begin_src kcats
[200 ;; step count remaining
 [10 [0 >] [clone dec] while]  ;; the sample program to run
 environment
 
 [[expression] lookup something? ;; something still in the expression
  [positive?] dip and] ;; still step budget remaining
 [eval-step ;; evaluate the environment one step
  [dec] dip] ;; decrease the step budget 
 while
 
 [stack] lookup] ;; return the output
#+end_src
**** DONE Breakpoint
#+begin_src kcats
[[[[toe [+] unwrap =]
   [tos 3 >]]
  [execute]
  every?] ;; when to stop - when we're about to add and tos already >3
 [0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
 [[[[expression] lookup something?] ;; something still in the expression
   [swap execute not]] ;; don't stop yet
  [execute]
  every?] ;; break?
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src
**** TODO Step over
#+begin_src kcats
[[0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
[[expression] lookup count] shield swap;; count up the expression length, we'll run until it's smaller than this
 
 [[expression] lookup count
  [[positive?] [<=]] [execute] every?] ;; only stop if expr empty or shorter than we started off
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src

** Pipes
#+begin_src kcats :tangle src/kcats/lexicon.kcats
[pipe-in [[spec [[item] [pipe]]]
          [definition [[[[type [file] unwrap =]
                         [value file-in]]
                        [[type [stdout] unwrap =]
                         [stdout]]]
                       decide]]]]

[tunnel [[spec [[item] [pipe]]]
         [definition [[[[type [ip-port] unwrap =]
                        [clone
                         [port] lookup
                         [[address] lookup] dip
                         !**java.net.Socket.]]]
                      decide]]]]

[pipe-out [[spec [[item] [pipe]]]
           [definition [[[[type [file] unwrap =]
                          [value file-out]]
                         [[type [ip-port] unwrap =]
                          [clone
                           [address] lookup
                           [[port] lookup] dip
                           serversocket
                          ]]
                         [[list?]
                          [+kcats.pipe/->filled]]]
                        decide]]]]

[assemble [[spec [[pipe program] [item]]]
           [definition [swap
                        [take swap] swap pack
                        [dip] join
                        [[closed? not]] dip
                        while
                        discard]]
           [doc "Takes a large value out of a pipe by
                 `take`ing it piece by piece, and assembling the
                 pieces with `reducer`. `reducer` should take a
                 piece, and the so-far assembled value and return a
                 new value with the piece incorporated."]]]

;; TODO: is there any point to this? If we already have a
;; complex/large value in memory, we don't save any memory by
;; breaking it down, we can just shove the whole thing into
;; the pipe with a single put. For flat lists, we can just
;; `[put] step`. Maybe doing the byte conversion piece-wise is
;; useful, so I'm going to keep it for now.
;; At least with the `assemble` we probably don't want to get
;; a 1gb entire file with a single `take` if we end up
;; throwing away most of the contents as we go.
;;
;; As a higher-level abstraction might be useful to have pipes
;; with paired reducer/splitter so the other end knows how to
;; assemble. Maybe send the reducer over the pipe first?
[disassemble [[spec [[program item [pipe in]] [[pipe in]]]]
              [doc "Puts a large value into a pipe by
                    taking it apart with the `splitter`
                    program. This program should take a large value
                    and break it into two parts, such that the
                    topmost will fit into the pipe."]
              [definition [[swap [put] dip] join ;; build a while body that includes splitter
                           [nothing? not] swap
                           while
                           discard]]]] ;; drop the 'nothing' value

;; TODO: definition incomplete
;; while neither pipe is closed, take from input, run
;; program, put into output
[pump [[spec [[program [pipe in] [pipe out]] [[pipe in] [pipe out]]]]
       [definition [wrap [shield] join
                    ;; create a list to use with any
                    [[] sink [pack] dip swapdown [pack] dip
                     [[closed?] any?] dip swap]]]]]

[spit [[spec [[item [item target]] []]]
       [definition [[pipe-in] dip bytes put close discard]]]]

;;[slurp [[spec [[[item target]] [item pipe]]]]]
#+end_src
* Issues
** TODO Get rid of platform-specific definitions
