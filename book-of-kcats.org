# -*- mode: org; -*-
# -*- org-export-babel-evaluate: nil -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="docs-custom.css"/>
#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:kcats :results code :exports both
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
[[./kcats.png]]
[[./kcats-repl.gif]]
* Benefits
** Easy for beginners
Kcats is designed to require learning as few concepts as
possible. It's made with:

+ Stacks
+ Data values (numbers, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.[fn:0]

Kcats code is just english words, and quotation marks =[= and =]=. No other
symbols.

Format code however you want, kcats doesn't care. 

Interactive development is encouraged. The documentation for the
standard library can be queried with the language itself. See
[[Exploring]].

[fn:0] Inspired by Alan Kay's quote "Lisp isn't a language, it's a
building material".
** Powerful
Kcats' metaprogramming (programs that write programs) facilities allow
you to express yourself succinctly and without repetition.
** Excels in the small
There is zero ceremony. A program can easily be a single line
consisting of a few words:

#+begin_src kcats
  "contacts.txt" slurp read [[age] lookup 21 >=] filter  
#+end_src

That reads a database file of contacts, and prints only those contacts
at least 21 years old. The program is 8 words.

You don't need a "main" method, or class declaration or any other
boilerplate.  You only need to specify what the program is actually
supposed to *do*.
** Features
- [X] Automatic memory management
- [X] Multithreading
- [X] Error handling
- [X] Metaprogramming
- [X] Channels/CSPs
- [X] Introspection
- [X] Filesystem I/O
- [X] TCP/IP Socket I/O
- [X] Generators
- [X] Sequence library
- [X] Cryptographic primitives
- [X] Builtin debugging tools
- [X] Serialization
** Tradeoffs
Kcats is meant to handle personal automation tasks, where expressivity
and simplicity matter far more than raw performance. It's not
currently suitable for processing huge datasets or high performance
number crunching, and likely never will be.

* Getting Started
** Builds
*** Download pre-built binaries
See [[https://github.com/skyrod-vactai/kcats/releases][Releases]]. Binaries currently do not have installers, you will need
to place the executable in a convenient place and =chmod= it (on mac/linux).
*** From source
**** Dependencies
+ emacs
+ rustc
+ cargo
**** Creating the source
The source is contained within these org files, along with annotations
and other non-code information. To generate the source code (that the
runtime or compiler needs as separate files) before running or
building, run the following command:

=emacs --batch --load org --load tangle.el=
**** Building
See [[file:production.org::Building][Building]]
** Using
See [[file:production.org::Using][Using]]
** Developing
*** Browsing the source
It can be checked out from git or viewed here: [[file:production.org::*Production implementation][Production
implementation source]]
*** Emacs IDE
See =emacs-ide.org= in the source tree for more info.
* Fundamentals
** Key terminology
- stack :: A first-in, first-out structure. This is where the program
  stores all the data it needs to manipulate.
- item :: A value - could be a number, string, list, etc. 
- list :: One or more items bound up together.
- program :: a list of instructions intended to be carried out by a
  machine.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items.
- axiom word :: A word not defined in terms of other words.
- definition :: what a word is supposed to do, represented either in
  the base language for axiom words, or as a program.
- dictionary :: a list of available words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program, which
  generally includes a stack, expression, and dictionary.
- pipe :: A conduit to communicate between environments, and to the
  outside world. Values are put into pipes and emerge somewhere else
  (another environment, a file on disk, a remote machine, etc).
** The stack
Kcats is a stack-based language. To manipulate data, you put it onto a
stack, and then words operate on the items at the top of the stack
(which might remove, replace, or add new items). If you're familiar
with functions in other languages, that's all words are - they're a
function of the current stack, and they return a new stack.

The stack takes the place of variables and function parameters in
other programming languages.

Here's a simple example. If we mentally execute the program below, we
first put =1= onto the stack. Then we put =2= onto the stack. =2= is on top
of =1=. Then we put the word =+= onto the stack, where it will consume the =2=
and the =1=, and leave their sum, =3=.
#+BEGIN_SRC kcats :results code :exports both
1 2 +
#+END_SRC

#+RESULTS:
#+begin_src kcats
3
#+end_src

Multiple steps are accomplished just by adding more words and
data. For example, in the program below we can add =1= and =2= (leaving =3=
on the stack), and then multiply by =5=, leaving =15=.

#+begin_src kcats :results code :exports both
1 2 + 5 *
#+end_src

#+RESULTS:
#+begin_src kcats
15
#+end_src

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_src kcats
  ;; stack |  remaining program
  ;; ------|--------------------
           | 1 2 + 5 * 
         1 | 2 + 5 * 
       1 2 | + 5 *
         3 | 5 *
       3 5 | *
        15 |  
#+end_src

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Note the stack can end up with multiple items. When it's printed, it
will always start with the top of the stack - the last thing in is the
first thing out.

#+begin_src kcats :results code :exports both
1 2 3
#+end_src

#+RESULTS:
#+begin_src kcats
3 2 1
#+end_src

Lists are denoted with square brackets, like =[1 2 3]=. When
encountered, they just go onto the stack as a single unit. Words can
operate on lists once the list is on the stack. You can see below the
word =join= combines two lists.

#+begin_src kcats :results code :exports both
  [1 2 3] [4 5] join
#+end_src

#+RESULTS:
#+begin_src kcats
  [1 2 3 4 5]
#+end_src

** Exploring
*** Overview
Now that we know the very basics, we can explore and learn as we
go. Kcats lets you treat the standard library (the dictionary) as
data, and you can process it with... itself. Documentation is in
there. You just need to know how to ask for it. So here's how you do
it, and you'll understand how exactly it works later.

In all the examples in this document, you can run them on the command
line, by running =kcats=, pasting the program, and hitting CTRL-D to end
the input.

In case you want to view it in its entirety, the standard library is
part of the source, it lives in [[file:lexicon.org][the lexicon]] file.
*** What words or functions are available?
This program retrieves the dictionary of the starting environment, and
prints just the name of each, sorted in alphabetical order.
#+begin_src kcats :results code :exports both
dictionary [first] map [] sort
#+end_src

#+RESULTS:
#+begin_src kcats
[* + ++lookup ++sort - / < <=
 = > >= abs addmethod advance and animate
 any? assert assign association association? atom bail both?
 branch break buffer bytes bytes? ceil clone close
 collect compare contains? count dec decide decorate decorated
 delegated dictionary dip dipdown dive divedown drop dropdown
 dropper each emit environment error? eval-step evaluate even?
 evert every? execute fail false file-in file-out filter
 first flip float functional future generate handle handoff
 hash if inc inject inspect integers join joiner
 keep key last let liberate lingo list? lookup
 loop map max min mod negative? not nothing
 nothing? number? odd? or pair pipe-in pipe-out pipe?
 pop positive? prepend primrec put quot range read
 recover recur redefine reduce rem rest retry reverse
 second select serversocket set set? shield shielddeep shielddown
 sign sink slurp snapshot socket something? sort spit
 sqrt standard step string string? swap swapdown take
 taker timeout times timestamps toe tos true tunnel
 type unassign until unwrap update value verify while
 within? word? wrap xor zero? zip]
#+end_src

Even though the rest of this document will explain a lot of these
words and how they work, the above program does the following:

+ =dictionary=: retrieves the dictionary and puts it on the stack
+ =[first] map=: for each item in the dictionary (which is a key/value
  pair, where the key is the word and the value is the definition)
  take the =first=, which is the word.
+ =[] sort=: sort takes a program to transform each item in the list
  it's sorting, to use for comparison. We want to use the word itself
  for comparison, so we don't need to transform it at all, hence the
  empty program.
*** What inputs/outputs does a particular word have?
The specification of a word's input and output types is stored in the
dictionary too. It's in the property called =spec=. Let's say you're
interested in the word =swap=.

#+begin_src kcats :results code :exports both
dictionary [swap spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item a]
  [item b]]
 [[item b]
  [item a]]]
#+end_src

What this program does is fetches the dictionary, then looks up the
=swap= definition, then within that definition, looks up the =spec= property.

In the result, what we have here is two lists - the spec of the
input, and the spec of the output.

The input spec is =[[item a] [item b]]=. The output spec is =[[item b]
[item a]]=. What it's telling you is that it requires two items on the
stack, any two, we'll call them =a= (on top) and =b= beneath. There may be
more items below that but they won't be touched. When swap is
finished, =a= and =b= will have their places swapped so that =b= is on
top. And in fact that's what we get:

#+begin_src kcats :results code :exports both
"b" "a" swap
#+end_src

#+RESULTS:
#+begin_src kcats
"b" "a"
#+end_src

Remember the top of the stack is printed first, and so =b= is now on top. 
*** What are some example usages of a word?
#+begin_src kcats :results code :exports both
dictionary [swap examples] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[1 2 3 swap] [1 3 2]]]
#+end_src

This is a list of examples, and each example is a pair:

+ A program that calls the given word
+ A program that doesn't call the word that gives the same result [fn:2]

[fn:2] Why is it done this way instead of just giving a program and
its expected result? Some results don't have literal representations.
*** Continuing exploration
Use the same technique to explore other words. You can simply replace
the word in the code snippets above with some other word.  Here's how
you find the examples for ===, which tests for equality of two items -
just replaced =swap= with ===.

#+begin_src kcats
dictionary [= examples] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
  [[[1 2 =] [false]]
   [[1 1 =] [true]]
   [[[] [] =] [true]]
   [[[1] [] =] [false]]
   [[[1 [false]] [1 [false]] =] [true]]
   [[[1 [foo]] [1 [foo]] =] [true]]
   [[hi hi =] [true]]
   [[hi there =] [false]]
   [[[] true =] [false]]
   [[[1 [foo]] [1 [bar]] =] [false]]
   [[[] [] association =] [true]]
   [[[[a b]] [[a b]] association =] [false]]]
#+end_src

** Data types
*** Types
**** Words
In kcats, words have two main types
+ verbs, which result in actions being performed, and are defined in
  the dictionary
+ nouns or adjectives, which are used as labels or names for things,
  and are not in the dictionary.

The first type, verbs, are used directly in the execution of programs,
like =clone= and =swap=:

#+begin_src kcats :results code :exports both
  1 clone 2 swap
#+end_src

#+RESULTS:
#+begin_src kcats
1 2 1
#+end_src

The second type are used inside lists, often as field names. These
words are never executed, they're used more like you'd use strings or
keywords in other programming languages.

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] unwrap put
#+end_src

#+RESULTS:
#+begin_src kcats
[foo bar baz quux]
#+end_src

Note the use of =unwrap= here. What's wrong with just trying to =put=
=quux= directly into the list? 

#+begin_src kcats :results code :exports both
  [foo bar baz] quux put
#+end_src

#+RESULTS:
#+begin_src kcats
  [[type error]
   [asked [quux]]
   [reason "word is not defined"]
   [unwound [quux put]]]
  [foo bar baz]
#+end_src

The problem is when kcats encounters a word during execution, it
checks the dictionary to see what to do. If the word isn't isn't in
the dictionary, that's an error. When a word is inside a list, kcats
treats the whole list as an item and doesn't look inside the list.

What we want is to get =quux= onto the stack by itself without actually
executing it. We can do that with =[quux] unwrap=. The word =unwrap= does
just what it says, removes the list wrapper and leaves a bare word on
the stack. No error occurs here because the bare word is already on
the stack, it's not part of a program. Another way to go about this is
to use =join= so we don't need =unwrap=:

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] join
#+end_src

#+RESULTS:
#+begin_src kcats
[foo bar baz quux]
#+end_src

**** Booleans
Most programming languages have special values =true= and =false=. Kcats
does not. In kcats decision making, an empty list =[]= acts like =false=,
and anything else acts like =true=.

#+begin_src kcats :results code :exports both
  [] ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
  "no"
#+end_src
versus
#+begin_src kcats :results code :exports both
  "anything" ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
  "yes"
#+end_src

But wait, what about this?

#+begin_src kcats :results code :exports both
  3 odd?
#+end_src

#+RESULTS:
#+begin_src kcats
  true
#+end_src

Some words will return the word =true=, but it's not really a boolean,
it's just the word =true= which has no special meaning to kcats other
than that it's an arbitrary truthy value (remember anything that's not
an empty list is "truthy", so any word, including the word =true= is
truthy). For convenience, =true= is in the dictionary, so you do not
have to quote it. It evaluates to itself.

There are some extra "falsey" words defined for your convenience:
=nothing= and =false=. Both of them evaluate to =[]=. You can use them in
your code to enhance readability.

**** Strings
Strings work much like in other programming languages (except there
are fewer library functions).

#+begin_src kcats 
"Hello World!" count
#+end_src

#+RESULTS:
#+begin_src kcats
12
#+end_src

**** Bytes (byte array)
Byte arrays are a sort of "lowest common denominator" data
format. It's what you use to interact with files or sockets. You can
get byte literals in base64 encoding:

#+begin_src kcats
"Hello World!" bytes
#+end_src

#+RESULTS:
#+begin_src kcats
#b64 "SGVsbG8gV29ybGQh"
#+end_src

and you can treat those byte arrays as lists of integers:

#+begin_src kcats
#b64 "SGVsbG8gV29ybGQh" take
#+end_src

#+RESULTS:
#+begin_src kcats
72 #b64 "ZWxsbyBXb3JsZCE="
#+end_src

72 is the ASCII encoding for =H=.
**** Numbers
Integers and floats are supported (64 bit).

Supported math operations include =+=, =-=, =*=, =/=, =mod=, =rem=, =min=, =max=, =abs=,
=inc=, =dec=, =<=, =>=, =<==, =>==, =ceil=, =sqrt=, =odd?=, =even?=.
**** Lists
Lists are multiple items bound up into a single unit, where their
order is maintained.

***** Comprehension
See the word =step=, which runs the same program on each item in a list.

#+begin_src kcats
0 [12 6 13 7 5] [+] step 
#+end_src

#+RESULTS:
#+begin_src kcats
43
#+end_src

Similar to =step=, but more strict, is =map=, which only allows the
program to work on a given item and can't mess with the rest of the
stack. Use that to transform each item in a list, in the same way (in
this case showing the remainder when dividing by 5).

#+begin_src kcats :results code :exports both
[12 6 13 7 5] [5 mod] map
#+end_src

#+RESULTS:
#+begin_src kcats
[2 1 3 2 0]
#+end_src

**** Associations
An association looks just a list of pairs, like this:
#+begin_src kcats
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]
#+end_src

However there are some words you can use that make a list behave a bit
differently. For example:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] 25 assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[age 25]
 [name "Alice"]
 [favorite-color "brown"]]
#+end_src

Here we use =assign= to reset Alice's age - it does not simply add a new
item to the list.  It will find the existing key and replace it. It
will create a new item only if the key didn't already exist:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [department] "Sales" assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[name "Alice"]
 [favorite-color "brown"]
 [age 24]
 [department "Sales"]]
#+end_src

Notice that the order of the items is not preserved. Once you treat a
list as an association, it "sticks" - it acts like an association from
then on, and order is no longer guaranteed to be maintained.

We can improve upon our example that incremented Alice's age
(presumably after her birthday) with the word =update=. That will run a
program on the value of whatever key (or keys) you specify.

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update
#+end_src

#+RESULTS:
#+begin_src kcats
[[age 25]
 [name "Alice"]
 [favorite-color "brown"]]
#+end_src

Note that associations and lists look the same when printed but
testing them for equality can reveal they are not the same:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  =
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

Here we are comparing an association with a list. The === operator has
no way of knowing whether you want the list semantics (which does care
about order), or the association semantics (which doesn't care about
order). It defaults to the more strict rules, so they are not equal.

The act of using a list as an association (by applying words to it
like =assign= or =update=) will convert it to an association, but what if
you just want to convert a list to an association, without doing
anything else?

You can use the word =association= to convert the list to an association:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  association =
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

**** Sets
Sets are made to test for membership, and do not care about order. 
#+begin_src kcats
["Larry" "Curly" "Moe"] set "Moe" contains?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

If you add an item to a set, but it's already there, nothing changes.

#+begin_src kcats
["Larry" "Curly" "Moe"] set "Curly" put
#+end_src

#+RESULTS:
#+begin_src kcats
["Larry" "Moe" "Curly"]
#+end_src

You can =take= from a set but since order doesn't matter, you get an arbitrary item.

#+begin_src kcats
1 20 1 range set take
#+end_src

#+RESULTS:
#+begin_src kcats
15 [8 3 18 16 6 13 11 12 4 7 2 10 14 17 19 5 9 1]
#+end_src

**** Errors
See [[Error handling]]
**** Pipes
See [[Coordination and Input/Output]]
*** Traits
 There are words that operate on multiple types, and it's helpful to
 talk about what those types have in common. Traits are not used
 except in specs.
**** Dispenser
Containers from which you can take out items, one by
one. Includes:
+ Strings
+ Bytes
+ Lists
+ Associations
+ Sets
+ Out Pipes
+ Tunnels

Supported words:
+ =take=
+ =step=
**** Receptacle
Containers into which you can put items, one by one. Includes:
+ Strings
+ Bytes
+ Lists
+ Associations
+ Sets
+ In Pipes
+ Tunnels

Supported words:
+ =put=
**** Sized
Containers whose items can be counted. Includes:
+ Strings
+ Bytes
+ Lists
+ Associations
+ Sets

Supported words:
+ =count=
+ =join=
+ =every?=
+ =any?=
**** Ordered
Containers whose items are kept in a specific order. Includes
+ Strings
+ Bytes
+ Lists

Supported words:
+ =pop=
+ =first=
+ =second=
+ =last=
+ =reverse=
** Stack motion
Often you have all the data a word needs on the stack, but it's in the
wrong order. There's lots of handy words to help there.

+ swap :: swap the top two items
+ float :: float the 3rd item up to the top
+ sink :: sink the top item down to 3rd
+ flip :: reverse the top 3 items

 These words can also be combined with =dip= and its variants to reach
 deeper into the stack.
** Cloning and dropping
When you're done with an item, you can =drop= it, which eliminates it
from the top of the stack. If you know a word will drop a value you
need afterward, you can =clone= it.
** Programs that write programs
The most important expressive feature of kcats is that you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line of the execution trace
below, the word =execute= takes the list from the top of the stack on
the left, and puts its contents back on the right, making it part of
the program remaining to be run!
#+begin_src kcats
  ;;   stack  |  remaining program
  ;; ---------|--------------------
              | 4 5 6 [* +] execute inc
            4 | 5 6 [* +] execute inc
          4 5 | 6 [* +] execute inc
        4 5 6 | [* +] execute inc
  4 5 6 [* +] | execute inc
        4 5 6 | * + inc
         4 30 | + inc
           34 | inc
           35 |
         
       
#+end_src
Note that, when =* += gets moved back to the expression, it went in
*front* of =inc=. The expression acts just like a stack - the last thing in
is the first thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_src kcats :results code :exports both
4 5 6 [+] [*] join execute
#+end_src

#+RESULTS:
#+begin_src kcats
44
#+end_src

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quotation - a message being
being passed along, not acted upon.

** Looping and branching
*** if
=if= takes 3 programs from the stack:
+ =condition= a program whose result decides which branch to take
+ the =true= branch
+ the =false= branch

An important detail: after =condition= runs, its stack effects are
erased. The =true= or =false= branch runs on whatever was underneath the 3
programs at the start.

#+begin_src kcats
1 2 3 [odd?] ["it's odd"] ["it's even"] if
#+end_src

#+RESULTS:
#+begin_src kcats
"it's odd" 3 2 1
#+end_src

Notice how the =3= is still there. The word =odd?= normally consumes its
argument.
#+begin_src kcats
3 odd?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

Here's a more extreme example:

#+begin_src kcats
1 2 3 [drop odd?] ["it's odd"] ["it's even"] if
#+end_src

#+RESULTS:
#+begin_src kcats
"it's even" 3 2 1
#+end_src

See how we =drop= the =3= and test =odd?= against =2= instead? Normally we'd
have consumed both the =3= and the =2= but the conditional is not allowed
to have any stack effect. See [[Stack effect control]].
*** loop
Loops take a program to run as the body, and a boolean (See [[Booleans]])
condition whether to run the body. If the condition is false, the body
never runs. If it's true, the body runs and =loop= expects another
boolean condition to be on top to see whether to run the body again.

Note that the value on top *only* determines whether the body runs
again, it's dropped and *not* accessible to the body program. If the
body needs it, be sure to =clone= it. Usually it doesn't need that value
for anything except deciding whether to continue the loop, which is
why it's dropped automatically.

Here's an example:

#+begin_src kcats
1 true [2 * clone 100 <] loop
#+end_src

#+RESULTS:
#+begin_src kcats
128
#+end_src

Notice that =loop= receives the body program and =true= the first
time. The body program never sees =true=, only the =1= underneath it - it
multiplies it by 2, then clones it and checks if it's less
than 100. If so, it drops that boolean value and continues and
multiplies the number beneath by 2 again, and so on, until the number
is greater than or equal to 100. Finally that =false= value is dropped
and the =loop= is done, leaving just the final number =128=.
*** while
Kcats also has =while=, which is a bit higher level than =loop=. Instead
of expecting a boolean value on top each time through, you provide a
condition program similar to what =if= requires. =while= runs the
condition program, if it leaves a truthy value, the loop
continues. Like =loop=, =while='s body does not have access to the truthy
value.

#+begin_src kcats
1 [100 <] [2 *] while
#+end_src

#+RESULTS:
#+begin_src kcats
128
#+end_src

Like =if=, the condition program cannot permanently affect the stack. So
we don't need =clone= like we did with =loop=. After we compare the number
to 100, it's restored so the body can see it on top.
** Argument order
Kcats stack-based nature can take a little getting used to, and the
reversing of the order you wrote something is perhaps the biggest
stumbling block.

Notice how =if= is designed to have the
conditional/true/false branch in the order you expect when you write
code. However remember if you print the stack the order will be
reversed - the =false= program will be on top, followed by the =true=
program, followed by the =conditional=:

#+begin_src kcats
1 2 3 [drop odd?] ["it's odd"] ["it's even"] ;; if 
#+end_src

#+RESULTS:
#+begin_src kcats
["it's even"] ["it's odd"] [drop odd?] 3 2 1
#+end_src

This is a common theme in kcats, where argument order is designed to
make the code readable - if a word takes multiple arguments, and the
order matters, the "first" logical argument is not the top of the
stack. Here's an example:

#+begin_src kcats
1 2 <
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

When we write =1 2 <= we mean "1 is less than 2". Even though the top
of the stack is 2, we don't consider 2 the "first" argument.
** Item hiding
Sometimes you have a program that you don't trust with a certain stack
value. Perhaps there's a password on the stack, and you're running an
untrusted program given to you by someone else.

What if there was a way to hide that password behind your back such
that the program never even knew it was there, and then restore it
after the untrusted program was finished?

=dip= takes an item on the top of the stack, and a program. It
temporarily hides the item, and runs the program. After the program is
done, it puts the item back on the stack.

#+begin_src kcats
1 2 "mypassword" [+] dip
#+end_src

#+RESULTS:
#+begin_src kcats
"mypassword" 3
#+end_src

Notice the addition program could not access the password even if it
tried. It isn't on the stack while it's executing, it's hidden away
elsewhere in the runtime, temporarily.

=dip= is very common in kcats, and it's used mostly in cases where you
don't actually care if a program reads a value, you just want the
value out of the way temporarily, and it's easier than finicky
swapping. However in cases where there is a trust issue, no amount of
swapping can fix the problem and you definitely should reach for =dip=.

** Stack effect control
Kcats provides some facilities to let you avoid tedious cloning of
values to keep from losing them. Most words consume values from the
stack to produce new values. Sometimes you'll still need those old
values again later.

We saw earlier how =if= runs a condition program, and no matter how
badly that program messes with the stack, that effect is wiped clean
and only the top result of that program remains.

That magic is not locked away inside =if= - you can use it in your own
programs.

Earlier we showed how to examine the dictionary. Here's how you see
the definition of =if=:

#+begin_src kcats
dictionary [if definition] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[shield] dipdown branch]
#+end_src

=if= runs the condition program with =shield=. =shield= runs the given
program, takes the top item and places it on top of the *original* stack
(before the program ran). Let's look at the first example of =shield= -
remember each example shows two programs that produce the same result.

Here's how we view the first example of =shield=.
#+begin_src kcats
dictionary [shield examples] lookup first
#+end_src

#+RESULTS:
#+begin_src kcats
  [[1 2 3 [=] shield]
   [1 2 3 false]]
#+end_src

Here we're checking whether =2= and =3= are equal without consuming
anything.

Here's what it would look like without =shield=:

#+begin_src kcats
1 2 3 =
#+end_src

#+RESULTS:
#+begin_src kcats
[] 1
#+end_src

The =2= and =3= are consumed, leaving only the falsey value.
** 'down' and 'deep' variants
There are words like =dipdown=, =shielddown=, =swapdown=, =dropdown=,
=divedown=. What are those?

It's a modification of the original where the effect is one stack
element further down from the original. What exactly is further down,
depends on the word.

+ swapdown :: swap not the top two items, but the 2nd and 3rd items
+ dipdown :: hide not the top stack item, but the top two items
+ shielddown :: protect not the whole stack, but everything except the
  top item.
+ dropdown :: drops the 2nd item
+ divedown :: hides the top two items but then floats the result back
  to the top above the previously hidden items

Similarly the =deep= variants are one level even deeper than that:

+ swapdeep :: swap the 3rd and 4th items
+ dipdeep :: hide the top 3 items
+ shielddeep :: protect all but the top two item
+ dropdeep :: drops the 3rd item
** Promotion
Data types are automatically converted when needed.

For example, if you have a list of pairs and you use the word =lookup=,
it assumes your intention is to use the list as an associative data
type, so it will be automatically converted, and remain converted
after =lookup= completes.

You can tell by the spec when the return type is a promoted type:
#+begin_src kcats :results code :exports both
dictionary [assign spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item value]
  [list keys]
  sized]
 [association]]
#+end_src

Here you can see that the spec for =assign= takes a =sized= and returns an
=association=. This allows you to do things like this:

#+begin_src kcats :results code :exports both
[[name "Susie"] [age 25]] [sport] "bowling" assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[age 25]
 [name "Susie"]
 [sport "bowling"]]
#+end_src

The initial value of =[[name "Susie"] [age 25]]= is not an =associative=,
it's just a =list=. You could explicitly convert it using the word
=association= but =assign= will do it for you, because it needs an
associative type.

Note that the conversion can fail, because converting to =associative=
requires that you have a list of pairs. If you don't, that's an error:

#+begin_src kcats :results code :exports both
["foo" "bar"] [age] 25 assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[unwound []]
 [asked [pair]]
 [reason "type mismatch"]
 [type error]
 [actual "foo"]
 [handled true]]
#+end_src

The most common promotion is from =list= to =associative= but there are
others.
** Error handling
In kcats, when a program encounters an error, an error value is
placed on the stack instead of the usual result.

#+begin_src kcats :results code :exports both
2 3 "four" * + 
#+end_src

#+RESULTS:
#+begin_src kcats
[[unwound [* +]]
 [reason "type mismatch"]
 [asked [number]]
 [type error]
 [actual "four"]
 [handled true]] "four" 3 2
#+end_src

Notice the =unwound= field contains the rest of the program that
remained when the error occurred.

We can fix the problem and continue, but only if we can stop the
unwinding before our entire program is unwound. We can do that using
the word =recover=, which takes two programs: =p= and =r=, =p= is run and if
it results in an error, the unwinding is limited to =p= and then =r= is
run. When =r= runs, the error object is on the top of stack. If there is no
error, =r= does not run.

In the program below, we recover by discarding the error and the
string "four", and replacing it with the number =4=. Then trying the
operations =* += again.
#+begin_src kcats :results code :exports both
  2 3 "four" [* +] [drop drop 4 * +] recover
#+end_src

#+RESULTS:
#+begin_src kcats
14
#+end_src

The problem with the usage of =recover= above is that we had to specify
the arithmetic words =* += twice - once in =p= and again in =r= in case they
failed the first time. Remember those operations are saved in the
=unwound= field of the error, and we can access them and even =execute=
them. There is a word that does this for you: =retry=: it takes an error
on the top of stack, and executes its =unwound= program.

#+begin_src kcats :results code :exports both
  2 3 "four" [* +] [[drop 4] dip retry] recover
#+end_src

#+RESULTS:
#+begin_src kcats
14
#+end_src

In the above program, after the error occurs, we discard the string
underneath the error and replace it with the integer =4=.

Sometimes you need to raise your own errors, you can do that with the
word =fail=.

#+begin_src kcats
  2
  [odd?]
  ["ok"]
  [[[type error] [asked odd?] [reason "expected odd number"]]
   association fail]
  if
  3 4 +
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked odd?]
 [type error]
 [reason "expected odd number"]
 [unwound [3 4 +]]
 [handled true]] 2
#+end_src

Sometimes you want to handle some errors but not others. There's no
error type matching like you'd find with java's =catch=. You have to
recover, examine the error, and if it's one you don't want to handle,
re-activate it with =fail=.
** Your own words
You're not stuck with just the vocabulary in the starting
environment. You can make your own words!

You can alter the dictionary however you want, but it's a best
practice to limit the scope of those changes to a particular
program. =lingo= is a word that executes a program with an altered
dictionary (and then restores the original dictionary):

#+begin_src kcats
  [[square] [[definition [clone *]]
             [spec [[number] [number]]]]
   assign]
  [9 square]
  lingo
#+end_src

#+RESULTS:
#+begin_src kcats
81
#+end_src

So what's happening here? =lingo= takes two programs. The first alters
the dictionary (it can expect the environment's current dictionary to
be on top when it's called). In this case it's =assign= ing =square= to
the given definition =[clone * ]=. The second program is the program you
want to run that uses the altered dictionary =[9 square]=.

Note that you can do whatever you want - you can alias =+= to =-= (not
advisable, but you can), you can remove =lingo= from the dictionary so
your program can't define any of its own new words, etc.

Also note that it is possible, and encouraged, to nest calls to =lingo=
so that only the sections of code that actually need a particular
alteration are using it. All library code should be loaded with =lingo=. [fn:3]

If you really want to permanently alter the dictionary, you can do
that too, with =redefine=, which takes a dictionary (presumably that
you've modified) and replaces the environment's dictionary with that
one.

#+begin_src kcats
  dictionary
  [square] [[definition [clone *]]
            [spec [[number] [number]]]]
  assign
  redefine
  9 square
#+end_src

#+RESULTS:
#+begin_src kcats
81
#+end_src

[fn:3] Currently, there is no special standard library functionality
for loading libraries. However you can still do it - if you put
whatever alterations you want in a separate file, let's say
=square.kcats=, you can load it like this:

#+begin_src kcats
  "square.kcats" slurp read [9 square] lingo
#+end_src
** Generators
Sometimes in programming, having the concept of an indefinite sequence
is handy. You have part of your program producing data, and another
consuming it, but the producer doesn't know how much the consumer will
actually need. A producer might calculate a huge number of values at
great expense, only for the consumer to only need a tiny fraction of
them. Generators allow the consumer to tell the producer when to
produce, but the producer still retains all the logic of how that's done.

In kcats there's no special sauce for generators, we can implement
them as a pattern with just the standard words we've already seen.

Here's an example: Let's say you want to create the fibonacci
sequence. Let's see how we can code that without worrying about how
many items in the sequence we'll eventually need.

A generator consists of two things: state, and a program. Each time
we want to generate a value, we run the program. The program should
produce a new value and update the state. We just put however many
state items we need on the stack, and then a program that can work
with those items.

#+begin_src kcats :results code :exports both
1 0 [[+] shielddown swap clone]
#+end_src

So here we start with =1 0=. That's the starting state. Normally we'd
start fibonacci with =1 1= but this isn't the actual first two numbers
in the sequence, it's starting values we use to calculate them. Then
we have a program that takes two numbers as input and leaves one new
number. Let's just =execute= that program and see the result:

#+begin_src kcats :results code :exports both
1 0 [[+] shielddown swap clone] execute
#+end_src

#+RESULTS:
#+begin_src kcats
1 1 1
#+end_src

We can see the =0= is now =1= and there's an extra =1= on the
stack. Remember the generator must do two things, produce a new value
and update the state. It updated the state from =0 1= to =1 1=, and
produced the first value, =1=.

This gets us one number, but not the whole fibonacci sequence. Let's
look at the word =generate=. All it does is run the program, pulls the
generated item to the top of the stack, and puts a new copy of the
program in place so that when we want the next item, we can call
=generate= again:

#+begin_src kcats :results code :exports both
1 0 [[+] shielddown swap clone] generate
#+end_src

#+RESULTS:
#+begin_src kcats
1 [[+] shielddown swap clone] 1 1
#+end_src

Notice here that the only difference from before is that the program
is sandwiched between the fibonacci number we produced, and the state.

Let's keep going and call generate again! But wait, before we do that
we need to do something with value we just produced, to get it out of
the way. For now we'll just =drop= it. We've seen it and we want to
see what's next.

#+begin_src kcats :results code :exports both
  1 0 [[+] shielddown swap clone] generate ;; what we had before
  drop ;; throw away the first value
  generate ;; the 2nd value
#+end_src

#+RESULTS:
#+begin_src kcats
1 [[+] shielddown swap clone] 1 2
#+end_src

Ok, so the 2nd value is =1= and we can see the state is updated -
instead of =1 1= we have =1 2=.

One more time:
#+begin_src kcats :results code :exports both
  1 0 [[+] shielddown swap clone]
  [generate drop] 2 times ;; generate and drop the first two values
  generate ;; the 3rd value
#+end_src

#+RESULTS:
#+begin_src kcats
2 [[+] shielddown swap clone] 2 3
#+end_src

Ok we can see that we can get values one at a time by calling
=generate=, but this is not very useful. What we really want is to get
the first =20= numbers in the fibonacci sequence, and collect them into a
list. We can do exactly that:

#+begin_src kcats :results code :exports both
1 0 [[+] shielddown swap clone] ;; our original generator
20 taker ;; another generator that stops generating after 20 items
collect ;; collects all the generated items into a list
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765]
[[positive?] [dec [generate] dive] [[]] if] 0 [[+] shielddown swap clone] 6765 10946
#+end_src

There's the fibonacci sequence! Hey wait, what's all that stuff after
it?  We just want fibonacci! That's there in case you wanted to keep
generating more values. If you want to just get the result and throw
away the generators, you can do that with =shield=, which erases all
stack effects except whatever was on top. So we'll just =shield= the
entire thing:

#+begin_src kcats :results code :exports both
  [1 0 [[+] shielddown swap clone]
   20 taker
   collect]
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765]
#+end_src

So what is happening here? We're stacking up generators. Starting with
the last, we have =collect= which will repeatedly call =generate= on the
generator below it. It keeps going and collecting the generated items
in a list, until the generator below returns =nothing=. Then it stops
and returns what it collected.

Then below =collect= we have a generator =20 taker= - what that does is
keeps its own state of how many items we want it to take. It counts
down as it generates items below it, passing them up to =collect= and
when it hits zero, it returns =nothing= (even if the generator below it
would have produced something, =taker= won't even ask). That will signal
=collect= to stop.

We have other handy generators we can stack up. Let's say for whatever
reason we want to know what are the first 20 *odd* fibonacci numbers?
Well, we have =keep=:

#+begin_src kcats :results code :exports both
  [1 0 [[+] shielddown swap clone] ;; our original generator
  [odd?] keep ;; a generator that keeps calling the one
              ;; below it until it gets something that
              ;; passes the predicate we specified
  20 taker ;; another generator that calls generate 20 times
  collect] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 3 5 13 21 55 89 233 377 987 1597 4181 6765 17711 28657 75025 121393 317811 514229]
#+end_src

There it is, the first 20 *odd* fibonacci numbers!

Let's say instead we wanted to know the prime factors that make up
each of the first 20 fibonacci numbers. We can do that with =each=:

#+begin_src kcats :results code :exports both
  [1 0 [[+] shielddown swap clone] ;; our original generator
   ;; a program to give the prime factors of a given number
   [[] swap 2
    [/ 2 >=]
    [[mod zero?]
     [clone sink [put] dipdown / 2]
     [inc]
     if]
    while
    drop put]
   each

   20 taker ;; another generator that calls generate 20 times
   collect] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[[1] [1] [2] [3] [5] [2 2 2] [13] [3 7]
 [2 17] [5 11] [89] [2 2 2 2 3 3] [233] [13 29]
 [2 5 61] [3 7 47] [1597] [2 2 2 17 19] [37 113]
 [3 5 11 41]]
#+end_src

There we have it. We can see that =[2 2 2]= is what makes up =8=, etc.

Other included generators are:

+ dropper :: Inverse of =taker= - drops the first n items of the
  sequence and returns the rest.
+ joiner :: Joins items together
+ integers :: all the numbers starting with 0

=reduce= will consume what a generator produces. You provide a program
that takes 2 arguments, and =reduce= will generate all the items, and
pass to your program: the result so far and the next item generated,
and repeat that until there are no items left:

#+begin_src kcats :results code :exports both
  [integers
   1 dropper ;; drop 0 so we start with 1
   10 taker
   [3 *] each
   [+] reduce]
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
135
#+end_src

Let's say you go to the trouble of making a beautiful stack of
transformations and you want to re-use it, but you don't have a
generator, you have a list! Our transformation stack needs a
*generator*! How are we supposed to use it?  Never fear, there is a
simple way to adapt transformations to work on anything that works
with the word =take=. You can use the word =liberate= to convert a list to
a generator. (It's just an alias for =[take]= which is even shorter than
=liberate= so feel free to just use =[take]=).

Do you see why =[take]= converts a list to a generator? Remember,
generators are a state and a program. If we already have a list or
pipe, we can just treat that as the state. And =[take]= as the program
does exactly what we want, removes an item from the list and returns
it, leaving the state with one fewer item.
** Coordination and Input/Output
*** Basics
In kcats, both coordination and input/output are done with =pipes=. See
the [[Key terminology][definition]] for pipe.

Let's take a common example of coordination. Your program has to do
several very long and intensive calculations but doesn't want to make
the user wait to do other things. The way that's done in kcats is by
creating multiple environments, and have them communicate with each
other using pipes. You can send any value through a pipe that you
could put onto the stack, including other pipes. You can =clone= a pipe
to give access to it to more than one environment.

There are two main operations a pipe supports: =put= and =take=. You
either put an item in, or take an item out. Either one of those
operations may *block*, if the pipe is either full (when putting) or
empty (when taking). Your environment would have to wait for some
other environment to take something out so there's space to put, or
put something in so that there's something to take out.

All pipes share the =put= and =take= operations but they can differ in
other ways. For example, the pipe you get when writing to a file will
only accept bytes. Trying to put any other type will cause an
error. Pipes also have varying capacity to hold items. Imagine a pipe
that has no length at all, it's just a hole in a thin wall. It doesn't
hold anything - you can only pass an item through if there's someone
on the other side of the wall already waiting to accept it. That's
called a =handoff=, and is the most common coordination pipe. Other
pipes have a capacity. Imagine a pipe where even if no one is taking
anything out of it, you can still put 10 items into it before it will
stop accepting more. That is a pipe with a capacity of 10 items.

Note that =put= and =take= can also be used on plain lists. =put= adds to
the end, and =take= removes the first item. Neither will ever block when
used on a list. Another slight difference is what happens when you've
reached the end of the content (either the list is empty or the pipe
has, for example, hit the end of file condition): a =take= from an empty
list will just return =nothing=, but a =take= from a pipe that is at EOF
will result in an error.

*** Input/output
Let's look at how we do I/O using files as an example - let's say we
want to write the word =foo= to a file called =bar=:
#+begin_src kcats :results code  :exports both
  [[file "bar"]] pipe-in ;; create the pipe to the given file "foo"
  "foo" bytes ;; we have to convert string to bytes first, using the word
              ;; =bytes=.
  put ;; finally, put the bytes into the pipe, and they are written to
      ;; the file
#+end_src

#+RESULTS:
#+begin_src kcats
[[to [[file "bar"]]]
 [type tunnel]
 [values [[type bytes]]]]
#+end_src

Note the representation of the pipe shows where it leads (the =to=
field), and what types of items it can carry (the =values= field).

Neither =put= nor =take= consume the pipe from the stack,
for convenience, as most of the time you'll want to use it again.

Let's look at reading from a file:

#+begin_src kcats :results code :exports both
[[file "bar"]] pipe-out
take string
#+end_src

#+RESULTS:
#+begin_src kcats
"Hello World!" [[type tunnel]
                [values [[type bytes]]]
                [to [[file "bar"]]]]
#+end_src

Note that the amount of bytes you'll get from a file on each take, is
limited. You will only get the entire contents if the file is
small. We'll want to repeatedly =take= until there's nothing left, and
put all the taken parts together.

Here's how we do it:
- turn the pipe that provides chunks of a file into a [[Generators][generator]], with =[take]=.
- Assemble the chunks with =reduce=. It requires a program to say how to
  combine the chunks. We want to =join= them, so the program is =[join]=.

We can also use the word =file-out= as a shortcut to get a pipe given a
file's name.
#+begin_src kcats :results code :exports both
"bar" file-out [take] [join] reduce string
#+end_src

#+RESULTS:
#+begin_src kcats
"Hello World!" [take] [[type tunnel]
                       [values [[type bytes]]]
                       [to [[file "bar"]]]]
#+end_src

** Debugging
In kcats, we don't need an external debugger. We can debug our
programs right in the kcats interpeter. We can specify the program to
run and step through it.

Let's say this is the program we want to step through. This is how we'd normally run it:
#+begin_src kcats :exports both :results code
0 1 5 inc range [+] step
#+end_src

#+RESULTS:
#+begin_src kcats
15
#+end_src

To debug, we put it into an environment object which we can then use
debugging words like =advance=:

#+begin_src kcats :exports both :results code
  [[expression [0 1 5 inc 1 range [+] step]]] environment
  [advance] 7 times
  eval-step
#+end_src

#+RESULTS:
#+begin_src kcats
[[expression [execute [2 3 4 5] [+] step]]
 [stack [[+] 1 0]]]
#+end_src

Note that =advance= is like =step-over= in a traditional debugger, and
=eval-step= is like =step-into=.  So above we advance until we reach the
word =step= in the program, and then we step into it. We end up showing
the environment in the middle of execution. The stack has a program
=[+]= on top, and the next word is =execute= which will run that program.

* Example programs
** Query a sample database
#+begin_src kcats
  ["examples/books.kcats" file-out [take] [join] reduce 
   string read
   [[subjects] lookup
    set [dystopia] unwrap contains?]
   filter] 
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[[[author-first "George"]
  [author-last "Orwell"]
  [title "1984"]
  [year 1949]
  [subjects [government dystopia surveillance totalitarianism freedom]]]
 [[author-first "Aldous"]
  [author-last "Huxley"]
  [title "Brave New World"]
  [year 1932]
  [subjects [society technology dystopia happiness drugs]]]
 [[author-first "Ray"]
  [author-last "Bradbury"]
  [title "Fahrenheit 451"]
  [year 1953]
  [subjects [censorship knowledge books society dystopia future]]]]
#+end_src

** Factorial
*** Recursive with recur
#+BEGIN_SRC kcats 
10
[1 <=]
[]
[clone dec]
[execute *]
recur
#+END_SRC

#+RESULTS:
#+begin_src kcats
3628800
#+end_src

*** Using range
#+BEGIN_SRC kcats :results code :exports both
10
inc [1 1] dip 1 range 
[*] step
#+END_SRC

#+RESULTS:
#+begin_src kcats
3628800
#+end_src

*** Plain loop
#+BEGIN_SRC kcats :results code :exports both
10 clone 
true [dec clone [*] dip clone 1 >] loop
drop
#+END_SRC

#+RESULTS:
#+begin_src kcats
3628800
#+end_src

** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
#+BEGIN_SRC kcats :results code :exports both
100 [0] [[1.0 swap /] dip +] primrec
#+END_SRC

#+RESULTS:
#+begin_src kcats
5.187377517639621
#+end_src

** Fibonacci
#+BEGIN_SRC kcats :results code :exports both
 [1 0 [[+] shielddown swap clone] ;; fibonacci generator
  20 taker ;; another generator that calls generate 20 times
  collect] ;; collects all the generated items into a list
  shield
#+END_SRC

#+RESULTS:
#+begin_src kcats
[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765]
#+end_src

** Prime factors
#+BEGIN_SRC kcats :results code :exports both
  360234254421

  [] swap 2

  [/ 2 >=]
  [[mod zero?]
   [clone sink [put] dipdown / 2]
   [inc]
   if]
  while

  drop put
#+END_SRC

#+RESULTS:
#+begin_src kcats
[3 3 3 67 277 718897]
#+end_src

** bidirectional comms from a socket
#+begin_src kcats
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; collectd
 [[type ip-host]
  [address "localhost"]
  [port 9988]] association ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 collect] ;; receive
#+end_src
** Write string to a file
#+begin_src kcats
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_src
** Search the dictionary
#+BEGIN_SRC kcats :results code :exports both
  dictionary ;; put the dictionary of all words onto the stack as key value pairs
  [second ;; the value of one of those pairs
   [spec] lookup ;; look up the spec field
   first ;; the input part of the spec
   [number number] =] ;; is it taking two number inputs?
  filter ;; filter the dictionary using the above criteria
  [first] map ;; of what remains, just keep the key (which is the word itself)
#+END_SRC

#+RESULTS:
#+begin_src kcats
[> rem >= * mod min - + <= within? < max quot /]
#+end_src
** Copy data from one file to another
#+begin_src kcats
  [[file "/tmp/bar"]] pipe-in
  [[file "/tmp/foo"]] pipe-out 
  [put] step
#+end_src

#+begin_src kcats :results code
  "/tmp/foo" "/tmp/bar"
  pair [[] [file] float assign] map ;; make file descriptors for both
  take pipe-out
  swap unwrap pipe-in
#+end_src

#+RESULTS:
#+begin_src kcats
[[unwound [[type] unwrap = [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[first second] [first first]] unwrap branch [[[[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first swap drop [[[[association] unwrap]]] unwrap swap [[]] unwrap or [[[[nothing?] shield] dip swap [or] shielddown] [] [[take swap [[execute] shielddown] dip swap] dip or] [execute] recur] execute swap drop swap drop [file] unwrap = [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[value file-out] [[[[type [ip-host] unwrap =] [clone [port] lookup [[address] lookup] dip serversocket]] [[list?] [+kcats.pipe/->filled]]] decide]] unwrap branch swap unwrap pipe-in]] [type error] [reason "type mismatch"] [actual [[file "/tmp/foo"]]] [asked [list]] [handled true]] [[[file "/tmp/bar"]]]
#+end_src
** List the steps of program execution
#+begin_src kcats :results code :exports both
  [0 [1 2 3] [+] step] ;; the program to trace

  [expression] swap put wrap environment ;; create a starting env

  ;; now create a generator of environment states for each step of execution
  [[[expression] lookup] ;; if the expression is not empty
   [eval-step clone] ;; step 
   [[]] ;; otherwise emit nothing to stop the consumption
   if]

  ;; consume the generator
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
  [[[stack [0]] [expression [[1 2 3] [+] step]]]
   [[stack [[1 2 3] 0]] [expression [[+] step]]]
   [[stack [[+] [1 2 3] 0]] [expression [step]]]
   [[stack [[+] 1 0]] [expression [execute [2 3] [+] step]]]
   [[stack [1 0]] [expression [+ [2 3] [+] step]]]
   [[stack [1]] [expression [[2 3] [+] step]]]
   [[stack [[2 3] 1]] [expression [[+] step]]]
   [[stack [[+] [2 3] 1]] [expression [step]]]
   [[stack [[+] 2 1]] [expression [execute [3] [+] step]]]
   [[stack [2 1]] [expression [+ [3] [+] step]]]
   [[stack [3]] [expression [[3] [+] step]]]
   [[stack [[3] 3]] [expression [[+] step]]]
   [[stack [[+] [3] 3]] [expression [step]]]
   [[stack [[+] 3 3]] [expression [execute [] [+] step]]]
   [[stack [3 3]] [expression [+ [] [+] step]]]
   [[stack [6]] [expression [[] [+] step]]]
   [[stack [[] 6]] [expression [[+] step]]]
   [[stack [[+] [] 6]] [expression [step]]]
   [[stack [6]] [expression []]]]
  [[[expression] lookup] [eval-step clone] [[]] if] [[expression []] [stack [6]]]
#+end_src

We could ensure the stack/expression are printed in the same order each time
#+begin_src kcats :results code :exports both
  [0 [1 2 3] [+] step] ;; the program to debug

  [expression] swap put wrap environment ;; create a starting env

  ;; now create a generator of environment states for each step of execution
  [[[expression] lookup] [eval-step clone] [[]] if]

  ;; print with the fields sorted the same way for each step
  [
   [[stack [[+] 3 3]] [expression [execute [] [+] step]]]
   [[stack [3 3]] [expression [+ [] [+] step]]]
   [[stack [6]] [expression [[] [+] step]]]
   [[stack [[] 6]] [expression [[+] step]]]
   [[stack [[+] [] 6]] [expression [step]]]
   [[stack [6]] [expression []]]]
  [[[expression] lookup] [eval-step clone] [[]] if] [[expression []] [stack [6]]]
#+end_src
* Contributing
** Bug reports
Instead of opening a github issue, add a =TODO= subheading to the
[[*Issues][Issues]] heading. Commit the change and submit it as a pull request. In
the branch where that issue is being fixed, it will be changed to
=INPROGRESS=. When the issue is fixed, the heading will be
removed. (If you disagree that it's been fixed, submit a PR that
reverts the commit to remove it).

You can edit this file right on github, in your own fork of the
project, if you prefer.

Why do things this weird way? I don't want to rely on github, nice as
it is.
* Issues
** DONE Build without using emacs interactively
Users should not be required to know emacs to build the project, only
have it installed. The build should be accessible from bash without
having to use emacs interactively. 
** DONE Remove platform interop from lexicon
That was only there as a cheat when there was only the prototype
implementation. The platforms are different and their function names
don't belong in the lexicon.

I'm not even sure there should be platform interop at all - it doesn't
appear to be possible in the rust impl anyway.

So far what I've done is have some lower level words actually in the
dictionary but marked them like `++lookup`. I haven't decided what to
do about this yet. Lower level words probably should just be first
class citizens and I just need to think of better names. Right now the
low level (single-depth) lookup is `++lookup` and the user-facing
`lookup` does the arbitrary depth. In this case, the user-facing name
probably needs to change to reflect what it does (something like
`drill` or `extract`), and then the low level can just be `lookup`.

That means for all the i/o and crypto interactions, there needs to be
low-level words. I'm not sure yet how to prevent namespace pollution,
as one of the design choices is
** DONE 'unassign' doesn't take a keylist, only a single key
Should change to match =assign= and =lookup=, accept a list instead of
a single bare word.
** DONE More support for nested/related envs
Debuggers, spawning, ingesting etc
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?

This ties in with durability - where do we store things in general,
and not just libraries? kcats does support the filesystem but I would
like that to be for compatibility only. The "native" kcats way of
storing and retrieving things should be via hash keys. There may also
be a fact database, probably with sparse tables (aka eavt format).

It brings up the question of what should "come with" the language. I
am thinking maybe there's a "barebones" version of the language with
no library management or anything. Then on top of that, build some
durability and networking to distribute code and other data. Then the
question is, what do we need to support in the base language? Seems
like there needs to be database/network functionality there, but
unused? Maybe make it a feature flag?

Let's explore the various options
*** Durability
It's tempting to want the flexibility of EAV (where there's basically
just one big db table with 3 columns and every attribute is a row).

However this may be a little hasty. Perhaps what we're really after
here is custom tables - the idea being that each user's db schema
might be different depending on what data is important to them.

We've basically got a database schema consensus problem. Maybe Alice
has a table CATS with columns SIZE COLOR AGE and Bob has a table CATS
with columns HEIGHT COAT-COLOR AGE. How do they share data? The two
tables are not really compatible without a specialized conversion tool
and even then some data would be missing. So Alice and Bob ideally
should agree on what a CATS schema is, otherwise they can't really
share CAT facts. The advantage of EAV might be that even if they had
different schemas they could stlil perhaps meaningfully talk about AGE
and possibly even COLOR (with a bit of intervention, or even another
fact that equates COLOR and COAT-COLOR in CATS).

The drawback of EAV is of course that it would perform rather terribly
as the database grows. I can't say for sure how many facts could
potentially be stored here, but here are some constraints:

+ Assume individual data only (no facebooks that store millions of
  people's data)
+ Assume popularity of the app (users may try to cram every fact they
  "know" into this db)
+ Assume there's some kind of garbage collection - Alice may collect
  weather observations or predictions constantly but doesn't need to
  keep old data. Maybe facts have a TTL? Not sure how that could be
  determined automatically.

 It's hard to estimate how large the db might get, but I suspect a
  lower bound of supporting 1M entries is safe. As for upper bound,
  it's more difficult to say, but I would think the hardware limits of
  mobile devices would come into play. As of 2023 I think a db size on
  the order of 10gb would be approaching the device's capability
  limits, so maybe 100M entries or so. I think it would be difficult
  to get an EAV database to perform well at that size, especially on
  mobile. Note datomic can handle that size so it's theoretically
  within reach.

  It may be possible to pick a standard db now (sqlite maybe) and not
  worry too much about performance. As long as the facts are portable
  to another db (which shouldn't be that hard), the issue can be
  revisited when it becomes an issue.

  Even using sqlite though, just building proper queries may be
  difficult. It may be possible to skirt that problem too and just do
  a minimal query to get a dataset that fits easily in memory and then
  post-process the rest. Let's say the query is "List all predictors
  (people who made predictions) and their accuracy", you could get all
  the unique predictor ids in a query, then one by one get all their
  predictions, then get all the relevant observations and compare
  them. Slow but not the type of query that will be done often, and
  possibly indexable.
**** Possible dynamic sql db
One possible design is to just use plain old sql (sqlite?) and create
normal tables. However the table names would be namespaced, possibly
with some sort of hash. That way, one person's "Customer" schema could
be in the same database as another person's without interfering.

So for example, the kcats language might need to keep track of library
dependencies. There could be a table =dependencies-01234abcd= with
columns =name=, =version=, =hash=, =blob= etc. Anything else wanting to use the
same schema could refer to it by hash. It would be possible to have
foriegn keys too.

One thing we want to avoid is having kcats users writing sql query
strings, that is not the idiomatic way of dealing with i/o. What
should happen is there's a =query= word that takes a program and db
descriptor of where the db is, and returns a pipe (where results come
out). The program is a "query equivalent" and would need to be
translated to sql and post-processed. This is very much nontrivial and
a naive implementation probably wouldn't perform well but we will try
it anyway. For example instead of writing

#+begin_src sql
  insert into Customers (name, age) values ("Bob", 25); 
  select * from Customers where name="Bob";
#+end_src

you'd write something like
#+begin_src kcats
  customers [[name "Bob"] [age 25]] put
  
  customers [[name] lookup "Bob" =] filter
#+end_src

and 
And then the translation would see we're selecting from customers,
then there's a filter. The filter might not translate to sql so it
will either just select all, or if it sees a certain format for the
predicate it can translate to a =where= clause. This is going to be
complex and bug prone but hopefully can be done in a way that the
worst case is poor performance and then iterate to get better
speed.


I suppose content distribution might need to be done
alongside this.

** DONE Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
** DONE org-babel-execute for kcats
** INPROGRESS At least one example for each word in lexicon
#+begin_src kcats
10 0.5 *
#+end_src

#+RESULTS:
: 5

#+begin_src kcats
"foo" bytes
#+end_src

#+RESULTS:
: #b64 "Zm9v"

#+begin_src kcats
[[a b] [c [[d e]]]] [c d] 5 assign
#+end_src

#+RESULTS:
: [[c [[d 5]]] [a b]]

#+begin_src kcats
[[a b] [c []]] [c] [[d 5]] association assign
#+end_src

#+RESULTS:
: [[c [[d 5]]] [a b]]

#+begin_src kcats
[[a b] [c [[d e]]]] [1 1 0 1] 5 assign
#+end_src

#+RESULTS:
: [[a b] [c [[d 5]]]]

#+begin_src kcats
[[a b] [c [[d e]]]] [1 0] 5 assign
#+end_src

#+begin_src kcats
  4 3 [>] shield [wrap [wrap] dip] dip sink branch 
#+end_src

#+RESULTS:
: 4

#+begin_src kcats
  true 4 2 branch
#+end_src

#+RESULTS:
: [[asked [program]] [reason "type mismatch"] [type error] [unwound [branch]]] 2 4 true

#+begin_src kcats :results code :exports both
  5
  [1 2 "oh fudge"]
  [[+]
   []
   recover]
  map
#+end_src

#+RESULTS:
#+begin_src kcats
[[[type error] [reason "word is not defined"] [asked [handle]] [unwound []]] [[unwound []] [asked [handle]] [reason "word is not defined"] [type error]] [[asked [number]] [type error] [reason "type mismatch"] [unwound [+]]]] 5
#+end_src

#+begin_src kcats
5 1 [+] [] recover
#+end_src

#+RESULTS:
: [[unwound []] [asked [handle]] [reason "word is not defined"] [type error]] 1 5

#+begin_src kcats
1 type
#+end_src

#+RESULTS:
: number

#+begin_src kcats
5.01 5 0.1 swap [- abs] dip <
#+end_src

#+RESULTS:
: true

** TODO Prime number sieve example
#+BEGIN_SRC kcats :tangle sieve.kcats 
  2000 clone 2 swap range ;; all the numbers up to n

  [sqrt 2] dip  ;; start counter at 2, stop at sqrt of n
  [sink =] ;; stop loop when the counter hits sqrt n
  [[drop drop] dip]  ;; drop the original args, just leaving the primes
  [[[[=] 
     [swap mod positive?]]
    [execute] any?] 
   filter ;; keep the counter but no multiples of it 
   [inc] dip] ;; increment counter
  [execute]
  recur
#+END_SRC

#+RESULTS:
#+begin_src kcats
[[type error]
 [reason not enough items on stack]
 [unwound [sqrt 2 [[]]
           unwrap
           [sink =]
           [[drop drop]
            dip]
           [[[[=] [swap mod positive?]] [execute]
             any?] filter [inc]
            dip]
           [execute] recur]]
 [asked [consume]] [handled true]]
#+end_src

Here's a mimic of the python version, WIP:

#+begin_src kcats :results code
  ;; num
  10
  [[[] [true put]] dip times] shield ; a n
  2 ;; p a n
  [swapdown clone * > ] ;; while test
  [[wrap lookup] ; if test - fetch by index
   [
   swapdown ;; p n a
   clone ; p
   clone * ; p^2 p n a
   ;; range wants p, n+1, p^2 
   sink ;; p n p^2
   [inc] dip ;; p n+1 p^2
   [range] shield ;; r p n+1 p^2 a
   [dec sink drop] dipdown ;; r p a n
   swapdown ;; r a p
   [ ;; i r a p
    wrap ;;swapdown ;; [i] a r p
    [[]] update ;; set to false: a r p
    swap ;; r a p
   ]
   step ;; a p
   swap 
   ] ; do the for loop
   [] ; else do nothing
   if
   inc ;; p++
  ]
  while 
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason type mismatch]
 [type error]
 [unwound [fail [[2 [true true true true
                     true true true true
                     true true]
                  10]]
           unwrap evert
           first [[swapdown clone clone *
                   sink [inc] dip
                   [range] shield [dec sink drop]
                   dipdown swapdown [wrap [[]]
                                     update swap]
                   step swap]
                  []] unwrap
           branch inc [swapdown clone * >]
           shield [[wrap lookup]
                   [swapdown clone clone *
                    sink [inc] dip
                    [range] shield [dec sink drop]
                    dipdown swapdown [wrap [[]]
                                      update swap]
                    step swap]
                   []
                   if inc [swapdown clone * >]
                   shield] loop]]
 [actual [[type error]
          [asked [association]] [reason Lookup attempted on non-associative value]]] [asked
                                                                                      [association]]
 [handled true]] [[type error]
 [asked [association]] [reason Lookup attempted on non-associative value]] [2] [true true true true
 true true true true
 true true] 10
#+end_src

impl of 'repeat'
#+begin_src kcats
true 10 [] sink [wrap [put] join] dip times
#+end_src

#+RESULTS:
: [true true true true true true true true true true]

#+begin_src kcats
true 10 [] sink [wrap [put] join] dip times
#+end_src

#+RESULTS:
: [true true true true true true true true true true]

#+begin_src kcats :results code
     [] [[true] 15 times] inject
     2 swap ;; p a
     [clone clone *] dip swap ;; p^2 a p
     [[[count] shield] dip swap [<] shielddown] ;; b p^2 a p  
     [[wrap [drop []] update] shield ;; do the update 
      float drop sink [+] shielddown swapdown] ;; 
     ;while
#+end_src

#+RESULTS:
#+begin_src kcats
true 4 [true true true true true true true true true true true true true true true] 2
#+end_src

How do we write this code? Generally, how do we decide what order things go on the stack?

It looks like the array of bools is the main piece of data here, that
is used throughout the algorithm. The other commonly used variable is
p, the one that's incremented. I think probably p should remain on
top. The outermost loop needs to know when to stop, and that needs to
compare to num. That can go on the bottom.

The inner loop uses i. That should probably replace p on top when in use.
So it should be =[p a]= and later =[i a p]=.

Now that =lingo= exists, maybe should also write =let= for variables
(where the values are evaluated before updating the dictionary)?  Also
these aren't actually "variables" because you can't change the value,
without an inner =let=.

Actually this is probably best implemented in two parts:
+ a word that takes a set of bindings and evaluates the values,
  leaving a map of word to value
+ a word that takes the map above and inserts it into the
  dictionary. I think =lingo= does this already.

let's try to write the former here. I think we need =map-values= type of
thing here, which requires treating a map as a list.

#+begin_src kcats

#+end_src
#+begin_src kcats
  [[[a [+ 5 6]]
    [b [- 100 8]]]
   [a b +]
   let] 

#+end_src
* Roadmap Notes
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+BEGIN_SRC kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+END_SRC
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?
