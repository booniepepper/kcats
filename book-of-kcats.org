# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a stack-based programming language similar to Joy,
and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Goals
** Easy for a beginner programmer to learn
*** Use as few concepts as possible
The language should use as few concepts as possible. It may include

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Nested datatypes (lists, maps)
+ Functions
+ Channels

It will explicitly *not* use

+ Variables
+ User-defined Types (static or dynamic)
+ Classes
+ Loops
+ Lexical or dynamic scope rules
+ Macros
*** Easy to understand documentation
**** Documentation by example
By documenting by example only, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

Items inside square brackets [] are quotations.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
#+END_EXAMPLE


** Easy to implement
** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.
** Easy static analysis
* Definining some terms
:PROPERTIES:
:CUSTOM_ID: definitions
:END:
- stack :: A first-in, first-out structure. This is mainly where data
           the program needs to manipulate will be stored.
- aggregate :: A list of items, which can be interpreted either as
               data or executable code.
- program :: an aggregate intended to be executable.
- word :: causes the program to do something, usually taking some
          items from the top of the stack and using them to create new
          stack items. Some words may do nothing but put themselves on
          the stack.
- axiom word :: A word that is defined in the base language, not in
                terms of other words.
- definition :: what exactly a word is supposed to do, represented
                either in the base language for axiom words, or as a
                program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program being evaluated, which needs
                to be broken down into axiom words and executed.
- environment :: the entire state of the program, which generally
                 consists of a dictionary and one or more stacks.
- predicate :: a word that consumes stack items and leaves either true
               or false on the stack.
- channel :: A method to communicate between stacks. Values are put
             into channels on one stack, and emerge in another.
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library `expound` which gives easier
to understand error messages.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::boolean boolean?)
  (spec/def ::number number?)
  (spec/def ::string string?)
  (spec/def ::bytes bytes?)
#+END_SRC

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be aggregates, which we haven't specced yet. That's ok,
recursive specs are allowed. Aggregates contain items, and items
can also be aggregates.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::item
    (spec/or :aggregate ::aggregate
             :boolean ::boolean
             :number ::number
             :string ::string
             :bytes ::bytes
             :word ::word))
#+END_SRC

Now we'll spec an aggregate, which is just a list. We'll use
clojure's vectors (which are indexed lists). We'll also spec out
programs, which are aggregates but intended to be executed (otherwise
there is no difference).

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::aggregate (spec/coll-of ::item :kind vector?) "aggregate?")
  (expound/def ::program ::aggregate)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (def word? symbol?)
  (spec/def ::word word?)

  (spec/def ::axiom-definition (spec/keys :req [::fn ::spec]))
  (spec/def ::program-definition (spec/keys :req [::fn ::definition]))

  (spec/def ::dictionary (spec/map-of ::word (spec/or ::axiom-definition
                                                      ::program-definition)))
#+END_SRC

Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

Since a stack is a list of items, we need to also define what a "stack
item" is - it's any of the types we've specced up until now. 

An expression is also a list of items that are being broken down into
their axiomatic parts.
#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::stack (spec/coll-of ::item
                                  :kind list?))

  (spec/def ::expression (spec/coll-of ::item
                                       :kind list?))
#+END_SRC

Next we'll spec what an Environment is - it's currently just a
dictionary, stack, and expression put together. Later we might allow
multiple stacks.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::environment (spec/keys :req [::stack ::dictionary ::expression]))
#+END_SRC
** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a [[#definitions][program]]. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do and we return the
last environment.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (declare eval-step) ;; we'll define this later

  (defn eval
    [env]
    (->> env
         (iterate eval-step)
         (drop-while #(-> % ::expression seq))
         first))
#+END_SRC

Now, we define =onto-stack=, which says what we do to put an item onto
the stack. Simple items like numbers, strings and undefined words,
just go straight onto the stack with no changes. 

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defmulti onto-stack
    "Evaluate one item in the given environment. A single step in a
    program's execution."
    (fn [{[item] ::expression}]
      (type item)))

  (defn- push
    "Push an item from the expression into the stack"
    [{[item & others] ::expression :as env}]
    (-> env
        (assoc ::expression others)
        (update ::stack conj item)))

  (defmethod onto-stack Number [env]
    (push env))

  (defmethod onto-stack String [env]
    (push env))

  (defmethod onto-stack Boolean [env]
    (push env))

  ;; PersistentVector is the clojure type for an aggregate
  (defmethod onto-stack clojure.lang.PersistentVector [env]
    (push env))

  (defmethod onto-stack (Class/forName "[B") [env]
    (push env))
#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

We'll also specify here what a step of evaluation is - it looks at the
next item in the expression. If it has a definition, it's replaced
with its definition. Otherwise it's put onto the stack.

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.
#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defmethod onto-stack clojure.lang.Symbol [{[word & others] ::expression
                                              ::keys [dictionary stack]
                                              :as env}]
    (let [{f ::fn spec ::spec} (dictionary word)]
      (when spec
        (spec/assert spec stack))
      (if f
        (f (update env ::expression rest))
        (push env))))

  (defn definition
    "Returns the definition of an item, if it's a word defined in terms
    of other words"
    [{::keys [dictionary] :as env} item]
    (some-> dictionary (get item) ::definition))

  (defn eval-step
    "Evaluate one step in the environment."
    [{[next-item & items] ::expression ::keys [stack dictionary] :as env}]
    (println (dissoc env ::dictionary))
    (if-let [d (definition env next-item)]
      (assoc env ::expression (into items d)) ;; replace item with definition
      ;; eval the thing onto the stack
      (onto-stack env)))
#+END_SRC
** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defn update-stack [f env]
    (update env ::stack f))

  (defn s-apply
    "Take nitems off the stack, apply them to f. f should return a list
     to put back onto the stack."
    [nitems f stack]
    (let [[a b] (split-at nitems stack)]
      (into b (apply f a))))

  (defn s-apply-one
    "Like s-apply, but useful for functions where you only want to put
     one item back on the stack and f doesn't return a
     list. Automatically creates a list of one item."
    [nitems f stack]
    (s-apply nitems (comp list f) stack))

  (defn f-stack
    "Apply nitems from stack to f, put result back on stack"
    [nitems f]
    (partial update-stack (partial s-apply-one nitems f)))

  (defn inscribe
  "Define a new word. Takes an aggregate off the stack which should be of the
   form:
   [new-word [program-item1 [program-item2 ...]]"
    [{[[word word-def] & others] ::stack
      ::keys [expression dictionary]}]
    {::stack others
     ::expression (pop expression)
     ::dictionary (assoc dictionary word {::definition word-def})})
#+END_SRC

Here are some tests for what we have so far. This test will inscribe a
new word, =plus= and then use it.
#+BEGIN_SRC clojure 
  (eval {::expression '[1 2 [plus [+]] inscribe plus]
         ::dictionary {'+ {::fn (f-stack 2 #'+)}
                       'inscribe {::fn #'inscribe}}
         ::stack '()})
  ;; should yield (3)

#+END_SRC

Now we can go ahead and start filling out axiom words in our default dictionary.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj

  (spec/def ::stack-min-depth-1 (spec/coll-of ::item
                                              :kind list?
                                              :min-count 1))
  (spec/def ::stack-min-depth-2 (spec/coll-of ::item
                                              :kind list?
                                              :min-count 2))

  (spec/def ::binary-arithmetic (spec/cat :x ::number
                                          :y ::number
                                          :others (spec/* ::item)))

  (spec/def ::predicate (spec/cat :x ::item
                                  :others (spec/* ::item)))

  (spec/def ::quoted-word (spec/coll-of ::word
                                        :count 1
                                        :kind vector?))
  (def arithmetic-words
    (into {} cat
          [(for [sym ['+ '- '/ '* '< '<= '> '>= 'min 'max]]
             [sym
              {::spec ::binary-arithmetic
               ::fn (f-stack 2 (resolve sym))}])
           (for [sym ['inc 'dec]]
             [sym
              {::spec (spec/cat :x ::number
                                :others (spec/* ::item))
               ::fn (f-stack 1 (resolve sym))}])]))

  (def predicates
    (into {} cat
          [(for [sym ['odd? 'even? 'sequential? 'zero? 'pos? 'neg?
                      'number? 'int? 'true? 'false? 'nil? 'some?
                      'string? 'empty?]]
             [sym {::spec ::predicate
                   ::fn (f-stack 1 (resolve sym))}])
           (for [sym ['starts-with? 'ends-with?]]
             [sym {::spec ::stack-min-depth-2
                   ::fn (f-stack 2 (resolve sym))}])]))

  (def builtin-words
    (merge
     arithmetic-words
     predicates
     {'discard {::spec ::stack-min-depth-1
                ::fn (partial update-stack rest)}
      'clone {::spec ::stack-min-depth-1
              ::fn (partial update-stack (fn [s]
                                           (conj s (first s))))}
      'swap {::spec ::stack-min-depth-2
             ::fn (partial update-stack (fn [[a b & others]]
                                          (-> others
                                              (conj a)
                                              (conj b))))}
      'execute {::spec (spec/cat :program ::aggregate
                                 :others (spec/* ::item))
                ::fn (fn [{[p & others] ::stack ::keys [dictionary expression]}]
                       {::stack others
                        ::expression (into expression p)
                        ::dictionary dictionary})}
      'dip {::spec (spec/cat :program ::aggregate
                             :x ::item
                             :others (spec/* ::item))
            ::fn (fn [{[p x & others] ::stack ::keys [dictionary expression]}]
                   {::stack others
                    ::expression (into expression (conj p x))
                    ::dictionary dictionary})}
      'inscribe {::spec (spec/cat :definition (spec/tuple ::word ::aggregate)
                                  :others (spec/* ::item))
                 ::fn #'inscribe}
      'describe {::spec (spec/cat :word (spec/tuple ::word)
                                  :others (spec/* ::item))
                 ::fn (fn [{[[word] & others] ::stack dict ::dictionary :as env}]
                        (let [dfn (-> dict (get word) ::definition)]
                          (if dfn
                            (assoc env ::stack (conj others dfn))
                            (-> "Word %s is not defined"
                                (format word)
                                Exception.
                                throw))))}
      'branch {::spec (spec/cat :condition ::boolean
                                :true-branch ::aggregate
                                :false-branch ::aggregate
                                :others (spec/* ::item))
               ::fn (fn [{[b t f & others] ::stack expression ::expression :as env}]
                      (-> env
                          (assoc ::stack others)
                          (update ::expression into (conj (if b t f)))))}
      '= {::spec (spec/cat :x ::item
                           :y ::item
                           :other (spec/* ::item))
          ::fn (f-stack 2 =)}
      'cons {::spec (spec/cat :x ::item
                              :aggregate ::aggregate
                              :others (spec/* ::item))
             ::fn (f-stack 2 (comp vec cons))}
      'some {::spec (spec/cat :program ::aggregate
                              :aggregate ::aggregate ;; TODO finish this
                              :others (spec/* ::item))
             ::fn (fn [env]
                    (update-stack
                     (fn [[p a & others :as stack]]
                       )))}
      'first {::spec (spec/cat :aggregate ::aggregate, :other (spec/* ::item))
              ::fn (f-stack 1 first)}
      'map {::spec (spec/cat :program ::aggregate
                             :aggregate ::aggregate
                             :others (spec/* ::item))
            ;; runs a parallel simulation - if the map function
            ;; tries to add or remove more stack elements those
            ;; changes will be lost - only top stack element is
            ;; collected from each parallel run of p
            ::fn (fn [env]
                   #_(update-stack (fn [[p a & others :as stack]]
                                     (conj others
                                           (->> (for [item a]
                                                  (eval (with-stack env (conj others item)) p))
                                                (map (comp first :stack))
                                                (into []))))
                                   env))}
      'filter {::spec (spec/cat :program ::aggregate
                                :aggregate ::aggregate
                                :others (spec/* ::item))
               ;; runs a parallel simulation - if the filter function
               ;; tries to add or remove more stack elements those
               ;; changes will be lost - only top stack element is
               ;; collected from each parallel run of p
               ::fn (fn [env]
                      #_(update-stack (fn [[p a & others :as stack]]
                                        (->> a
                                             (filter #(leaves-true? (with-stack env (conj others %)) p))
                                             (into [])
                                             (conj others)
                                             (into [])))
                                      env))}

      'every? {::spec (spec/cat :program ::aggregate
                                :aggregate ::aggregate
                                :others (spec/* ::item))
               ::fn (fn [env]
                      #_(update-stack (fn [[p a & others :as stack]]
                                        (->> a
                                             (every? #(leaves-true? (with-stack env (conj others %)) p))
                                             (conj others)))
                                      env))}
      'and  {::spec (spec/cat :x ::item, :y ::item,
                              :others (spec/* ::item))
             ::fn (f-stack 2 #(and %1 %2))}
      'or  {::spec (spec/cat :x ::item, :y ::item,
                             :others (spec/* ::item))
            ::fn (f-stack 2 #(or %1 %2))}
      'in  {::spec (spec/cat :aggregate ::aggregate, :item ::item
                             :other (spec/* ::item))
            ::fn (f-stack 2 contains?)}
      'intersection {::spec (spec/cat :aggregate-x ::aggregate, :aggregate-y ::aggregate,
                                      :others (spec/* ::item))
                     ::fn (f-stack 2 (fn [x y]
                                       (into []
                                             (clojure.set/intersection
                                              (into #{} x)
                                              (into #{} y)))))}
      'trace {::spec (spec/cat :program ::aggregate
                               :others (spec/* ::item))
              ::fn (fn [{[p & others] :stack :as env}]
                     #_(reduce (fn [env item]
                                 (let [r (eval-one env item)]
                                   (debug r item)
                                   r))
                               (with-stack others)
                               p))}}))(spec/def ::binary-arithmetic (spec/cat :x ::number
                                                                              :y ::number
                                                                              :others (spec/* ::item)))


#+END_SRC
