# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to express short
  programs. You can't write just 1 line of C++ or even python. But you
  will be able to write meaningful kcats expressions that are just a
  few words, and be able to put them into an application to get it to
  do what you want. While typical applications are menu-driven, kcats
  based applications will be message-driven, where a message is some
  words sent to a running program. 
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just values (numbers,
words, text, true/false) and quotation marks. No other symbols - no
periods, exclamation points, semicolons, equals, plusses, ampersands,
or asterisks.

Quotations are marked with square brackets, those are the only two
symbols that carry any meaning. 
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as input,
then the resulting stack afterward (both the before and after stack
are surrounded with square braces):

#+BEGIN_EXAMPLE
[true ☯] [false]
[false ☯] [true]
#+END_EXAMPLE

In the example without knowing in advance what the =☯= symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Powerful
The language should allow the user to express himself succinctly and
without a lot of ceremony or repetition.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
The language should be well positioned to handle various types of
programming tasks, including numerical computation, API client/server,
networking applications, machine learning, etc.

** Make tool development as easy as possible
+ Debuggers
+ IDEs

Wherever possible, tooling should be baked into the language.
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put
=1= onto the stack. Then we put =2= onto the stack (so that =2= is on
top and =1= is beneath it). Then we put the word =+= onto the stack
and it will consume the =2= and the =1= and replace them with the sum,
which is =3=. (The =3= is shown in square brackets because the results
are what's on the stack when the program is done, and the stack is a
list, which is delimited with square brackets).
#+BEGIN_SRC kcats :results code :exports both
1 2 +
#+END_SRC

#+RESULTS:
#+begin_src kcats
[3]
#+end_src

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add =1=
and =2= (leaving =3= on the stack), and then put =5= and =*= on
the stack (which consumes the =5= and =3=, leaving =15=):

#+begin_src kcats :results code :exports both
1 2 + 5 *
#+end_src

#+RESULTS:
#+begin_src kcats
[15]
#+end_src

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 + 5 * 
            1 | 2 + 5 * 
          1 2 | + 5 *
            3 | 5 *
          3 5 | *
           15 |  
#+end_example

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.

#+begin_src kcats :results code :exports both
[1 2 3] [4 5] join
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2 3 4 5]]
#+end_src

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [* +] execute
                    4 | 5 6 [* +] execute
                  4 5 | 6 [* +] execute
                4 5 6 | [* +] execute
          4 5 6 [* +] | execute
                4 5 6 | * +
                 4 30 | +
                   34 |
#+end_example
Note that, when =* += gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =* += would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_src kcats :results code :exports both
4 5 6 [+] [*] join execute
#+end_src

#+RESULTS:
#+begin_src kcats
[44]
#+end_src

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote, a message being
passed along and not acted upon until it reaches the recipient.

** Data types
*** Words
In kcats, words have two main types
+ verbs, which result in actions being performed, and are defined in
  the dictionary
+ nouns or adjectives, which are used as labels or names for things,
  and are not in the dictionary.

The first type, verbs, are used directly in the execution of programs:

#+begin_src kcats :results code :exports both
  1 clone 2 swap
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 1]
#+end_src

The second type are used inside lists, often as keys in a map. These
words are never executed, they're used more like you'd use strings or
keywords in other programming languages.

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] unwrap pack
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar baz quux]]
#+end_src

Note the use of =unwrap= here. What's wrong with just trying to =pack=
=quux= directly into the list? The problem is when kcats encounters a
word during execution,it checks the dictionary to see what to do. If
the word isn't there, that's an error.

#+begin_src kcats :results code :exports both
  [foo bar baz] quux pack
#+end_src

#+RESULTS:
#+begin_src kcats
  [[[type error]
    [reason "word is not defined"]
    [unwound [quux pack]]
    [asked [quux]]]
   [foo bar baz]]
#+end_src

What we want is to get =quux= onto the stack by itself without actually
executing it. We can do that with =[quux] unwrap=. The word =unwrap= does
just what it says, removes the list wrapper and leaves a bare word on
the stack. Another way to go about this is to use =join= so we don't
need =unwrap=:

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] join
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar baz quux]]
#+end_src

*** Booleans
Kcats doesn't have traditional boolean values =true= and =false=. In
kcats, an empty list =[]= is the equivalent of =false=, aka "falsey") and
anything else is the equivalent of =true= (aka "truthy").

#+begin_src kcats :results code :exports both
  [] ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
["no"]
#+end_src

#+begin_src kcats :results code :exports both
  "anything" ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
["yes"]
#+end_src

Some words will return the word =true=, but it's not really a boolean,
it's just the word =true= which has no special meaning other than that
it's an arbitrary truthy value. By convention, for readability, if
your function needs to return a truthy value and there isn't anything
specific you need to return, you should use the word =true=. For
convenience, =true= is self-evaluating so it doesn't need to be quoted.

#+begin_src kcats :results code :exports both
  3 odd?
#+end_src

#+RESULTS:
#+begin_src kcats
[true]
#+end_src


*** Lists

*** Associations
An association looks just a list of pairs, like this:
#+begin_src kcats
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]
#+end_src

However there are some words you can use that make a list behave a bit
differently. For example:

#+begin_src kcats :results code :export both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] 25 assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[[name "Alice"] [favorite-color "brown"] [age 25]]]
#+end_src

Here we want to reset Alice's age - but we don't want to create a new
item, we want to find the existing one and replace it. It will create
a new item if it doesn't exist:

#+begin_src kcats :results code :export both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [department] "Sales" assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[[favorite-color "brown"] [department "Sales"] [age 24] [name "Alice"]]]
#+end_src

Notice that the order of the items is not preserved. Once you treat a
list as an association, it "sticks" - it acts like an association from
then on and order is no longer guaranteed to be maintained.

We can improve upon our example that incremented Alice's age
(presumably after her birthday) with the word =update=. That will run a
program on the value of whatever key (or keys) you specify.

#+begin_src kcats :results code :export both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update
#+end_src

#+RESULTS:
#+begin_src kcats
[[[favorite-color "brown"] [name "Alice"] [age 25]]]
#+end_src

Note that associations and lists look the same when printed but
testing them for equality can reveal they are not the same:

#+begin_src kcats :results code :export both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  =
#+end_src

#+RESULTS:
#+begin_src kcats
[[]]
#+end_src

Here we are comparing an association with a list. The === operator has
no way of knowing whether you want the list semantics (which does care
about order), and the association semantics (which doesn't care). It
defaults to the more strict rules, so they are not equal.

The act of using a list as an association (by applying words to it
like =assign= or =update=) will convert it to an association, but what if
you just want to convert a list without doing anything else?

You can use the word =association= to convert the list to an association:

#+begin_src kcats :results code :export both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  association =
#+end_src

#+RESULTS:
#+begin_src kcats
[true]
#+end_src


* Implementations
+ [[file:prototype.org::*Prototype implementation][Prototype implementation]]
+ [[file:production.org::*Production implementation][Production implementation]]
* Using
** Building
*** Dependencies
+ emacs
+ Runtime/compiler for the implemenation you're trying to run

*** Creating the source
The source is contained within these org files, along with annotations
and other non-code information. To generate the source code (that the
runtime or compiler needs as separate files) before running or
building, open the org file for the given implementation, and run
=M-x= =org-babel-tangle=.

See [[*Build without using emacs interactvely][Build without using emacs interactvely]]
*** Building and Running
See the Using heading in the file for the implementation you want to
use.
** Debugging
*** Trace analyzer
**** Overview
We can trace the execution of any program already (see Printing and
=before-step= option for evaluation). But once we have the trace
output it can be huge and difficult to find the place where things
went wrong.

We can apply a debugger after the fact, just using the trace output -
it contains all the data about what happened. We can do typical debug
operations like =step into=, =step over=, =breakpoint= etc.

**** Emacs lisp
#+BEGIN_SRC emacs-lisp
;; Some functions to move around in a buffer containing
;; kcats trace output

(require 'parseedn 'parseclj-alist)

(setq kcats.trace/stack-expression-splitter :.)

(defun kcats.trace/split-line
    (parsed-line)
  (let ((splitter-pos (seq-position parsed-line kcats.trace/stack-expression-splitter)))
    (list (seq-subseq parsed-line 0 splitter-pos)
          (seq-subseq parsed-line (1+ splitter-pos)))))

(defun kcats.trace/parse-current ()
  (interactive)
  (let ((l (thing-at-point 'line t)))
    (with-temp-buffer
      (insert l)
      (goto-char (point-min))
      (parseedn-read `((object . ,#'identity))))))

(defun kcats.trace/expression-depth ()
  (interactive)
  (length (first (kcats.trace/split-line (kcats.trace/parse-current)))))

(defun kcats.trace/step-over-forward ()
  (interactive)
  (let* ((starting-depth (kcats.trace/expression-depth))
         (current-depth starting-depth)
         (lines-unmoved 0))
    (while (and (>= current-depth starting-depth)
                (= lines-unmoved 0))
      (setq lines-unmoved (forward-line 1))
      (setq current-depth (kcats.trace/expression-depth))))
  (search-forward " :. "))

(defun kcats.trace/read-lexicon
    ()
  (beginning-of-buffer)
  (setq kcats.trace/lexicon (parseedn-read `((object . ,#'identity)))))

;; Why is there no "step-over-backward"? Because lots of words can end
;; on the same line, we don't know which one we want to search
;; backward for the beginning of. If you are stepping forward through
;; execution and you go too far, use `point-stack-pop' to return to
;; the last place you were.

;; Why is there no step-out? There is no function call stack. We don't
;; know which function we're currently executing, so we can't tell
;; when we've finished it.
#+END_SRC

#+RESULTS:
: kcats\.trace/read-lexicon

** Developing
*** Emacs mode
#+BEGIN_SRC emacs-lisp
(defface kcats-brackets 
  '((((class color)) (:foreground "DimGrey" :weight bold)))
  "kcats brackets" :group 'faces)
(defface kcats-stackop 
  '((((class color)) (:foreground "LightGreen" :inherit 'font-lock-keyword-face)))
  "kcats stack manipulation operation" :group 'faces)

(defconst kcats-font-lock-keywords
      `(("\\[\\|\\]" 0 'kcats-brackets)
        (";;.*" 0 'font-lock-comment-face)
        (,(regexp-opt '("swap" "swapdown" "discard" "sink" "float" "clone" "snapshot" "evert") 'words) . (0 font-lock-builtin-face))
        (,(regexp-opt '("true" "false" "[]") 'words) . (0 font-lock-keyword-face))
        (,(regexp-opt '("first" "second" "pack" "unpack" "step" "filter"
                        "map" "count" "join" "rest" "wrap" "unwrap" "reverse") 'words) . (0 font-lock-function-name-face))
        (,(regexp-opt '("execute" "dip" "dipdown" "shield" "shielddown" "shielddowndown" "inject"
                        "loop" "while" "if" "branch" "recur" "times") 'words) . '(0 font-lock-preprocessor-face))
        ("#?\"" 0 'double-quote prepend)))

(add-hook 'kcats-mode-hook (lambda () (font-lock-add-keywords nil kcats-font-lock-keywords)))

(require 'smie) ;; indentation engine

(setq kcats-mode-syntax-table (let ((table (make-syntax-table)))
    ;; Initialize ASCII charset as symbol syntax
    (modify-syntax-entry '(0 . 127) "_" table)

    ;; Word syntax
    (modify-syntax-entry '(?0 . ?9) "w" table)
    (modify-syntax-entry '(?a . ?z) "w" table)
    (modify-syntax-entry '(?A . ?Z) "w" table)

    ;; Whitespace
    (modify-syntax-entry ?\s " " table)
    (modify-syntax-entry ?\xa0 " " table) ; non-breaking space
    (modify-syntax-entry ?\t " " table)
    (modify-syntax-entry ?\f " " table)
    ;; Setting commas as whitespace makes functions like `delete-trailing-whitespace' behave unexpectedly (#561)
    (modify-syntax-entry ?, "." table)

    ;; Delimiters
    (modify-syntax-entry ?\[ "(]" table)
    (modify-syntax-entry ?\] ")[" table)

    ;; Others
    (modify-syntax-entry ?\; "<" table) ; comment start
    (modify-syntax-entry ?\n ">" table) ; comment end
    (modify-syntax-entry ?\" "\"" table) ; string
    (modify-syntax-entry ?\\ "\\" table) ; escape

    table))

(define-derived-mode kcats-mode fundamental-mode "kcats"
  "major mode for editing kcats."
  (set-syntax-table kcats-mode-syntax-table)
  (setq-local comment-start ";") ;; try ";;"
  (setq-local comment-end "")

  (smie-setup nil (lambda (method arg)
                    (when (eq method :list-intro)
                      t)))
  (setq font-lock-defaults '(kcats-font-lock-keywords)))

(add-to-list 'auto-mode-alist '("\\.kcats\\'" . kcats-mode))
(defun my-restart-kcats-mode ()
  (interactive)
  (let ((kcats-mode-hook nil))
    (normal-mode)))
#+END_SRC

#+RESULTS:
: my-restart-kcats-mode

*** org-babel mode
#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:kcats (body params)
  "Execute a block of kcats code with org-babel."
  (org-babel-eval
   kcats-babel-executable
   body))

(defcustom kcats-babel-executable "kcats"
  "Location of the kcats binary"
  :type 'string
  :group 'kcats-babel)
#+END_SRC

#+RESULTS:
: kcats-babel-executable

* Contributing
** Bug reports
Instead of opening a github issue, add a =TODO= subheading to the
[[*Issues][Issues]] heading. Commit the change and submit it as a pull request. In
the branch where that issue is being fixed, it will be changed to
=INPROGRESS=. When the issue is fixed, the heading will be
removed. (If you disagree that it's been fixed, submit a PR that
reverts the commit to remove it).

You can edit this file right on github, in your own fork of the
project, if you prefer.

Why do things this weird way? I don't want to rely on github, nice as
it is.
* Issues
** TODO Build without using emacs interactvely
Users should not be required to know emacs to build the project, only
have it installed. The build should be accessible from bash without
having to use emacs interactively. 
** INPROGRESS Remove platform interop from lexicon
That was only there as a cheat when there was only the prototype
implementation. The platforms are different and their function names
don't belong in the lexicon.

I'm not even sure there should be platform interop at all - it doesn't
appear to be possible in the rust impl anyway.

So far what I've done is have some lower level words actually in the
dictionary but marked them like `++lookup`. I haven't decided what to
do about this yet. Lower level words probably should just be first
class citizens and I just need to think of better names. Right now the
low level (single-depth) lookup is `++lookup` and the user-facing
`lookup` does the arbitrary depth. In this case, the user-facing name
probably needs to change to reflect what it does (something like
`drill` or `extract`), and then the low level can just be `lookup`.

That means for all the i/o and crypto interactions, there needs to be
low-level words. I'm not sure yet how to prevent namespace pollution,
as one of the design choices is
** TODO 'unassign' doesn't take a keylist, only a single key
Should change to match =assign= and =lookup=, accept a list instead of
a single bare word.
** INPROGRESS More support for nested/related envs
Debuggers, spawning, ingesting etc
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?
** TODO Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
** DONE org-babel-execute for kcats

* Notes
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+BEGIN_SRC kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+END_SRC
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?


* Example programs
** Factorial
*** Recursive definition 
#+BEGIN_SRC kcats
10 
[fact [[clone 0 =]
       [discard 1]
       [clone dec fact *]
       if]]
inscribe
fact
#+END_SRC

*** Recursive with recur
#+BEGIN_SRC kcats
10
[1 <=]
[]
[clone dec]
[execute *]
recur
#+END_SRC

*** Using range
#+BEGIN_SRC kcats
10
inc [1 2] dip range 
[*] step
#+END_SRC

*** Plain loop
#+BEGIN_SRC kcats
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+END_SRC

** Spawn child environments and pipe values back
#+BEGIN_SRC clojure
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[discard] dip ;; done with the pipe
+ ;; add numbers
#+END_SRC
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
#+BEGIN_SRC kcats
100 [0] [[1.0 swap /] dip +] primrec
#+END_SRC

** Primrec
#+BEGIN_SRC clojure
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+END_SRC
** Fibonacci
#+BEGIN_SRC kcats
50 [1 0] swap [[[+] shield] inject] times reverse
#+END_SRC

#+RESULTS:
: 
: [[0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074]]

** Prime numbers (sieve of eratosthenes)
#+BEGIN_SRC kcats
2000 clone 2 swap range ;; all the numbers up to n

[sqrt 2] dip  ;; start counter at 2, stop at sqrt of n
[sink =] ;; stop loop when the counter hits sqrt n
[[discard discard] dip]  ;; drop the original args, just leaving the primes
[[[[=] 
   [swap mod positive?]]
  [execute] any?] 
 filter ;; keep the counter but no multiples of it 
 [inc] dip] ;; increment counter
[execute]
recur
#+END_SRC

#+RESULTS:
: 
: [[2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999]]

** Prime factors
#+BEGIN_SRC kcats :results code
195969127

[] swap 2

[/ 2 >]
[[mod zero?]
  [clone sink [pack] dipdown / 2]
  [inc]
  if]
while

discard pack
#+END_SRC

#+RESULTS:
#+begin_src kcats

[[157 1248211]]
#+end_src

** bidirectional comms from a socket
#+begin_example clojure
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; assembled
 [[type ip-port]
  [address "localhost"]
  [port 9988]] ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 assemble] ;; receive
#+end_example
** Write string to a file
#+begin_example clojure
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_example
** Search the dictionary
#+BEGIN_SRC kcats :results code
dictionary ;; put the dictionary of all words onto the stack as key value pairs
[second ;; the value of one of those pairs
 [spec] lookup ;; look up the spec field
 first ;; the input part of the spec
 [program] =] ;; is it taking a single input, a program?
filter ;; filter the dictionary using the above criteria
[first] map ;; of what remains, just keep the key (which is the word itself)

;; when we run this, we get
;;[[shield execute assert]]
;; which are the words in the dictionary that take just a program as
;; input.
#+END_SRC

#+RESULTS:
#+begin_src kcats

[[spawn execute environment shield assert]]
#+end_src
