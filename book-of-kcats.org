
# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to write short
  programs. This cuts users off from vast amounts of
  functionality. For example, what if they want their phone's alarm
  clock to only go off if it is not raining? That's just a few words
  of english to describe, and the phone usually has a weather function
  that knows if it's raining. But there's just no facility for the
  user to express what he wants - if it's not on the menu, the user is
  out of luck.
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just words and quotation
marks. No other symbols - no periods, exclamation points, semicolons,
equals, plusses, ampersands, or asterisks.

Quotations are marked with square brackets, those are the only two
symbols that carry any meaning. 
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
false â˜¯ ðŸ’­ true
#+END_EXAMPLE

In the example without knowing in advance what the â˜¯ symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Easy static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put 1
onto the stack. Then we put 2 onto the stack (so that 2 is on top and
1 is beneath it). Then we put the word =add= onto the stack and it
will consume the 2 and the 1 and replace them with the sum, which
is 3.
#+begin_example
1 2 add
=> 3
#+end_example

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add 1
and 2 (leaving 3 on the stack), and then put 5 and =multiply= on the
stack (which consumes the 5 and 3, leaving 15):

#+begin_example
1 2 add 5 multiply
=> 15
#+end_example

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 add 5 multiply 
            1 | 2 add 5 multiply 
          1 2 | add 5 multiply
            3 | 5 multiply
          3 5 | multiply
           15 |  
#+end_example

When there is nothing left to the right of the =|=, the program is
finished and the result is what is left on the stack (in this case
15).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.
#+begin_example
[1 2 3] [4] join
=> [1 2 3 4]
#+end_example

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a "list that looks like a program" is
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [multiply add] execute
                    4 | 5 6 [multiply add] execute
                  4 5 | 6 [multiply add] execute
                4 5 6 | [multiply add] execute
 4 5 6 [multiply add] | execute
                4 5 6 | multiply add
                 4 30 | add
                   34 |
#+end_example
Note that, when =multiply add= gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =multiply add= would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_example
4 5 6 [add] [multiply] join execute
=> 34
#+end_example

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote. If you said to Bob,
"Tell Alice 'bring your tennis racket'", Bob hears "bring your tennis
racket" but he knows that isn't meant for him, it's just a message to
be passed along to Alice. Similarly, when you put a program on the
stack, it's a message to be passed on now, and perhaps acted on later.
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Base Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library =expound= which gives easier
to understand error messages.

#+BEGIN_SRC clojure
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval test]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

What's important here is that we have some basic value types. Values
are stateless - they can be sent over a wire to some remote machine
without losing any meaning (the number 5 is always the number
5). 

There is only one common type in the system that has state (and
therefore would lose meaning being sent to a remote machine): a
pipe. See [[*Pipes][this later section]] for more detail. Kcats allows other
stateful things on the stack (like java objects, clojure atoms etc)
but best practice is that they should only be there temporarily,
usually during the construction of a pipe[fn:2].

#+BEGIN_SRC clojure
(expound/def ::boolean boolean?)
(expound/def ::number number?)
(expound/def ::string string?)
(expound/def ::bytes bytes?)
(expound/def ::integer integer?)
#+END_SRC

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be list, which we haven't specced yet. That's ok, recursive
specs are allowed. Lists contain items, and items can be lists.

Values are a particular kind of item, which is what most =words= will
operate upon. A value list is one where all the contents are
values.
#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(expound/def ::value
  (spec/or :value-list ::value-list
           :boolean ::boolean
           :number ::number
           :string ::string
           :bytes ::bytes
           :word ::word))

(expound/def ::item (constantly true))
#+END_SRC

Now we'll spec a list. We'll use clojure's vectors (which are indexed
lists). We'll also spec out programs, which are lists but intended to
be executed (otherwise there is no difference).

#+BEGIN_SRC clojure
(expound/def ::list (spec/coll-of ::item :kind vector?) "list?")
(expound/def ::value-list (spec/coll-of ::value? :kind vector?) "value-list?")
(expound/def ::program ::list)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure
(def word? symbol?)
(expound/def ::word word?)

(expound/def ::axiom-definition (spec/keys :req [::fn ::spec]))
(expound/def ::program-definition (spec/keys :req [::definition]))

(expound/def ::dictionary (spec/map-of ::word
                                       (spec/or :axiom ::axiom-definition
                                                :user-defined ::program-definition)))
#+END_SRC
Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

An expression is a stack too, but it represents words waiting to be
executed - parts of the program that haven't run yet. In kcats, the
program modifies itself heavily, so it is constantly adding pieces to
the expression.
#+BEGIN_SRC clojure
(def stack? (every-pred (complement indexed?) sequential?))

(expound/def ::stack (spec/coll-of ::item
                                   :kind stack?))

(expound/def ::expression (spec/coll-of ::item
                                        :kind stack?))

#+END_SRC

Next we'll spec what an Environment is - it's just a dictionary,
stack, and expression put together.

#+BEGIN_SRC clojure
  (expound/def ::environment (spec/keys :req [::stack ::dictionary ::expression]))
#+END_SRC

Finally, we'll make a bit of syntax for expressing what a particular
word needs on the stack.

#+begin_src clojure
;; since we'll commonly be defining specs for a stack, we'll nearly
;; always not care about anything below a certain depth, so let's make
;; a macro that encapsulates that.
(defmacro stack-spec
  [& args]
  `(spec/cat ~@args
             :others (spec/* ::item)))

;; also make a function for creating a spec from kcats data
(defn build-spec
  [specs]
  (assert (and (vector? specs)
               (every? vector? specs)
               (every? symbol? (into [] cat specs))))
  (clojure.core/eval `(stack-spec
                       ~@(into [] cat
                               (for [[spec-name spec-type] specs]
                                 [(keyword (str spec-name))
                                  (keyword "kcats.core" (str spec-type))])))))

#+end_src

[fn:2] There are some pipes that may be technically values (think of a
pipe that produces the infinite sequence 1,2,3...). You could send
that somewhere else, as long as you include what number it last
produced. But you can't send files or sockets somewhere else (they're
pointers to real world resources that may be different or nonexistent
somewhere else). Discerning between the two may be a future feature.

** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a program. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do and we return the
last environment.

We also allow some execution options, like being able to stop after a
certain number of steps (to prevent infinite looping), or do something
before each step (like printing out the environment as a way of
tracing what's happening).
#+BEGIN_SRC clojure 
(declare eval-step) ;; we'll define this later

(defn eval
  ([{:keys [max-steps before-step]} env]
   (let [eval-step (if before-step
                     (comp eval-step before-step)
                     eval-step)]
     (loop [{::keys [expression] :as env} env
            step-count 0]
       (if (or (not (seq expression)) ;; nothing left to run
               (and max-steps (>= step-count max-steps)))
         env
         (recur (eval-step env) (inc step-count))))))
  ([env]
   (eval {} env)))

#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

We'll include handling for calling down into the platform language
directly. There will be syntax for calling clojure functions and java
methods as if they are kcats words.

We'll also specify here what a step of evaluation is - it looks at the
next item in the expression. If it has a definition, it's replaced
with its definition. Otherwise it's put onto the stack.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)
(require '[clojure.string :as string]
         '[clojure.edn :as edn])
;; Invocation requires several things:
;; * Indication that it's meant to be invoking platform functionality
;; * Stack effect (how many args consumed and produced)
;; * Platform function type (fn, constructor, instance, static, etc)
;;
;; 
;; + call clojure fn (drop all args and replace w return val)
;; * call java, drop passed in argument or return value
;; ! call java, keep passed in argument or return value
;; for java calls, the first char refers to the return value, 2nd is
;; the object, 3rd and beyond are arguments
;;
;; Regarding argument order: it's the order in which they were put on
;; the stack. last arg is at the top of stack.
;;
;; ++foo : clojure fn foo, consume 2 args, return 1 value (a b -> c)
;; !Bar. : Java no-arg construct Bar instance ( -> b)
;; !*Baz. : construct with one arg (a -> b)
;; **quux : call void instance method quux for side effect (a -> )
;; *!quux : call quux to mutate object (a -> a)
;; *!*quux : call quux to mutate object with arg (a b -> a)
;; !**quux ; call quux with arg, to get return value (a b -> c)
;; !*Foo/bar : call static bar on class Foo. (a -> b)
;; **Foo/blort : call static blort, side effect only (a ->)

(declare nil->nothing) 

(defn invoke*
  [{[word & others] ::expression
    ::keys [dictionary stack]
    :as env}]
  {::stack
   (let [[_ arity fn-name] (->> word
                                str
                                (re-find #"([\\+\\!\\*]*)(.*)\.?"))
         java? (not (.contains arity "+"))
         [args others] (split-at (cond-> (count arity)
                                   java? (dec)) ;; has an extra marker for return val
                                 stack)
         args (reverse args)] ;; due to stacking reversing the args previously
     (concat
      (nil->nothing
       (cond
         (not (seq arity)) [word] ;; just a regular word

         (or (.contains arity "!")
             (.contains arity "*")) ;; java call
         (let [[ret-flag & arity] (seq arity)
               mutated-args (keep-indexed
                             (fn [i arg]
                               (when (= \! (nth arity i))
                                 arg))
                             args)
               ret (cond
                     (.endsWith fn-name ".") ;; java constructor
                     (clojure.lang.Reflector/invokeConstructor
                      (Class/forName (->> fn-name
                                          count
                                          dec
                                          (subs fn-name 0)))
                      (into-array Object args))

                     (.contains fn-name "/") ;; static method
                     (let [[clazz method] (string/split fn-name #"/")]
                       (->> args
                            (into-array Object)
                            (clojure.lang.Reflector/invokeStaticMethod clazz method)))

                     :else (->> args ;; instance method
                                rest
                                (into-array Object)
                                (clojure.lang.Reflector/invokeInstanceMethod
                                 (first args)
                                 fn-name)))]
           (cond-> mutated-args
             (= ret-flag \!) ;; keep the return value
             (conj ret)))

         ;; clojure function
         (some-> fn-name symbol resolve) (-> fn-name
                                             symbol
                                             resolve
                                             (apply args)
                                             vector)
         :else (throw (Exception. (str "Cannot resolve platform word: " word)))))
      others))
   ::expression others
   ::dictionary dictionary})

(defn onto-stack
  "Move one item from the expression to the stack. "
  [{[item & others] ::expression ::keys [dictionary stack] :as env}]
  (if (symbol? item)
    (let [{f ::fn spec ::spec} (dictionary item)]
      (when spec
        (spec/assert spec stack))
      (if f
        (f (update env ::expression rest)) ;; drop this word now that we've used it
        (invoke* env)))
    (-> env
      (assoc ::expression others)
      (update ::stack conj item))))

(defn definition
  "Returns the definition of an item, if it's a word defined in terms
  of other words"
  [{::keys [dictionary] :as env} item]
  (some-> dictionary (get item) ::definition))

(declare repr)

(defn eval-step
  "Evaluate one step in the environment."
  [{[next-item & items :as expression] ::expression ::keys [stack dictionary] :as env}]
  (try
    (if-let [d (definition env next-item)]
      (assoc env ::expression (concat (list* d) items)) ;; replace item with definition
      
      ;; eval the thing onto the stack
      (onto-stack env))
    (catch Exception e
      (throw (ex-info (str "Error during evaluation of " (repr next-item))
                      {:environment (dissoc env ::dictionary)}
                      e)))))
 
(defn step-over
  "Executes the next word in the expression completely, returning the
  environment."
  [{::keys [expression] :as env}]
  (let [depth (count expression)]
    (loop [{::keys [expression] :as env} env]
     (if (< (count expression) depth)
       env
       (recur (eval-step env))))))

#+END_SRC

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.

** Printing
Printing out (or serializing) kcats data is mostly just printing the
underlying clojure data structures, as-is. However we want to note the
difference between raw data and data that's been put into an optimized
structure for processing. A map (or mapping, dictionary etc) lets you
look up a value given a key. The raw data is just a list of key/value
pairs. Arranging it in a hashmap is a performance optimization. When
we print out data, it's the raw format we want. In kcats there's no
difference in raw data, between a list of pairs and a map. Under the
covers though, it may actually be a hashmap. 

We're going to define our representation of raw data that only uses
square brackets and words (in clojure, those are vectors and
symbols). Then we can just print out these representations and we have
our serialized data format.
#+begin_src clojure
(defn repr
  "The kcats canonical representation, in clojure data
  structures. Converts clojure maps to vectors, keywords to symbols."
  [x]
  (cond
    (map? x) (mapv (fn [[k v]] [(repr k) (repr v)]) x)
    (keyword? x) (-> x name symbol)
    (coll? x) (mapv repr x)
    :else x)) 

(defn print-env
  "Prints the expression/stack and then return env"
  [{::keys [expression stack] :as env}]
  (apply clojure.core/pr (reverse (repr expression)))
  (print " . ")
  (apply clojure.core/prn (repr stack))
  env)

#+end_src
** Concept of nothing/nil/null
Kcats is not going to have a concept of =null= or =nil=. If we want to
express "nothing" we will use an empty list =[]=. We'll need some functions
to treat empty lists as clojure treats =nil=.

#+begin_src clojure
(def nothing [])

(def nothing? (partial = nothing))

(defn nothing->nil
  "Returns argument unless it's a kcats 'nothing' (empty list), in
  which case it returns nil"
  [x]
  (if (nothing? x)
    nil
    x))

(defn nil->nothing
  "Returns argument unless it's nil, in which case it returns empty list"
  [x]
  (if (nil? x)
    nothing
    x))
#+end_src
** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(defn f-stack
  "Apply nitems from stack to f, put result back on stack after
   dropping nitems-drop."
  ([nitems-use nitems-drop f]
   (fn [env]
     (update env ::stack
             (fn [stack]
               (let [use (take nitems-use stack)
                     stack (drop nitems-drop stack)]
                 ;; items are reversed so that we can write code with arguments in
                 ;; the same order as we'd use in other langs, eg so that [2 1 >]
                 ;; -> true
                 ;;
                 ;; The top item in the stack would normally be the first
                 ;; arg, but that was the LAST arg written in the code.
                 (conj stack (apply f (reverse use))))))))
  ([nitems f]
   (f-stack nitems nitems f)))

(defn env-effect
  "Calls f with nitems from stack, it should return a pair (items to
  prepend to the expression, items to replace the nitems with)"
  [nitems f]
  (fn [{::keys [stack expression dictionary]}]
    (let [[a b] (split-at nitems stack)
          [new-expression-items new-stack-items] (apply f a)]
          {::stack (into b (reverse new-stack-items))
           ::expression (into expression (reverse new-expression-items))
           ::dictionary dictionary})))

(defmacro effect
  "Constructs a fn with given in args, whose body is out. That
  function body should return a pair (new-expression-items,
  new-stack-items)"
  [in out]
  `(env-effect ~(count in) (fn ~in ~out)))

(defmacro stack-effect
  "Takes a stack effect notation and turns it into a call to
  env-effect"
  [in out]
  `(env-effect ~(count in) (fn ~in [[] ~out])))
#+END_SRC

Now we can go ahead and start filling out axiom words in our default
dictionary.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)
(require '[clojure.java.io :as io])
(import [java.io ByteArrayOutputStream])

;; some state to hold our core words, so we can build them up a chunk
;; at a time.
(defonce core-words (atom {}))

;; math symbols are ok - non-programmers already know what they mean
(def arithmetic-words
  (into {} cat
        [(for [sym ['+ '- '/ '* '< '<= '> '>= 'min 'max 'quot 'rem 'mod]]
           [sym
            {::spec (stack-spec :x ::number
                                :y ::number)
             ::fn (f-stack 2 (resolve sym))}])
         (for [sym ['inc 'dec]]
           [sym
            {::spec (stack-spec :x ::number)
             ::fn (f-stack 1 (resolve sym))}])]))

;; need to implement `some` to respect empty list being falsey
(def predicates
  (into {} cat
        [(for [sym ['odd? 'even? 'sequential? 'zero? 'pos? 'neg?
                    'number? 'int? 'true? 'false?
                    'string? 'empty?]]
           [sym {::spec (stack-spec :x ::item)
                 ::fn (f-stack 1 (resolve sym))}])
         (for [sym ['starts-with? 'ends-with?]]
           [sym {::spec (stack-spec :subject ::item
                                    :object ::item)
                 ::fn (f-stack 2 (resolve sym))}])]))

(def axiom-words
  {'discard {::spec (stack-spec :a ::item)
             ::fn (stack-effect [a] [])
             ::examples '[[[1 2 3 discard] [2 1]]
                          [[1 2 3 [a b c] discard] [3 2 1]]]}
   'clone {::spec (stack-spec :a ::item)
           ::fn (stack-effect [a] [a a])
           ::examples '[[[1 2 3 clone] [3 3 2 1]]]}
   'swap {::spec (stack-spec :a ::item, :b ::item)
          ::fn (stack-effect [a b] [b a])
          ::examples '[[[1 2 3 swap] [2 3 1]]]}
   ;; TODO: this is just [swap] dip. worth having its own word?
   'swapdown {::spec (stack-spec :a ::item, :b ::item, :c ::item)
              ::fn (stack-effect [a b c] [a c b])
              ::examples '[[[1 2 3 swapdown] [3 1 2]]]}
   'float {::spec (stack-spec :a ::item, :b ::item, :c ::item)
           ::fn (stack-effect [a b c] [c a b])
           ::examples '[[[1 2 3 float] [1 3 2]]]}
   'sink {::spec (stack-spec :a ::item, :b ::item, :c ::item)
          ::fn (stack-effect [a b c] [b c a])
          ::examples '[[[1 2 3 sink] [2 1 3]]]}
   'execute {::spec (stack-spec :p ::program)
             ::fn (effect [p] [p []])
             ::examples '[[[[1 2 +] execute] [3]]
                          [[2 [+] 4 swap execute] [6]]]}
   'wrap {::spec (stack-spec :a ::item)
          ::fn (stack-effect [a] [[a]])
          ::examples '[[[1 wrap] [[1]]]
                       [[[1 2] wrap] [[[1 2]]]]]}
   ;; TODO: possible security issue with unwrap and bare words on the
   ;; stack: It's possible for malicious code to squat on a word that
   ;; was intended to be data, and not an action word, causing
   ;; unexpected behavior. May want to reconsider whether undefined
   ;; words should be placed onto the stack unquoted.
   'unwrap {::spec (stack-spec :l ::list)
            ::pre '[list?]
            ::post [true] ;; can be anything
            ::fn (stack-effect [l] l)
            ::examples '[[[[1] unwrap] [1]]]}
   'rest {::spec (stack-spec :l ::list)
          ::pre '[list?]
          ::post '[list?]
          ::fn (stack-effect [l] [(vec (rest l))])
          ::examples '[[[[1 2 3] rest] [[2 3]]]]}
   'fail {::spec (stack-spec :s ::string)
          ::fn (stack-effect [s] (throw (Exception. s)))}
   'dip {::spec (stack-spec :p ::program
                            :a ::item)
         ::pre '[list?]
         ::fn (effect [p a] [(conj (vec p) [a] 'unwrap) []])
         ::examples '[[[1 8 [inc] dip] [8 2]]
                      [[1 2 [dec] unwrap
                        [+] dip] [dec 3]]]}
   'list? {::spec (stack-spec :a ::item)
           ::fn (stack-effect [a] [(vector? a)])
           ::examples '[[[[1] list?] [true]]
                        [[[] list?] [true]]
                        [[5 list?] [false]]]}
   'number? {::spec (stack-spec :a ::item)
             ::fn (stack-effect [a] [(number? a)])
             ::examples '[[[[1] number?] [false]]
                          [[[] number?] [false]]
                          [[5 number?] [true]]
                          [[5.01 number?] [true]]]}
   'string {::spec (stack-spec :a ::item)
            ::fn (stack-effect [a] [(str a)])
            ::examples '[[[1 string] ["1"]]
                         [[[1 2 3] string] ["[1 2 3]"]]
                         [[[] string] ["[]"]]]}
   'read {::spec (stack-spec :s ::string)
          ::fn (stack-effect [s] [(edn/read-string s)])
          ::examples '[[["[1 [2] 3]" read] [[1 [2] 3]]]]}
   ;; maybe this should be something like
   ;; timesfive [[definition [5 *]] [examples [...]]] inscribe
   'inscribe {::spec (stack-spec :definition ::program
                                 :word ::word)
              ::fn (fn [{[word-def word & others] ::stack
                         ::keys [expression dictionary]}]
                     {::stack others
                      ::expression expression
                      ::dictionary (assoc dictionary word
                                          (into {}
                                                (for [[k v] word-def]
                                                  [({'definition ::definition
                                                     'examples ::examples
                                                     'spec ::spec} k)
                                                   (cond-> v
                                                     (= k 'spec) build-spec)])))})
              ::examples '[[[[add3] unwrap [[definition [3 +]]
                                            [spec [[number integer]]]]
                             inscribe
                             5 add3] [8]]]}
   'describe {::spec (stack-spec :word ::word)
              ::fn (fn [{[word & others] ::stack dict ::dictionary :as env}]
                     (let [dfn (-> dict (get word) ::definition)]
                       (if dfn
                         (assoc env ::stack (conj others dfn))
                         nothing)))}
   'branch {::spec (stack-spec :false-branch ::program
                               :true-branch ::program
                               :condition ::item)
            ::fn (effect [f t b]
                         [(if (nothing->nil b) t f) []])
            ::examples '[[[5 true [3 *] [4 +] branch] [15]]
                         [[6 false [3 *] [4 +] branch] [10]]]}
   'step {::spec (stack-spec :p ::program
                             :a ::list)
          ::fn (effect [p [agg-item & agg-rest :as agg]]
                       (if (seq agg)
                         [(cond-> ['execute]
                            (seq agg-rest) (concat [(vec agg-rest) p 'step]))
                          [p agg-item]]
                         [[] []]))
          ::examples '[[[1 [2 3 4] [*] step] [24]]
                       [[1 [] [*] step] [1]]]}
   'recur {::spec (stack-spec :rec2 ::program
                              :rec1 ::program
                              :true-branch ::program
                              :false-branch ::program)
           ::fn (effect [rec2 rec1 then pred]
                        ['[if]
                         [(vec (concat rec1 [[pred then rec1 rec2 'recur]] rec2))
                          then pred]])
           ::examples '[[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}
   'loop {::spec (stack-spec :p ::program
                             :flag ::item)
          ::fn (effect [p f]
                       [(when (nothing->nil f)
                          (concat p [p 'loop]))
                        []])
          ::examples '[[[10 true [-2 * clone 50 <] loop] [160]]]}
   'pack {::spec (stack-spec :x ::item
                             :l ::list)
          #_::fn #_(stack-effect [x l] [(conj (vec l) x)])
          ::definition '[[[[swap bytes?]
                           [[!java.io.ByteArrayOutputStream.] dipdown 
                            [*!*write] dip ;; the list into the stream
                            *!*write ;; the item into the stream
                            !*toByteArray]]

                          [[swap string?]
                           [!*java.lang.String/valueOf !**concat]]                            

                          [[true] [[+vec] dip ++conj]]]
                         decide]
          ::examples '[[[[] 1 pack] [[1]]]
                       [[[1 2 3] 4 pack] [[1 2 3 4]]]
                       [["foo" \d pack] ["food"]]
                       [["foo" bytes 32 pack !*java.lang.String.] ["foo "]]]}
   'unpack {::spec (stack-spec :l ::list)
            ::fn (stack-effect [[l & others]] [(nil->nothing l) (vec others)])
            ::examples '[[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}
   'join {::spec (stack-spec :a ::item
                             :b ::item)
          ::fn (stack-effect [a b]
                             (if (and (string? a) (string? b))
                               [(str b a)]
                               [(vec (concat b a))]))
          ::examples '[[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}
   'range {::spec (stack-spec :from ::integer
                              :to ::integer)
           ::fn (f-stack 2 (comp vec range))
           ::examples '[[[1 5 range] [[1 2 3 4]]]]}
   'evert {::spec (stack-spec :l ::list)
           ::doc "Turns the list on top of the stack inside out (puts
                  the list as the rest of the stack, and vice versa)"
           ::fn (fn [{[l & others] ::stack ::keys [dictionary expression]}]
                  {::stack (apply list (vec others) l)
                   ::expression expression
                   ::dictionary dictionary})
           ::examples '[[[1 2 3 [4 5 6] evert] [[3 2 1] 4 5 6]]]}
   'some? {::spec (stack-spec :a ::item)
           ::fn (f-stack 1 (comp some? nothing->nil))}
   'every? {::spec (stack-spec :p ::program
                               :l ::list)
            ::definition '[ ;; build the r1
                           [shielddown] swap prepend ;; run pred with unary
                           [unpack swap] swap pack ;; add rest of dip program
                           [dip swap not] join ;; add the rest of outer dip
                           wrap [dip or] join ;; add rest of r1
                           ;; put the other recur clauses under r1
                           [false
                            [[[nothing?] shield] dip
                             swap [or] shielddown] ;; the 'if' 
                            [not]] ;; then
                           dip ;; underneath the r1
                           [execute] recur ;; r2 and recur!
                           swap discard] ;; drop leftover list
            ::examples '[[[[2 4 6] [even?] every?] [true]]
                         [[[2 4 5] [even?] every?] [false]]
                         [[[] [even?] every?] [true]]
                         [[[2 4 6] [] every?] [true]]
                         [[11 [2 4 6] [+ odd?] every?] [true 11]]
                         [[12 [[even?] [pos?] [3 rem 0 =]] [execute] every?] [true 12]]]} 
   'any? {::spec (stack-spec :p ::program
                             :l ::list)
          ::definition '[;; build the r1
                         [shielddown] swap prepend ;; run pred with unary
                         [unpack swap] swap pack ;; add rest of dip program
                         [dip swap] join ;; add the rest of outer dip
                         wrap [dip or] join ;; add rest of r1
                         ;; put the other recur clauses under r1
                         [false
                          [[[nothing?] shield] dip
                           swap [or] shielddown] ;; the 'if' 
                          []] ;; then
                         dip ;; underneath the r1
                         [execute] recur ;; r2 and recur!
                         swap discard]
          ::examples '[[[[2 4 6] [even?] any?] [true]]
                       [[[3 5 7] [even?] any?] [false]]
                       [[[] [even?] any?] [false]]
                       [[[2 4 6] [] any?] [true]]
                       [[11 [3 5 6] [+ odd?] any?] [true 11]]
                       [[-15 [[even?] [pos?] [3 rem 0 =]] [execute] any?] [true -15]]]}
   'and {::spec (stack-spec :a ::item
                            :b ::item)
         ::fn (f-stack 2 (fn [a b]
                           (and (nothing->nil a)
                                (nothing->nil b))))
         ::examples '[[[1 odd? 2 even? and] [true]]]}
   'or {::spec (stack-spec :a ::item
                           :b ::item)
        ::fn (f-stack 2 (fn [a b]
                          (or (nothing->nil a)
                              (nothing->nil b))))
        ::examples '[[[1 odd? 3 even? or] [true]]]}
   'not {::spec (stack-spec :a ::item)
         ::fn (f-stack 1 (fn [a]
                           (not (nothing->nil a))))
         ::examples '[[[1 even? not] [true]]]}
   'lexicon {::spec (stack-spec)
             ::fn (fn [{::keys [stack expression dictionary]}]
                    ;; read in the standard library aka lexicon
                    {::stack (list (-> "src/kcats/lexicon.kcats"
                                       io/file
                                       io/reader
                                       java.io.PushbackReader.
                                       edn/read))
                     ;; step through the word alist and inscribe each one
                     ::expression (concat '([unwrap swap inscribe] step) expression)
                     ;; keep the base dictionary intact
                     ::dictionary dictionary})}})

(swap! core-words merge
       axiom-words
       arithmetic-words
       predicates)

(defn default-env
  ([expression]
   {::stack '()
    ::dictionary @core-words
    ::expression expression})
  ([]
   (default-env '(lexicon))))

(defn k
  "Run a program with the default env and return the result. Option to
  stop execution after `max-steps` if still unfinished, to prevent
  accidental infinite loops (for debugging purposes)"
  ([opts p]
   (repr (::stack (eval opts (update (default-env)
                                    ::expression
                                    concat p)))))
  ([p] (k {:before-step print-env} p)))

#+END_SRC

Next we can add a way to test that all the examples are working, so
that we notice any bugs as we're developing.

#+begin_src clojure
(in-ns 'kcats.core)
(require '[clojure.test :as test])
(defn test
  "Run through all the examples in the default env and make sure they
  work. Takes optional list of words to test"
  ([words]
   (doseq [[word {::keys [examples]}] (if words
                                        (select-keys @core-words words)
                                        @core-words)]
     (test/testing (str word)
       (doseq [[program exp-stack] examples]
         (->> program
              (k {:max-steps 2500})
              repr
              (= exp-stack)
              test/is)))))
  ([] (test nil)))
#+end_src

Now that we have a lot of axiom words, we can define more words as a
standard library, in native kcats. It will be an association list
(which we'll define later 

#+begin_src clojure :tangle src/kcats/lexicon.kcats
[[shield [[spec [[p program]]]
          [[doc "Runs program keeping top of stack produced but protects existing items from being consumed."]]
          [definition [[snapshot] dip inject first]]
          [examples [[[1 2 3 [=] shield] [false 3 2 1]]]]]]

 [shielddown [[spec [[p program]]]
              [definition [shield swap discard]]]]

 [shielddowndown [[spec [[p program]]]
                  [definition [shield [discard discard] dip]]]]

 [if [[spec [[false-branch program]
             [true-branch program]
             [condition program]]]
      [definition [[shield] dipdown branch]]
      [examples [[[5 [5 =] [3 *] [4 +] if] [15]]
                 [[6 [5 =] [3 *] [4 +] if] [10]]]]]]

 [dipdown [[spec [[p program]
                  [a item]
                  [b item]]]
           [definition [wrap [dip] join dip]]
           [examples [[[1 2 3 [inc] dipdown] [3 2 2]]]]]]

 [primrec [[spec [[rec1 program]
                  [exit program]
                  [data number]]]
           [definition [[execute] swap join ;; add execute to rec1 to be recurs rec2
                        [[discard] swap join] dip ;; add discard to exit condition
                        [[clone zero?]] dipdown  ;; put the condition on bottom
                        [[clone dec]] dip ;; add the r1
                        recur]] ;; now its generic recur
           [examples [[[5 [1] [*] primrec] [120]]]]]]

 [= [[spec [[ x item], [y item]]]
     [definition [++=]]
     [examples [[[1 1 =] [true]]
                [["hi" "hi" =] [true]]
                [["hi" "there" =] [false]]
                [[[] false =] [false]]
                [[1 "hi" "hi" =] [true 1]]]]]]

 [count [[spec [[l list]]]
         [definition [+count]]
         [examples [[[["a" "b" "c"] count] [3]]]]]]

 [prepend [[spec [[a item]
                  [l list]]]
           [definition [wrap swap join]]
           [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]]

 [assert [[spec [[p program]]]
          [definition [snapshot ;; save stack to print in err message
                       [shield] dip swap ;; run the assertion under the saved stack
                       [discard] ;; if passes, drop the saved stack, dont need
                       [string ["assertion failed "] dip join fail] ;; else throw err
                       branch]]]]

 [inject [[spec [[p program]
                 [l list]]]
          [doc "Inject the quoted program into the list below
                   it (runs the program with the list as its
                   stack).  Does not affect the rest of the stack."]
          [definition [swap evert unpack dip evert]]
          [examples [[[1 2 3 [4 5 6] [* +] inject] [[26] 3 2 1]]]]]]

 [snapshot [[spec []]
            [doc "Save the whole stack as a list on the stack"]
            [definition [[] evert clone evert unwrap]]
            [examples [[[1 2 3 snapshot] [[3 2 1] 3 2 1]]
                       [[snapshot] [[]]]]]]]

 [first [[spec [[l list]]]
         [definition [+first +nil->nothing]]
         [examples [[[[4 5 6] first] [4]]]]]]

 [second [[spec [[l list]]]
          [definition [+second]]
          [examples [[[[4 5 6] second] [5]]]]]]

 [bytes? [[spec [[a item]]]
          [definition [+bytes?]]]]

 [string? [[spec [[a item]]]
           [definition [+string?]]]]

 [bytes [[spec [[a item]]]
         [definition [[[[clone string?] [!*getBytes]]
                       [[clone bytes?] []]]
                      decide]]]]

 [map [[spec [[p program]
              [l list]]]
       [definition [[snapshot [] swap] ;; save original stack, and
                    ;; add an empty list to
                    ;; hold results
                    dipdown ;; do this underneath the program and list
                    [wrap swap clone rotate] ;; program snippet a to
                    ;; copy the original stack
                    ;; that we saved, will make
                    ;; new copy for each item
                    ;; in the list

                    swap pack ;; pack the map program into the
                    ;; partial program a above

                    ;; inject the map program into the stack copy,
                    ;; take the first item and pack it into the
                    ;; result list. the join here is to literally
                    ;; add the list item to the stack copy,
                    ;; without actually executing it, in case its
                    ;; a bare word
                    [[swap join] dip inject first swap [pack] dip]
                    join ;; add the program snippet b above to the
                    ;; snippet a, to get a program for step
                    step ;; step through the above program, using
                    ;; the list as data
                    discard ;; we dont need the copy of the
                    ;; original stack anymore
                    ]]
       [examples [[[[1 2 3] [inc] map] [[2 3 4]]]
                  [[1 [1 2 3] [+] map] [[2 3 4] 1]]
                  [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]]
                  [[7 9 [+] [] map] [[+] 9 7]]]]]]

 [filter [[spec [[p program]
                 [l list]]]
          [definition [[snapshot [] swap]
                       dipdown
                       ;; clone the original value so we can save it in results if needed
                       [[clone] dip clone wrap swapdown]
                       swap pack
                       [join inject first
                        ;; if passes filter, pack it into results
                        [[pack]]
                        ;; othewise discard it
                        [[discard]]
                        branch
                        swapdown
                        dip]
                       join step discard]]]]

 [nothing? [[spec [[a item]]]
            [definition [[] =]]]]

 [something? [[spec [[a item]]]
              [definition [nothing? not]]]]

 [while [[spec [[body program]
                [pred program]]]
         [definition [swap wrap [shield] join ;; add shield to the pred program
                      clone dipdown ;; run it on the previous ToS
                      join loop]]
         [examples [[[3 [0 >] [clone dec] while] [0 1 2 3]]]]]]]
#+end_src

** Logical operators
** Maps/associations
A simple implementation that works well for small lists: specify
associations as lists of pairs.

Then include some words that depend on this functionality.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(expound/def ::pair (spec/coll-of ::item :kind vector? :count 2))

(expound/def ::association-list (spec/or :map map?
                                         :pairs (spec/coll-of ::pair
                                                              :kind vector?)))
(defn lookup
  [alist k]
  (let [m? (map? alist)]
    (get (if m?
           alist
           (into {} alist))
         (cond-> k
           (and m? (symbol? k)) (->> name (keyword "kcats.core")))
         [])))

(defn assoc-in
  "Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created."
  {:added "1.0"
   :static true}
  [m [k & ks] v]
  (let [m (into {} m)]
    (if ks
      (assoc m k (assoc-in (get m k) ks v))
      (assoc m k v))))

;;TODO: axiom words should be separated
(def associative-words
  {'associative? {::spec (stack-spec :item ::item)
                  ::fn (stack-effect [x] [(spec/valid? ::association-list x)])}
   'assign {::spec (stack-spec :value ::item
                               :keylist ::list,
                               :alist ::association-list)
            ::fn (f-stack 3 #'assoc-in)
            ::examples '[[[[[a b] [c d]] [a] 5 assign] #_-> [[[a 5] [c d]]]]
                         [[[[a b] [c d]] [e] 5 assign] #_-> [[[a b] [c d] [e 5]]]]
                         [[[[a b] [c [[d e]]]] [c d] 5 assign] #_-> [[[a b] [c [[d 5]]]]]]]}
   'update {::spec (stack-spec :program ::program
                               :keylist ::list
                               :alist ::association-list)
            ::definition '[[[lookup] shield] dip ;; m ks v p
                           shielddown
                           assign]
            ::examples '[[[[[a 1] [b 2]] [b] [inc] update]
                          [[[a 1] [b 3]]]]

                         [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update]
                          [[[a [[c 4] [d 5]]] [b 2]]]]

                         [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update]
                          [[[a [[c 15] [d 5]]] [b 2]]]]

                         [[[[a 1] [b 2]] [d] [5] update]
                          [[[a 1] [b 2] [d 5]]]]

                         [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update]
                          [[[a [[c 3] [d 5] [e 11]]] [b 2]]]]
                         ]}
   'lookup {::spec (stack-spec :keylist ::list
                               :map ::association-list)
            #_::fn #_(f-stack 2 (fn [alist ks]
                                  (get-in (into {} alist) ks []))) ;; TODO this doesn't work on nested alists
            ::definition '[[[[swap associative?] ;; it's a map
                             [swap something?] ;; it's not empty
                             [something?]] ;; the keylist is not empty
                            [execute]
                            every?]
                           [unpack swap [++lookup] dip] ;; extract the first key and lookup
                           while

                           [something?]
                           ;; fail if we could not drill down all the way
                           ["Lookup attempted on non associative value" fail]
                           [discard]  ;; get rid of remaining keylist
                           if]
            ::examples '[[[[[a b] [c d]] [a] lookup] [b]]
                         [[[[a b] [c d]] [e] lookup] [[]]]
                         [[[[outer [[a b] [c d]]]] [outer c] lookup] [d]]]}
   ;; another example
   #_(k {:max-steps 1500}
        '[[[outer [[a b] [c d]]]] [outer c]
          [[[swap associative?]
            [swap something?]
            [something?]]
           every?]
          [unpack swap [+**lookup] dip]
          while])
   'unassign {::spec (stack-spec :key ::item
                                 :map ::association-list)
              ::fn (f-stack 2 (fn [alist key]
                                (vec (remove #(-> % first (= key)) alist))))
              ::examples '[[[[[a b] [c d]] a unassign] [[[c d]]]]
                           [[[[a b] [c d]] e unassign] [[[a b] [c d]]]]]}
   'decide {::spec (stack-spec :test-expr-pairs ::association-list
                               :other (spec/* ::item))
            ::doc "Takes a list of choices (pairs of test, program) and
            executes the first program whose test passes. if none
            pass, returns 'nothing'. Stack is reset between
            testing conditions."
            ::fn (fn [{[[[test expr :as first-clause]
                         & other-clauses]
                        & others] ::stack
                       ::keys [dictionary expression]}]
                   {::expression (if first-clause
                                   (concat [[test 'shield] ;; run test resetting stack
                                            expr ;; the then
                                            [(vec other-clauses) 'decide] ;; the else
                                            'if]
                                           expression)
                                   expression)
                    ::stack (cond-> others
                              ;; if conditions are empty result is empty list
                              (not first-clause) (conj []))
                    ::dictionary dictionary})
            ::examples '[[[5 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]
                              [[true] ["something else"]]]
                           decide]
                          ["five" 5]]
                         [[9 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]
                              [[true] ["something else"]]]
                           decide]
                          ["something else" 9]]
                         [[9 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]]
                           decide]
                          [[] 9]]]}
   'type {::spec (stack-spec :alist ::association-list)
          ::definition '[[clone count 1 =] ;; if it's a single item
                         [first first] ;; the type is the key of that first item
                         [[type] lookup] ;; otherwise look up the key 'type'
                         if]
          ::examples '[[[[[foo 1]] type] [foo]]
                       [[[[type url] [value "http://foo.com"]] type] [url]]]}
   'value {::spec (stack-spec :alist ::association-list)
           ::definition '[[clone count 1 =]
                          [first second]
                          [[value] lookup]
                          if]
           ::examples '[[[[[foo 1]] value] [1]]
                        
                        [[[[type url] [value "http://foo.com"]] value]
                         ["http://foo.com"]]]}
   'zip {::spec (stack-spec :values ::list
                            :keys ::list) ;; assumes equal length lists
         ::definition '[[[]] dipdown ;; add empty result below ToS
                        [[unpack wrap] ;; unpack the next key, wrap it
                                       ;; to make a "pair" (adding
                                       ;; value later)
                         dip ;; run that underneath the current value
                         pack ;; the value into the "pair" we created earlier
                         swap [pack] dip] ;; add the new pair to the results
                        step ;; step through all the values
                        discard ;; the now-empty list of keys
                        ]}})

(swap! core-words merge associative-words)
#+END_SRC
** Methods
#+begin_src clojure
(swap! core-words merge
       {'addmethod {::spec (stack-spec :condition ::pair
                                       :word ::word)
                    ::definition '[[clone describe] dip ;; get definition of word beneath
                                        ; and keep an extra copy for later inscribe
                                   pack ;; new condition onto end of definition
                                   [rotate ;; new condition to 1st
                                           ;; position - TODO: note this
                                           ;; could fail if the def is
                                           ;; more than just an alist
                                           ;; and 'decide'.
                                    pack] ;; new condition onto end of conditions
                                   inject ;; the above program to run on the conditions
                                   swap inscribe ;; redefine word
                                   ]}})
#+end_src

** Programmable Runtime
*** Basics
In kcats, the interpreter is a pure function of the environment data
it's given (with some caveats). That environment data is representable
as kcats data structures. That means that the kcats interpreter can
take that environment data from anywhere, and do whatever arbitrary
operations on it, including stepping through the execution of the
environment and producing more environment values. In other words,
kcats is its own debugger. I'm not sure if any other languages
implement this feature, certainly it should be straightforward to do
in many stack-based languages. For those familiar with lisp, you know
that you can use lisp to manipulate lisp code at compile time. In
kcats, you similarly have the power to manipulate code before it is
executed. In addition you have the power to manipulate *how* the code
is executed.

Of course, most real programs are not purely functional (they refer to
files on disk or network locations). So that must be taken into
account as always.

What we'll implement here is nested environments - where the outer
environment's stack contains data for an inner environment. The outer
environment can then use words like =eval-step= to step through the
execution of the inner environment, or do whatever other arbitrary
operations on it.
*** Implementation
First let's spec what a nested environment looks like
#+begin_src clojure
(in-ns 'kcats.core)
(declare env->clj env->internal)

(expound/def ::nested-environment
  #(->> % env->internal (spec/valid? ::environment)))
#+end_src

We'll need to be able to move back and forth between clojure's idea of
an environment and the equivalent representation in kcats. Even though
it's quite inefficient, for this first implementation, we'll convert a
kcats-format environment to clojure form (converting association lists
to clojure maps, etc), evaluate, then convert back afterward. This
allows maximum flexibility to treat a nested environment just like any
other piece of data.

Note that the =core-words= aren't representable in kcats (they're
defined in terms of the base language). That's not really a problem,
as we can make them available during evaluation by merging them in to
the environment's dictionary.

#+begin_src clojure
(in-ns 'kcats.core)

(defn env->clj
  "Convert an env from kcats format to clj"
  [e]
  (let [ec (into {} e)]
    {::stack (-> ec (get 'stack) list* (or '()))
     ::dictionary (merge core-words (into {}
                                          (for [[k v] (get ec 'dictionary)]
                                            [k {::definition v}])))
     ::expression (or (list* (get ec 'expression)) '())}))

(defn env->k
  "Convert an env from clj format to kcats"
  [e]
  [['stack (-> e ::stack vec)]
   ['dictionary (into {}
                      (for [[k {::keys [definition]}] (::dictionary e)
                            :when definition] ;; leave out core-words
                        [k definition]))]
   ['expression (-> e ::expression vec)]])

(defn env->internal
  [e]
  (cond-> e
    (not (map? e)) env->clj))
#+end_src

Now we can define an axiom word that steps through a nested
environment's execution.

#+begin_src clojure
(in-ns 'kcats.core)
(swap! core-words merge
       {'eval-step {::spec (stack-spec :environment ::nested-environment)
                    ::fn (f-stack 1 (comp env->internal eval-step))}
        'environment {::spec (stack-spec :expression ::list)
                      ::fn (f-stack 1 (comp default-env list*))}})
#+end_src

Now that we can step, and we have predicates, we can specify in kcats
itself when execution should stop, and just keep running until either
that condition is true or the execution is finished. For example:

#+begin_src clojure :tangle no
[[stack [1 2 3 4 5]]
 [expression [[+] step]]]
[clone [stack] lookup first 8 >] ;; ToS greater than 8
continue ;; step until above is true or all done
#+end_src

We can make some handy words to help.

#+begin_src clojure
(in-ns 'kcats.core)
(swap! core-words merge
       {'tos {::spec (stack-spec :environment ::nested-environment)
              ::definition '[[stack] lookup first]
              ::doc "top of stack"
              ::examples '[[[[[stack [1 2 3 4 5]]
                              [expression [[+] step]]]
                             tos]
                            [1]]]}
        'toe {::spec (stack-spec :environment ::nested-environment)
              ::definition '[[expression] lookup first]
              ::doc "top of expression"
              ::examples '[[[[[stack [1 2 3 4 5]]
                              [expression [[+] step]]]
                             toe]
                            [[+]]]]}})
#+end_src
*** Notes
TODO: the dictionary spec can be replaced with predicate programs,
that will be run with =shield= before the actual word and if it
returns false, will raise an error. Then this functionality can be
turned on optionally in the runtime, just as the debugger is
controlled.

Is it better to have data structures that match clojure or kcats? For
example, clojure idioms say that the environment should be a map with
namespaced keyword keys. But kcats would say it's a list of pairs with
words as keys. This matters in nested envs because each "step" of
execution needs to do something with this data. If it's pure clojure,
then it's easy for the runtime to manipulate but then the kcats user
doesn't know what it is. If it's kcats data, then the user will
recognize it but it will be inefficient for the clojure runtime to
work with.

One solution (and I am coming around to this approach) is to remain
clojure data structures all along but be able to convert it to kcats
format when leaving control of the runtime (for example when printing
out for a user, or being serialized over the wire). This is still
tricky though, eg if you have a clojure map with namespaced keys and a
kcats word key you want to look up, how do you know what namespace to
prepend to find it? Maybe this will always be obvious (probably
=kcats.core= since no kcats program could create a namespaced
keyword). This approach is already used somewhat in association
lists - clojure maps are valid on the stack as association lists.

another approach is to ditch clojure's idioms and just make the
internal data kcats data so that a kcats program can easily manipulate
it. The downside here is that clojure tooling doesn't like it (eg spec
only wants keywords as keys, not symbols) and it breaks the levels of
abstraction.
** Pipes
*** Basics
Pipes are a coordination construct - a way to get values from here to
there, when "there" is further away than a simple function call. In
that sense it "breaks" functional programming by introducing state,
but quite often real programs need to deal with state. That state
could just be something introduced by, and consumed by, the local
environment, or it could be received from another machine thousands of
miles away.

The interface is simple enough - we just need to be able to put values
into a pipe at one end, and take them off at the other. It's also
handy to know whether there's anything in the pipe or not, and whether
the pipe is "full" (nothing more will fit until something at the other
end is removed).

The program doesn't necessarily have access to both ends of the
pipe. For example, when sending data over a socket, the program has
access to the "in" end, but not the "out" (that's on a remote machine). 

#+begin_src clojure :tangle src/kcats/pipe.clj
(ns kcats.pipe
  (:require [kcats.core :as core]
            [clojure.spec.alpha :as spec]
            [expound.alpha :as expound])
  (:refer-clojure :exclude [take empty?])
  (:import [java.util.concurrent BlockingQueue ArrayBlockingQueue SynchronousQueue]
           [java.util Queue]))

(defprotocol Select
  (poll [pipe] "Returns a value if available, otherwise nil"))

(defprotocol In
  (put [pipe value] "Puts a value into the pipe, blocks if the pipe is full, returns value on success"))

(defprotocol Out
  (take [pipe] "Takes a value from the pipe, blocks if pipe is empty, returns the value"))

;; a protocol that just marks whether the pipe is generating values
;; itself. The reason to differentiate is that a self-contained pipe
;; can potentially be serialized and sent elsewhere without any loss
(defprotocol SelfContained)
#+end_src

Now we can make some higher level functions that will actually be what
kcats primitives will be defined in terms of.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(def default-sleep 10)

(defn select
  "Takes a coll of pipes. Whichever one is non-empty first, return the
  pipe and the value that was in it."
  [pipes]
  (loop [[this-pipe & remaining-pipes] pipes]
    (if this-pipe
      (if-let [item (poll this-pipe)]
        ;; found it, return the pipe and value as a tuple
        [this-pipe item]
        (recur remaining-pipes))
      ;; everything empty, start over
      (do (Thread/sleep default-sleep)
          (recur pipes)))))
#+end_src

Now we can define a few different kinds of pipes, starting with simple
"local" types.
*** Standard Values
Passes values from in to out - similar to core.async or golang
channels.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defn ->buffered [buffer-size]
  (ArrayBlockingQueue. buffer-size))

(defn ->filled [coll]
  (ArrayBlockingQueue. (count coll) false coll))
#+end_src
*** Atoms
This is a pipe that when you take, always returns the last value
put. It's never full, whatever you put just overwrites what was there
before. It has to be initialized with a value, therefore it's also
never empty. It's functionally equivalent to a clojure atom and is
implemented in terms of one.

Note =swap!= is missing. This maybe could be implemented as =[take]
dip shielddown put= (with the program on top, and the pipe
underneath) - but that is not the same as =swap!= because it lacks the
retry logic (if someone else changed the value while the update is
happening). To fix this, a kcats-native atom is probably
necessary. 

Might be able to get the same sort of functionality from a 2pipe/env
combo that you can send programs to: in-pipe takes programs that act
as swap! fns, out-pipe returns current value. But that is more of a
clojure ref than an atom. 

Another approach is to use clojure atoms but make the whole env be the
(clojure atom) value (only difference is that instead of a pipe on top
it's the pipe's value in its place). For kcats atom swap, run the env
with the program in the expression, with =shielddown=. The clojure
atom would then be properly updated. The kcats take, however would
need to just return ToS instead of the entire clojure atom value. The
problem with this is the =put= word doesn't usually care about the
whole env and would have to have a separate impl for atoms.

Thinking about tihs more, atoms should probably have a different
contract: puts take programs to run on the env (with pipe replaced with
the actual value). Takes return the value.

For example:
#+begin_src clojure :tangle no
;; swap! is done with a program that replaces previous ToS
;; note no stack items are consumed
10 6 atom [inc +] put .
=>  <Atom 17> 10

;; equivalent of reset! is to just put another value on top
10 6 atom [99] put .
=> <Atom 99> 10

#+end_src
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type clojure.lang.Atom
  In
  (put [a value] (reset! a value))
  Out
  (take [a] (deref a))
  Select
  (poll [a] (take a))
  SelfContained)

(defn ->atom
  "Creates a new atom pipe with initial value v"
  [v]
  (atom v))
#+end_src

*** Timeout
This is an (out) pipe that when you take, it will block for a
predefined period of time (decided when the pipe is created), and then
return the boolean value =true=.

The purpose of this kind of pipe is to use with =select= - where you
have a set of pipes and you want to take from whichever one is
non-empty first. You can include a timeout pipe in there to guarantee
that at least one of them will return something eventually.

#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(deftype Timeout [until-timestamp]
  Out
  (take [this] (let [t (- until-timestamp (System/currentTimeMillis))]
                 (when (pos? t)
                   (Thread/sleep t))
                 true))
  Select
  (poll [this] (or (> (System/currentTimeMillis) until-timestamp) nil)))

(defn ->timeout
  "Creates a new timeout pipe that waits t milliseconds and then
  returns a single value (true) from the pipe"
  [t]
  (->Timeout (+ (System/currentTimeMillis) t)))
#+end_src

*** Closing
Pipes need to be closed pretty often (eg there's no more bytes to be
read from a file, so we need to know when to stop waiting for more)
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defprotocol Close
  (close [pipe] "Closes the pipe from either end")
  (closed? [pipe] "Returns true if the pipe has been closed"))

;; Objects that don't implement the protocol can never be closed but
;; we can still ask if they're closed (it'll always be false)

(defn is-closed
  [obj]
  (and (instance? Close obj) (closed? obj)))

;; or we could also just add a dummy protocol impl to Object

(extend-type Object
  Close
  (close [obj])
  (closed? [obj] false))

;; Adds the ability to signal closed to java objects
;; that don't have a concept of "closed", like queues and
;; readers

(defn closer-out
  [closeable]
  (let [closed? (atom false)]
    (reify
      Close
      (close [this]
        (close closeable)
        (reset! closed? true))
      (closed? [this] @closed?)
      Out
      (take [this] (take closeable))
      Select
      (poll [this] (take this)))))

(defn closer-in
  [closeable]
  (let [closed? (atom false)]
    (reify
      Close
      (close [this]
        (close closeable)
        (reset! closed? true))
      (closed? [this] @closed?)
      In
      (put [this item] (put closeable item)))))

(defn closer-in-out
  [closeable]
  (let [closed? (atom false)]
    (reify
      Close
      (close [this]
        (close closeable)
        (reset! closed? true))
      (closed? [this] @closed?)
      In
      (put [this item] (put closeable item))
      Out
      (take [this] (take closeable))
      Select
      (poll [this] (take this)))))
#+end_src

We can now implement this on some pipe types
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)
;; some pipes are thin veneers on java concurrent objects

;; TODO: finish close impl
(extend-type BlockingQueue
  In
  (put [q value] (.put q value))
  Out
  (take [q] (.take q))
  Select
  (poll [q] (.poll q)))

(extend-type Queue
  Out
  (take [q] (.poll q))
  Select
  (poll [q] (take q))
  Close
  (close [q] nil)
  (closed? [q] (-> q .peek nil?)))

(defn ->handoff []
  (SynchronousQueue.))
#+end_src
*** Input/Output streams
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type java.io.InputStream
  Out
  (take [is]
    (let [buf (make-array Byte/TYPE 1024)
          bytes-read (.read is buf)]
      (if (= -1 bytes-read)
        (throw (Exception. "EOF on inputstream while reading"))
        (let [retbuf (make-array Byte/TYPE bytes-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [is] (take is))
  Close
  (close [is] (.close is))
  (closed? [is] (try (-> is .available (= 0))
                     (catch java.io.IOException ioe
                       true))))

(extend-type java.io.OutputStream
  In
  (put [os bs] (doto os (.write bs)))
  Close
  (close [os] (doto os (.flush) (.close)))
  (closed? [os] false))
#+end_src

*** Reader/Writers
Unfortunately java Readers (or Readables) don't have any mechanism to
check whether the EOF has been reached without actually doing a
read. So there's no direct way to implement =closed?= without keeping
some extra state, namely of what the status of the last read was. If
it returned -1, then we know EOF has been reached.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

;; Since java Readables can't be queried for closed stream (read just
;; returns -1 but it doesn't keep track of that previous state itself),
;; we'll wrap it in a record that adds a boolean for that state.
(defrecord Reader [rdr closed?]
  Out
  (take [{:keys [rdr closed?]}]
    (let [buf (java.nio.CharBuffer/allocate 1024)
          chars-read (.read rdr buf)]
      (if (= -1 chars-read)
        (do (reset! closed? true)
            (make-array Byte/TYPE 0))
        (let [retbuf (make-array Byte/TYPE chars-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [this] (take this))
  Close
  (close [{:keys [rdr closed?]}]
    (.close rdr)
    (reset! closed? true))
  (closed? [{:keys [closed?]}] @closed?))

(defn make-reader
  [rdr]
  (->Reader rdr (atom false)))

(extend-type Readable
  Out
  (take [rdr]
    (let [buf (java.nio.CharBuffer/allocate 1024)
          chars-read (.read rdr buf)]
      (if (= -1 chars-read)
        (throw (Exception. "EOF on reader while reading"))
        (let [retbuf (make-array Byte/TYPE chars-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [is] (take is))
  Close
  (close [is])
  (closed? [is] (try (-> is .available (= 0))
                     (catch java.io.IOException ioe
                       true))))

#+end_src

*** Words
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(expound/def ::in (partial satisfies? In))
(expound/def ::out (partial satisfies? Out))
(expound/def ::core/pipe (spec/or :in ::in
                                  :out ::out))

(swap! core/core-words merge
       {'atom {::core/spec (core/stack-spec :value ::core/item)
               ::core/fn (core/stack-effect [v] [(->atom v)])}
        'buffer {::core/spec (core/stack-spec :buffer-size ::core/integer)
                 ::core/fn (core/stack-effect [s] [(->buffered s)])}
        'timeout {::core/spec (core/stack-spec :timeout-ms ::core/integer)
                 ::core/fn (core/stack-effect [t] [(->timeout t)])}
        'handoff {::core/spec (core/stack-spec)
                  ::core/fn (core/stack-effect [] [(->handoff)])} 
        'select {::core/spec (core/stack-spec :pipes (spec/coll-of ::out))
                 ::core/fn (core/stack-effect [pipes]
                                              (let [[p v] (select pipes)]
                                                [v p pipes]))}
        'take {::core/spec (core/stack-spec :pipe ::out)
               ::core/fn (core/stack-effect [p] [(take p) p])}
        'put {::core/spec (core/stack-spec :value ::core/item
                                           :pipe ::in)
              ::core/fn (core/stack-effect [v p] [(doto p (put v))])}
        'close {::core/spec (core/stack-spec :pipe ::core/pipe)
                ::core/fn (core/stack-effect [p] (do (close p) [p]))}
        'closed? {::core/spec (core/stack-spec :pipe ::core/pipe)
                  ::core/fn (core/stack-effect [p] [(closed? p)])} 
        'pipe-in {::core/spec (core/stack-spec :obj ::item)
                  ::core/definition
                  '[
                    [[[type [ip-port] unwrap =]
                      [clone port lookup [address lookup] dip
                       !**java.net.Socket. 
                       !*getOutputStream]]
                     [[type [file] unwrap =]
                      [value
                       +clojure.java.io/file
                       +clojure.java.io/output-stream]]]
                    decide]}
        'pipe-out {::core/spec (core/stack-spec :obj ::item)
                   ::core/definition
                   '[
                     [[[type [file] unwrap =]
                       [value
                        +clojure.java.io/file
                        +clojure.java.io/input-stream]]
                      [[list?]
                       [+kcats.pipe/->filled]]]
                     decide]}
        'assemble {::core/spec (core/stack-spec :pipe ::core/pipe
                                                :reducer ::core/program)
                   ::core/doc "Takes from the pipe and runs reducer, until the pipe closes"
                   ::core/definition '[swap
                                       [take swap] swap pack
                                       [dip] join
                                       [[closed? not]] dip
                                       while]}
        'spit {::core/spec (core/stack-spec :contents ::core/item
                                            :target ::core/item)
               ::core/definition '[[pipe-in] dip bytes put close discard]}
        'slurp {::core/spec (core/stack-spec :target ::item)
                ::core/definition '[]}
        'spawn {::core/spec (core/stack-spec :expression ::core/list)
                ::core/fn (fn [{::keys [stack] :as env}]
                            ;;(print-env env)
                            (let [expr (first stack)]
                              (->> expr
                                   core/default-env
                                   (eval {:before-step core/print-env})
                                   future))
                            (update env ::stack rest))}})
#+end_src
*** Notes
core.async has an out-of-band close message. Do we need that? Seems
handy but also adds complexity as it becomes an error condition trying
to put/take into a closed pipe, that would then need to be handled.

Seems acceptable to me that pipes are just there and if you want to
tell whoever's at the other end that you're done sending, just send
something that tells them that.

It might be nice for the receiver to be able to let the sender know
he's "hanging up", but I think that function is better handled at a
higher level of abstraction (something built on top of bidirectional
pipes, which is just two pipes with the sender and receiver swapped)
** Crypto
#+begin_src clojure :tangle src/kcats/crypto.clj
(ns kcats.crypto
  (:require [kcats.core :as core])
  (:import [java.security MessageDigest SecureRandom KeyPairGenerator Signature]))

(swap! core/core-words merge
       {'hash {::core/spec (core/stack-spec :input ::core/bytes)
               ::core/definition '[[[[bytes?] [["SHA-256"
                                                !*java.security.MessageDigest/getInstance] dip
                                               !**digest]]
                                    [[string?] [bytes hash]]
                                    [[list?] [string hash]]]
                                   decide]}
        'key {::core/spec (core/stack-spec :seed ::item)
              ::core/definition '[bytes

                                  ["SHA1PRNG" !*java.security.SecureRandom/getInstance] dip
                                  ,*!*setSeed

                                  ["EC" !*java.security.KeyPairGenerator/getInstance 256] dip
                                  ,*!**initialize 
                                  
                                  !*generateKeyPair
                                  [!*getPublic] shield

                                  wrap [ec-keypair] join
                                  swap
                                  !*getPrivate pack
                                  [public type private] swap zip]}
        'encode {::core/spec (core/stack-spec :data ::core/item
                                              :as ::core/item)
                 ::core/definition '[[[[swap type base64 =]
                                       [bytes
                                        [!java.util.Base64/getEncoder] dip
                                        !**encodeToString
                                        swap discard]]]
                                     decide]}
        'decode {::core/spec (core/stack-spec :data ::core/item
                                              :as ::core/item)
                 ::core/definition '[[[[swap type base64 =]
                                       [bytes
                                        [!java.util.Base64/getEncoder] dip
                                        !**encodeToString
                                        swap discard]]]
                                     decide]}
        'sign {::core/spec (core/stack-spec :message ::core/item
                                            :key ::core/item)
               #_::core/fn #_(core/stack-effect
                              [m k]
                              [(let [signer (doto (Signature/getInstance "SHA256withECDSA")
                                              (.initSign k)
                                              (.update m))]
                                 (.sign signer))])
               ::core/definition '[swap
                                   "SHA256withECDSA" .*java.security.Signature/getInstance
                                   .!!initSign
                                   .!!update
                                   .*sign]}
        'verify {::core/spec (core/stack-spec :signature ::core/item
                                              :message ::core/item
                                              :key ::core/item)
                 ::core/fn (core/stack-effect
                            [s m k]
                            [(let [signer (doto (Signature/getInstance "SHA256withECDSA")
                                            (.initVerify k)
                                            (.update m))]
                               (.verify signer s))])}})
#+end_src

#+begin_example
;; in progress example sign
(k 
             '["foo" key [private] lookup
               "We strike at dawn"
               "SHA256withECDSA" .+java.security.Signature/getInstance
               swap discard ;; drop the full key
               [..+initSign] void
               [..+update] void])

;; next iteration
["foo" key 
"We attack at dawn" bytes 
[[[private] lookup] dip sign] shield
;[discard "bar" key] dipdown ;; try different key for verify
;;20 pack ;; add another byte to the sig, to make it invalid
[[public] lookup] dipdown verify]
#+end_example
* Tasks
** TODO Make a reader for the language
needs to support comments. clojure reader probably sufficient?
** TODO stdlib in a separate kcats file
** TODO Nested envs no longer need to convert back and forth
** TODO More support for nested/related envs
Debuggers, spawning, ingesting etc
** TODO Native spec
Write spec in terms of predicates that return true if what's on the
stack is valid for the word. Probably not easy to get an explanation
as detailed as clojure.spec, but most of the specs should be very
simple list/number/etc. 
* Notes
** Instruction set
It might be prudent to define some low level words, and then define
the higher level words in terms of those words. Essentially trading
some performance for portability. Here's a stab at what some of the
low level words would be. We could refer to positions on the stack and
expression with an integer (positive = on stack, negative = on
expression)

- shift* items from the expression to the stack, or vice versa (neg),
  int argument. Oops the problem here is if you shift stuff from
  stack->expr whatever you shifted will get eval'd next, instead of
  what you probably wanted

- move* better than swap as you can specify what you're moving AND how
  far. This has the problem of needing to know how long the section of
  program is that you need to move things past. I'm not sure this is
  useful either, as moving things into the expression is not very useful
  
- exchange* items at the given locations (eg -1 1 swap would swap the
  top of the stack and top of the expression)

- swap* shorthand for 1 2 exchange* (swap the top two items)

- conj* the item on top of the stack into the agg just below it

- concat* the top n (or 2?) items (lists)

- execute* unwrap agg on ToS, move it into expr (to be eval'd)

- discard* get rid of items on the stack

- clone* duplicate items on the stack

- cleave* the env into two, execute the program on ToS on one of
  them, put result on other. drop the mutated env. -  see below

- booleans and* or* not*

- =* 

- branch*

- unwrap* - unwraps the list at position n

- inscribe*

- describe* 

Using this we can define =dip= like this (nope, does not work due to
neg shift being worthless)

#+BEGIN_EXAMPLE
  1 2 swap* -1 shift* conj*

  3 1 2 [* +] . dip
  3 1 [* +] 2 . -1 shift* conj*
  3 1 [* +] . 2 conj*
  3 1 [* + 2]  
#+END_EXAMPLE


ok how about this

#+BEGIN_EXAMPLE
  swap* conj* execute*

  3 4 2 5 [* +] . dip
  3 4 2 5 [* +] . swap* conj* execute*
  3 4 2 [* +] 5 . conj* execute*
  3 4 2 [* + 5] . execute*
  3 4 2 . * + 5
  3 8 . + 5
  11 . 5
  11 5
#+END_EXAMPLE

re cleave*, seems like there is some overlapping functionality
between parallelism and preserving the stack for things like
=shield=. In both cases we're cloning the environment (or part of
it) so that multiple modifications don't conflict with each other.

The only difference is how we join the cloned stacks back together.

With shield, we clone the env, run the program on the clone, take
the top of the stack and put it back on the original. throw the clone
env away.

With map, we clone the env (one for each item in the list), run the
program in parallel on each env, gather up the top items in each env,
and put it as a list on top of the original stack.

The question is, can we leverage kcats itself to manage the intra-env
computations? Seems like theoretically we could - make a new stack
consisting of the other stacks as list items in the new one. Then you
can process that arbitrarily and whatever remains can be used. Seems
like maybe channels should be a dependency here, since that would
easily pipe the right value back to the right env.

So, what's needed here is another combinator (like genrec etc) that
takes two programs:

+ one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

+ one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the =pop= would drop the =7= off the stack, so we're
testing that it gets resurrected for each item in the list =[1 2 3]=.

Let's define =f= as something that would take the input stack and leave

=7 [[1 swap pop inc] [2 swap pop inc] [3 swap pop inc]]= (concat'ing the
mapping function program onto each piece of data)

Then that list-of-lists is what's used to make new environments (in
the implementation of cleave*), each top-level item is a program to
run.

Then you'd have 3 environments, after the program had run, stacks look like this:

2
3
4

Then we'd need to specify how map gathers up the top items from this
stack and adds them to the original:

1 3 exchange pop pop

#+BEGIN_EXAMPLE
So, what's needed here is another combinator (like genrec etc) that
takes two programs:

,* one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

,* one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the pop

map

7 [1 2 3] [inc] . map

env1
7 1 . inc
7 2

env2
7 2 . inc
7 3

env3
7 3 . inc
7 4


,* distribute items f(stack) -> new env(s) expression (in the case of map, enstacken or whatever takes the agg on ToS as the items to be added)
,* run all the envs (one per item in the list below ToS) 
,* reduce all the ToSs (in the case of map we're already done)

Let's try shield

2 3 [+] shield

,* enstacken
,* run all (one)
,* conj o
#+END_EXAMPLE
** Dispatch
*** Basics
A multimethod is a function broken into two parts:

+ a dispatch (where the arguments are examined to figure out where to
  send them)
+ method call (based on the dispatch results, pass the same args to
  some other function)

Concatenative languages make composing functions easy so it's possible
all the language needs is a convenient way to create dispatches.

#+BEGIN_EXAMPLE
  [from where] [thing] get => the thing

  network {url "http://foo.com"} get => (a pipe to read data from)
  network {url "http://foo.com"} get bytes => (byte array)

  [foo bar baz quux] mapping foo get => bar
#+END_EXAMPLE

Defining a multifn

#+BEGIN_EXAMPLE
  ;; [program to prepend to method] multi word inscribe
  [type get] multi foo inscribe

  [url [sdf asdf]] foo addmethod
#+END_EXAMPLE

There are a few ways to approach this
*** Approaches
**** Clojure-like 
Tried and true, but requires the implementation of a type hierarchy to
do dispatch by type properly

**** Predicate based
This is where the implementation of multimethods is just =cond=. The
conditions are data (just like everything else) and to add methods,
you just insert a condition. 

A series of predicate/method pairs- Iterate over the pairs, and the
first one where the pred returns true, execute the
method. Performance-wise, it could be slower if there's lots of
methods defined. However there's no dispatch function to execute so in
some cases it could be faster. (Note also, that because there's a
stack here, we could always have a dispatch value available too)
Ordering of the methods would become important. For example, if you
had a predicate like =object?= (that is basically always true) you'd
have to make sure that's last in the list.

There's another performance issue - sometimes predicates are expensive
to calculate repeatedly. Let's say you have a list of a billion
integers, and you have a method that is dispatched to with =[int?
every?]=. There's a couple strategies to combat having to examine
every item in that list, especially multiple times:

+ Cache the result as metadata on the value. Predicates could, instead
  of popping the value off the stack and leaving a boolean, leave the
  value but with an added metadata, of which predicate was already run
  on it, and the result. Predicates can short-circuit by seeing if the
  metadata is there before actually running.
+ Allow anyone to populate that metadata. If you know a huge list is
  already going to return true on some predicate, you can just add the
  meta at creation time. Of course this is a foot gun so you have to
  be careful and understand these are assertions that can be wrong.

Generally I am not going to worry about performance yet but I want it
to be addressable with backward compatible additions to the language.

#+begin_example
  ;; basic multimethod pattern
  [clone [[pred1...] [method1]
          [pred2...] [method2]
          ...] 
#+end_example
#+BEGIN_EXAMPLE
  ;; old example code 

  [[odd?] execute [[true [inc]] [false []]] swap get execute]

  ;; so the pattern here is [dispatch-fn execute methods swap get execute]

  ;; if we want to add a method, we can just insert it with add

  ;; we can create an empty multi from a dispatch:

  [[odd?] list [execute [] swap get execute] concat ;; or some such

  ;; then to update an already inscribed method
  [[foo] dup describe ... (updating) ... 

  ;; another way to do this is to just run predicates until one matches,
     that might do away with types entirely and just leave predicates.

  [[int? [+]] [string? [concat]] loop-and-execute ;; loop thru these and
  execute the first program where the pred matches.

  ;; for example
  5 6 [[[int?] [+]] [[string?] [join]] loop-and-execute
  11

  "hi" " there" [[[int?] [+]] [[string?] [join]] loop-and-execute
  "hi there"

  ;; should the predicates leave the value on the stack?
  5 odd?
  5 true
  ;; or drop it?
  5 odd?
  true

  ;; generally we probably still want to keep values that we're running
  ;; a pred on, but maybe best to explicitly clone
  5 clone odd?
  5 true

  ;; or should we actually reset the stack like with map? the benefit is
     that preds don't have to be tidy. but really i can't think of any
     reason they wouldn't be. The whole point of them is that they only
     need one value as input.
#+END_EXAMPLE


** Pipes
This is a general coordination construct. A pipe is a one way
communication channel, you put values in at one end, and take them off
at the other. Where the data actually goes (in memory, over network,
to a file, etc) is up to the implementation.

There are a few words that a pipe needs to respond to:
+ put - put a value into the pipe (may block)
+ take - take a value out of the pipe (may block)
+ close - close the input end of the pipe (no more puts)

And then some higher level words that let you do more complex things:
+ choose - given a list of pipes, block until one has a value ready,
  then return [val pipe].
+ copy - given two pipes, the values that emerge from the first will
  also emerge from the 2nd.
+ dump - given a pipe and a list, put all the items of the
  list into the pipe.

Unlike go/coreasync, there are no non-blocking operations, as envs are
equivalent to go blocks, so everything is in a go block.
#+BEGIN_EXAMPLE
  ;; create a pipe 

  
#+END_EXAMPLE


*** Problem
Pipes have non-representable content. For example, a pipe is made from
a clojure Atom, how do we represent that as a pure value? You can
maybe encode the memory reference and pass it around somehow - but you
can't take an atom and send it over the wire to a different
process. That isn't the same atom, it can't dereference some other
process's memory. 

This kind of makes the goal of "everything is a value and
serializable" unattainable, but maybe we can get close enough.

We could get sophisticated and pass an atom over the wire but as it
passes, wrap it in such a way that putting a value into it gets sent
back to its origin. That would be pretty powerful (and possibly
dangerous).

*** Implementation of 'close'
Should pipes implement this? (That there's nothing left to put/take so
don't bother waiting)?

I think it might be best to let pipes be a lower-level construct and
implement 'close' at a higher level. For example, add a 2nd atom pipe
that starts off with the value =false= and flips to =true= when
there's nothing left to put/take.

This is not terribly efficient but probably easiest to work with.

** Hash maps
*** Use a map literal or not?
Do we add a new literal type for maps? ={a 1 b 2}= ?

Or do we just use a list literal and specify that we want to look at
it like a map? =[a 1 b 2] hashmap=?

Data's just data, should it also carry around how it's supposed to be
looked at? A hashmap is just a list with some optimizations (the data
is grouped by hash so that you can find an item in O(1) time - but you
can always construct a hashmap from a list as the list has all the
data).

All data can be represented as lists (possibly nested), eg a graph
=1->2<-3= is =[[1 2] [3 2]]=

Do we just not bother to turn a list into something else until we
reach a word that expects a certain semantic? for example:

=[a 1 b 2] b get= we're clearly using =get= as a hashmap get, not
trying to get a vector item at an index b. (however if you allowed
integer keys, it would become ambiguous - but let's ignore that for
now). So maybe the language impl can see that we intend to use this
list as a map, and create a hashmap under the covers. (note I no
longer think this is necessary esp for smaller maps. elisp just uses
association lists (O(n) lookup) and for small maps it's actually going
to be faster than hashmap lookup. The vast, vast majority is going to
fall into that category. Hashmaps should be available for larger data
but not the default for literals.
*** Hashmap/ case statement equivalence
There's no difference between a hashmap with get, and a case statement
in this language. So maybe we shouldn't bother with hashmap types? We
could just have a program that we pass around and can modify?
 
=[a 1 b 2] b case=
** Types
How do we express types? We're definitely going to want to dispatch
methods based on "type" (whatever that may mean). One approach is to
just treat any map with a =type= field as an object. We'd need some
kind of inheritance functionality to be able to count, say, a =float=
type as a =number= type. However a single =type= may not be expressive
enough. In other languages, a type might be labelled with all the
interfaces or protocols it implements. I'm not sure that's necessary -
to find out if a type has a method implementation, we could possibly
introspect the dictionary and see what methods have a dispatch for
that type. It seems to me that would only be needed for exploratory
purposes (to find out what you can do with a given type), not at
runtime.

#+BEGIN_EXAMPLE
[type get] multi fetch inscribe ;; return bytes
[url [prog to get url]] [fetch] method put ;; uh oh, how do we avoid actually calling fetch here?? needs to be quoted
[[type url] [url "http://google.com"]] fetch
;; or how about a shorthand
[url "http://google/com"] hint fetch ;; where hint converts into a map with 2 values

[file [prog to read file]] [fetch] method put
[file "/tmp/blah.kcats"] hint fetch read eval ;; run a script?
#+END_EXAMPLE

What about generics? How to express "list of int"?

Could we make use of a predicate(s)? eg[ [value 1] [type integer?] ]
*** Discussion
At the lowest level, all values are just a sequence of bits. Machines
might be optimized for certain sizes and operations, but those are
implementation details.

Of course, the problem comes when a program gets a sequence of bits
but doesn't know what it's supposed to do with it. For example the =+=
operator might be intended to do arithmetic addition if the bits are
meant to be numbers, and concatenation if they're meant to be
text. How does it know which one it's got, when they're both just
sequences of bits and there's not necessarily any way to tell?

Type information included along with the value is the "typical"
solution, along with hierarchies etc. At least, there has to be a key
of some kind included that lets the program look up, in some way, what
it's supposed to do with the actual bits given a certain operator or
word.

Let's say there's a key k and the word w. The goal is to have a f(k,
w) that returns a program that manipulates the bits in the desired
way.
*** Predicate based
Since we make use of programs (executable lists) all over the place,
why not for type specification? We could have some native predicates
like =int?= =string?= etc, from which you can build up more complex
type-discerning predicates. Then dispatch is just going thru all the
methods until you hit one that matches.

#+begin_example

#+end_example
** Quoting
Do we need a special quote syntax other than lists? I'm thinking
of quoting a single word, (using lisp syntax here) is '(foo)
equivalent to 'foo? Obviously in lisp it isn't. I don't think it will
be in kcats either. For example the equivalent of assoc, it seems
reasonable to use a word as a key, but as soon as you put the word on
the stack, it's executed before we can assoc a value. That's not what
we intended. One way out is to do =[word] unwrap= which would just
leave =word= bare on the stack. Doing this might be rare enough that
it's ok to be that clunky vs making the language more complex to
support =quote=.

There's a couple examples I thought of where we might miss having a
special quote reading function.
 
+ If you want to be able to read a literal list and eval recursively
  so that you get the same access to evaluation in a literal that
  you'd get in other languages. eg in clojure 
  #+begin_src clojure :tangle no
    {:a (+ 1 1)}
    ;;eval's to
    {:a 2}
  #+end_src
  to get this in kcats you'd have to do something like
  #+begin_src fundamental
    [[a [1 1 +]] eval-recurse
  #+end_src
  The problem here is that when we only have one list construct, we
  can't tell where we're supposed to stop recursing and start
  evaluating. So we might end up recursing into =[1 1 +]= instead of
  executing it as a program. Also, the bare word =a= is a problem,
  it's not supposed to be eval'd in this case. But =eval-recurse= has
  no way to know that.

  The quoting functionality only fixes the latter issue. The former is
  tough because even with a way to distinguish, what's on the stack
  it's evaluating in? What's the equivalent of 
  #+begin_src clojure :tangle no
    (let [x 3]
      {:a (inc x)
       :b (* x 5)})
  #+end_src
 
  The reality is there isn't an equivalent because in a stack based
  lang, there are no "locals" with names. There are only stack items.
  
  So how would eval-recurse even work? Something like this?
  #+begin_src fundamental 
    1 [1 [1 +]] eval-recurse
    ;; if it's an atom, eval it, otherwise eval-recurse
    1 [1 [1 +]] [eval-recurse] map
    ;; done
    1 [1 2] 
  #+end_src
  
** Feature dependency tree
*** Types
**** Multimethods
***** Pipes
needs multi's because words like get/put should probably be generic
and have specific methods for pipes.

** Shield/shielddown/etc?
Do we need these? If a program knows that the items it consumes will
be needed later, it can =clone= them. And if a program is going to run
another program that it knows will consume items it needs, it can also
=clone= them first.

So at first glance it would seem that shield et al aren't needed. 

Even if they were needed, these names are too difficult for the target
audience to understand. We need better names and I can't think of any
right now.

Note: I later realized that shield isn't as voodoo as I originally
thought. There's no magic in implementing shield, if you have the
=stack= (or =evert=) word (capture the stack as a list). Then you can
just clone it and it's easy to revert the stack back to a previous
state from the copy. My current thinking is having this word isn't
going to confuse users since it's not magic or exceptional.

** better names?
- dipd :: dipdown, protect? 
- ifte :: if
- swaack :: swapstack, switch, pivot, evert*
- primrec :: ?
- infra :: inject*
- cond :: choose, decide*
- assoc :: set, associate, assign*, link
- map :: ? 
- pipe-out :: tap? drain?
- pipe-in :: fill?
- handoff :: ?
- spawn :: ?
- shield :: protect? prevent? confine? keep? restore? conserve? shield?
- shielddown :: shielddown?
** Nested env Runtime structure
How do environments that create new environments control execution?

There could be a top level runtime that controls all the environments
(runs them in different threads, etc)

Or it could just be fully programmable where the entry-point env is
responsible for doing whatever it needs. 

The latter seems like the way to go, but what's the control mechanism?
I think threading a separate concern from how an env is executed (as
in, in a debugger etc)

A threadpool is probably fine, futures would probably do it, at least
as a first pass. But there won't be any top level "show me all the
environments" which would be super handy for use in an IDE. One way to
handle this would be - for any env that needs to send messages home to
some IDE, inherit that behavior from its parent and have the top level
env do that. However then there's the matter of how things like
breakpoints etc would be communicated down to where they're needed.

It's important to be able to distinguish between envs whose purpose is
to do the actual job and those that are part of the execution setup
(envs whose only job is to run other envs, say with logging or
debugging). It's kind of hard have a library that introduces a
hierarchy of envs and then still allow the user to debug it.
** Hylomorphism
From http://joypy.osdn.io/notebooks/Recursion_Combinators.html#hylomorphism
#+begin_example
[P] c [G] [F] [unit [pop] swoncat] dipd [dip] swoncat genrec
;; translate to kcats
[P] c [G] [F] [wrap [discard] swap join] dipdown [dip] swap join recur
#+end_example
** Every? impl
#+begin_example
(k 
 '[2 3 [3 5 7 9 13 11]          ; items exceptions? empty? continue?
   false ;; any exceptions found
   [[[nothing?] shield] dip ;; is the list empty? (keep the list intact)
    swap [or] shielddown]
   [not]
   [[unpack swap [[+ even?] unary] dip swap not] dip or]
   [execute]
   recur
   ;; drop the remaining items
   swap discard
   ])

#+end_example

The above seems to work (after inserting the 'swapdown' into the
predicate to get the remaining list out of the way, so that when =dip=
runs it is on on the stack.

I think what's needed is a recur combinator that does the snapshotting
and injecting, and lets the caller specify a) what to inject, b) what
to do with the resulting snapshot afterward, c) when to stop

So the general form is that we have a program to run on list
items (and the rest of the stack below the list) P, a list L, a condition when to
stop I, and a program to run on the snapshot after the program's been run C.

The initial stack will be: P L I C
Example:
[inc odd?]
[1 2 3]
[[clone nothing?] dip swap [or] shielddown] 
[first]

During execution the program can expect that each time through the
loop, the ToS is a result item that's being built. In the case of
=every?= it's just a boolean of whether a false item has been
found. The recur =if= will stop the loop only if that OR the remaining
list is empty.

So the recur will look like this (assuming result-so-far on ToS,
remaining data, and then a snapshot beneath): R D S
#+begin_src clojure :tangle no
I
[not] 
[[clone] dipdown ;; clone the snapshot. -> R D S S
 [unpack] dip ;; unpack the next item. -> R I D S S
 swapdown [pack] dipdown ;; pack item into snapshot copy. -> R D S' S
 [P inject] dipdown ;; inject P into snapshot copy. -> R D S'' S 
 [first] dipdown swapdown C  ;; Run C on the result modified snapshot and current result -> R' D S
]
[execute]
recur

C I L P
[rotate] dip
#+end_src

Would be nice to have some words that help construct programs.
#+begin_src clojure :tangle no
;; insert a program into a nested list at indices

[what-to-do] [a [b c]] [2 2] insert -> [a [b [what-to-do] c]]

[a b c] [what-to-do] 2 insert -> [a b [what-to-do] c]  

[]
#+end_src
** Argument order
Question: when calling a java or clojure method/fn what order should
it expect the arguments to be on the stack?

I think it's a lot clearer to write "5/2" as "5 2 /"
instead of "2 5 /" - in which case =/= should expect its first
argument to be the 2nd item on the stack and its 2nd arg on top.

What about java method calls? "mylist 5 .addItem" seems most clear -
addItem should expect the object below and the argument on top. It
seems strange to put a method argument on the stack *before* the
object whose method you intend to call.

However there are some cases where this gets awkward. For example,
when you construct an object and then want to call a method on it
using data already on the stack. The object is then above the
arguments and the stack needs to be rearranged.

Some examples:

#+begin_example

foo.bar(5).baz(6)
foo 5 .bar 6 .baz

foo.bar(5, new Baz(6))
foo 5 6 Baz. .bar 
6 Baz. foo swap .bar  
#+end_example
* Example programs
** Factorial
*** Recursive definition 
#+begin_src clojure :tangle no
 10 
 [fact [[clone 0 =]
        [discard 1]
        [clone dec fact *]
        if]]
 inscribe
 fact
#+end_src
*** Recursive with recur
#+begin_src clojure :tangle no
 5
 [clone 1 <=]
 []
 [clone dec]
 [execute *]
 recur

 5
 [1]
 [*]
 
#+end_src
*** Using range
#+begin_src clojure :tangle no
 10
 1 +
 2 swap
 range unpack
 [*] step
#+end_src
*** Plain loop
#+begin_src clojure :tangle no
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src
** Spawn child environments and pipe values back
#+begin_src clojure :tangle no
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[discard] dip ;; done with the pipe
+ ;; add numbers
#+end_src
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
 #+begin_src clojure :tangle no
 100 [0] [[1.0 swap /] dip +] primrec
 [100 0 swap 1 + 1 swap range [1.0 swap / +] step]
 #+end_src
** Primrec
#+begin_src clojure :tangle no
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
** Prime numbers (sieve of eratosthenes)
#+begin_example

[1000 clone 2 swap range ;; all the numbers up to n
  [.+java.lang.Math/sqrt .+java.lang.Math/ceil .int 2] dip  ;; start counter at 2, stop at sqrt of n
  [ [=] dip swap ] ;; stop loop when the counter hits sqrt n
  [] ;; after loop, nothing left to do 
  [ [ [ [=] 
        [swap mod 0 = not]]
      [execute] any?] 
    filter ;; keep the counter but no multiples of it 
    [inc] dip] ;; increment counter
  [execute]
  recur
  [discard discard] dip] ;; drop the original args, just leaving the primes
#+end_example
** Prime factors
#+begin_example
(k '[300

     [] swap 2

     [/ 2 >]
     [ [mod 0 =]
       [clone sink [pack] dipdown / 2]
       [inc]
       if]
     while

     discard pack])
#+end_example
