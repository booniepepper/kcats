# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
[[./kcats.png]]
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to express short
  programs. You can't write just 1 line of C++ or even python. But you
  will be able to write meaningful kcats expressions that are just a
  few words, and be able to put them into an application to get it to
  do what you want. While typical applications are menu-driven, kcats
  based applications will be message-driven, where a message is some
  words sent to a running program. 
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just words, numbers,
text, and quotation marks. No other symbols - no periods, exclamation
points, semicolons, equals, plusses, ampersands, or asterisks.

Quotations are marked with square brackets =[= and =]=, those are the only
two symbols that carry any meaning.
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as input,
then the resulting stack afterward (both the before and after stack
are surrounded with square braces):

#+BEGIN_EXAMPLE
[true ☯] [false]
[false ☯] [true]
#+END_EXAMPLE

In the example without knowing in advance what the =☯= symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Powerful
The language should allow the user to express himself succinctly and
without a lot of ceremony or repetition.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
The language should be well positioned to handle various types of
programming tasks, including numerical computation, API client/server,
networking applications, machine learning, etc.

** Make tool development as easy as possible
+ Debuggers
+ IDEs

Wherever possible, tooling should be baked into the language.
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Static analysis
* Defining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put
=1= onto the stack. Then we put =2= onto the stack (so that =2= is on
top and =1= is beneath it). Then we put the word =+= onto the stack
and it will consume the =2= and the =1= and replace them with the sum,
which is =3=. 
#+BEGIN_SRC kcats :results code :exports both
1 2 +
#+END_SRC

#+RESULTS:
#+begin_src kcats
3
#+end_src
#+latex: \caption{result}
Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add =1=
and =2= (leaving =3= on the stack), and then put =5= and =*= on
the stack (which consumes the =5= and =3=, leaving =15=):

#+begin_src kcats :results code :exports both
1 2 + 5 *
#+end_src

#+RESULTS:
#+begin_src kcats
15
#+end_src

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 + 5 * 
            1 | 2 + 5 * 
          1 2 | + 5 *
            3 | 5 *
          3 5 | *
           15 |  
#+end_example

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.

#+begin_src kcats :results code :exports both
  [1 2 3] [4 5] join
#+end_src

#+RESULTS:
#+begin_src kcats
  [1 2 3 4 5]
#+end_src

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [* +] execute
                    4 | 5 6 [* +] execute
                  4 5 | 6 [* +] execute
                4 5 6 | [* +] execute
          4 5 6 [* +] | execute
                4 5 6 | * +
                 4 30 | +
                   34 |
#+end_example
Note that, when =* += gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =* += would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_src kcats :results code :exports both
4 5 6 [+] [*] join execute
#+end_src

#+RESULTS:
#+begin_src kcats
44
#+end_src

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote, a message being
passed along and not acted upon until it reaches the recipient.

** Data types
*** Types
**** Words
In kcats, words have two main types
+ verbs, which result in actions being performed, and are defined in
  the dictionary
+ nouns or adjectives, which are used as labels or names for things,
  and are not in the dictionary.

The first type, verbs, are used directly in the execution of programs:

#+begin_src kcats :results code :exports both
  1 clone 2 swap
#+end_src

#+RESULTS:
#+begin_src kcats
1 2 1
#+end_src

The second type are used inside lists, often as keys in a map. These
words are never executed, they're used more like you'd use strings or
keywords in other programming languages.

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] unwrap put
#+end_src

#+RESULTS:
#+begin_src kcats
[foo bar baz quux]
#+end_src

Note the use of =unwrap= here. What's wrong with just trying to =put=
=quux= directly into the list? The problem is when kcats encounters a
word during execution, it checks the dictionary to see what to do. If
the word isn't isn't in the dictionary, that's an error.

#+begin_src kcats :results code :exports both
  [foo bar baz] quux put
#+end_src

#+RESULTS:
#+begin_src kcats
  [[type error]
   [asked [quux]]
   [reason "word is not defined"]
   [unwound [quux put]]]
  [foo bar baz]
#+end_src

What we want is to get =quux= onto the stack by itself without actually
executing it. We can do that with =[quux] unwrap=. The word =unwrap= does
just what it says, removes the list wrapper and leaves a bare word on
the stack. Another way to go about this is to use =join= so we don't
need =unwrap=:

#+begin_src kcats :results code :exports both
  [foo bar baz] [quux] join
#+end_src

#+RESULTS:
#+begin_src kcats
[foo bar baz quux]
#+end_src

**** Booleans
Kcats doesn't have traditional boolean values =true= and =false=. In
kcats decision making, an empty list =[]= acts like =false=, and
anything else acts like =true=.

#+begin_src kcats :results code :exports both
  [] ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
  "no"
#+end_src

#+begin_src kcats :results code :exports both
  "anything" ["yes"] ["no"] branch
#+end_src

#+RESULTS:
#+begin_src kcats
  "yes"
#+end_src

Some words will return the word =true=, but it's not really a boolean,
it's just the word =true= which has no special meaning other than that
it's an arbitrary truthy value (remember anything that's not an empty
list is "truthy", so any word, including the word =true= is truthy). For
convenience, =true= is in the dictionary, so you do not have to quote
it. It evaluates to itself.

#+begin_src kcats :results code :exports both
  3 odd?
#+end_src

#+RESULTS:
#+begin_src kcats
  true
#+end_src

There are some extra words defined for your convenience: =nothing= and
=false=. Both of them evaluate to =[]=. Using them instead of the empty
list can help with readability.

**** Strings
Strings work much like in other programming languages (except there
are fewer library functions).
**** Bytes (byte array)
Byte arrays are a sort of "lowest common denominator" data format. 
**** Numbers
Integers and floats are supported (64 bit). 
**** Lists
Lists are just multiple items bound up into a single unit, where their
order is maintained.

***** Comprehension
See the word =step=, which runs the same program on each item in a list.

#+begin_src kcats
integers 10 taker collect [+] [take swap] dip step 
#+end_src

#+RESULTS:
: 55 [[positive?] [dec [generate] dive] [drop []] if] [inc clone] 10

#+begin_src kcats :results code :exports both
0 1 10 1 range [+] step
#+end_src

#+RESULTS:
#+begin_src kcats
45
#+end_src

Similar to =step=, but more strict, is =map=, which only allows the
program to work on a given item and can't mess with the rest of the
stack:

#+begin_src kcats :results code :exports both
1 10 1 range [3 *] map
#+end_src

#+RESULTS:
#+begin_src kcats
[3 6 9 12 15 18 21 24 27]
#+end_src

**** Associations
An association looks just a list of pairs, like this:
#+begin_src kcats
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]
#+end_src

However there are some words you can use that make a list behave a bit
differently. For example:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] 25 assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[name "Alice"] [age 25] [favorite-color "brown"]]
#+end_src

Here we want to reset Alice's age - but we don't want to create a new
item, we want to find the existing one and replace it. It will create
a new item if it doesn't exist:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [department] "Sales" assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[favorite-color "brown"] [name "Alice"] [department "Sales"] [age 24]]
#+end_src

Notice that the order of the items is not preserved. Once you treat a
list as an association, it "sticks" - it acts like an association from
then on and order is no longer guaranteed to be maintained.

We can improve upon our example that incremented Alice's age
(presumably after her birthday) with the word =update=. That will run a
program on the value of whatever key (or keys) you specify.

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update
#+end_src

#+RESULTS:
#+begin_src kcats
[[name "Alice"] [favorite-color "brown"] [age 25]]
#+end_src

Note that associations and lists look the same when printed but
testing them for equality can reveal they are not the same:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  =
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

Here we are comparing an association with a list. The === operator has
no way of knowing whether you want the list semantics (which does care
about order), or the association semantics (which doesn't care). It
defaults to the more strict rules, so they are not equal.

The act of using a list as an association (by applying words to it
like =assign= or =update=) will convert it to an association, but what if
you just want to convert a list to an association, without doing
anything else?

You can use the word =association= to convert the list to an association:

#+begin_src kcats :results code :exports both
  [[name "Alice"]
   [age 24]
   [favorite-color "brown"]]

  [age] [inc] update

  [[name "Alice"]
   [age 25]
   [favorite-color "brown"]]

  association =
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

**** Sets
**** Errors
**** Pipes
*** Traits
 The types just discussed is all there are, but there are words that
 operate on multiple types, and it's helpful to talk about what those
 types have in common.
**** Dispenser
Containers from which you can take out or put in items, one by
one. Includes:
+ Strings
+ Bytes
+ Lists
+ Associations
+ Sets
+ Pipes

Supported words:
+ =put=
+ =take=
+ =step=
  
**** Sized
Containers whose items can be counted. Includes:
+ Strings
+ Bytes
+ Lists
+ Associations
+ Sets

Supported words:
+ =count=
+ =join=
+ =every?=
+ =any?=
**** Ordered
Containers whose items are kept in a specific order. Includes
+ Strings
+ Bytes
+ Lists

Supported words:
+ =pop=
+ =first=
+ =second=
+ =last=
+ =reverse=
*** Promotion
Data types are automatically converted when you try to use them in a
way that requires it.

For example, if you have a list of pairs and you use the word =lookup=,
it assumes your intention is to use the list as an associative data
type, so it will be automatically converted, and remain converted
after =lookup= completes.

You can tell by the spec when the return type is a promoted type:
#+begin_src kcats :results code :exports both
dictionary [assign spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item value] [list keys] sized] [association]]
#+end_src

Here you can see that the spec for =assign= takes a =sized= and returns an
=association=. This allows you to do things like this:

#+begin_src kcats :results code :exports both
[[name "Susie"] [age 25]] [sport] "bowling" assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[name "Susie"] [age 25] [sport "bowling"]]
#+end_src

The initial value of =[[name "Susie"] [age 25]]= is not an =associative=,
it's just a =list=. You could explicitly convert it using the word
=association= but =assign= will do it for you, because it needs an
associative type.

Note that the conversion can fail, because converting to =associative=
requires that you have a list of pairs. If you don't, that's an error:

#+begin_src kcats :results code :exports both
["foo" "bar"] [age] 25 assign
#+end_src

#+RESULTS:
#+begin_src kcats
  [[type error]
   [reason "type mismatch"]
   [actual "foo"]
   [unwound []]
   [asked [pair]]
   [handled true]]
#+end_src

The most common promotion is from =list= to =associative= but there are
others.
** Error handling
In kcats, when a program encounters an error, an error object is
placed on the stack instead of the usual result.

#+begin_src kcats :results code :exports both
2 3 "four" * + 
#+end_src

#+RESULTS:
#+begin_src kcats
  [[type error]
   [reason "type mismatch"]
   [asked [number]]
   [unwound [* +]]]
  "four" 3 2
#+end_src

Notice the =unwound= field contains the rest of the program that
remained when the error occurred.

We can fix the problem and continue, but only if we can stop the
unwinding before our entire program is unwound. We can do that using
the word =recover=, which takes two programs: =p= and =r=, =p= is run and if
it results in an error, the unwinding is limited to =p= and then =r= is
run. When =r= runs, the error object is on the top of stack. If there is no
error, =r= does not run.

In the program below, we recover by discarding the error and the
string "four", and replacing it with the number =4=. Then trying the
operations =* += again.
#+begin_src kcats :results code :exports both
  2 3 "four" [* +] [drop drop 4 * +] recover
#+end_src

#+RESULTS:
#+begin_src kcats
14
#+end_src

The problem with the usage of =recover= above is that we had to specify
the arithmetic words =* += twice - once in =p= and again in =r= in case they
failed the first time. Remember those operations are saved in the
=unwound= field of the error, and we can access them and even =execute=
them. There is a word that does this for you: =retry=: it takes an error
on the top of stack, and executes its =unwound= program.

#+begin_src kcats :results code :exports both
  2 3 "four" [* +] [[drop 4] dip retry] recover
#+end_src

#+RESULTS:
#+begin_src kcats
14
#+end_src

In the above program, after the error occurs, we discard the string
underneath the error and replace it with the integer =4=.

Sometimes you need to raise your own errors, you can do that with the
word =fail=.

Sometimes you want to handle some errors but not others. There's no
error type matching like you'd find with java's =catch=. You have to
recover, examine the error, and if it's one you don't want to handle,
re-activate it with =fail=.
** Coordination and Input/Output
*** Basics
In kcats, both coordination and input/output are done with =pipes=. See
the [[Defining some terms][definition]] for pipe.

Let's take a common example of coordination. Your program has to do
several very long and intensive calculations but doesn't want to make
the user wait to do other things. The way that's done in kcats is by
creating multiple environments, and have them communicate with each
other using pipes. You can send any value through a pipe that you
could put onto the stack, including other pipes. You can =clone= a pipe
to give access to it to more than one environment.

There are two main operations a pipe supports: =put= and =take=. You
either put an item in, or take an item out. Either one of those
operations may *block*, if the pipe is either full (when putting) or
empty (when taking). Your environment would have to wait for some
other environment to take something out so there's space to put, or
put something in so that there's something to take out.

All pipes share the =put= and =take= operations but they can differ in
other ways. For example, the pipe you get when writing to a file will
only accept bytes. Trying to put any other type will cause an
error. Pipes also have varying capacity to hold items. Imagine a pipe
that has no length at all, it's just a hole in a thin wall. It doesn't
hold anything - you can only pass an item through if there's someone
on the other side of the wall already waiting to accept it. That's
called a =handoff=, and is the most common coordination pipe. Other
pipes have a capacity. Imagine a pipe where even if no one is taking
anything out of it, you can still put 10 items into it before it will
stop accepting more. That is a pipe with a capacity of 10 items.

Note that =put= and =take= can also be used on plain lists. =put= adds to
the end, and =take= removes the first item. Neither will ever block when
used on a list. Another slight difference is what happens when you've
reached the end of the content (either the list is empty or the pipe
has, for example, hit the end of file condition): a =take= from an empty
list will just return =nothing=, but a =take= from a pipe that is at EOF
will result in an error.

*** Input/output
Let's look at how we do I/O using files as an example - let's say we
want to write the word =foo= to a file called =bar=:
#+begin_src kcats :results code  :exports both
  [[file "bar"]] pipe-in ;; create the pipe to the given file "foo"
  "foo" bytes ;; we have to convert string to bytes first, using the word
        ;; =bytes=.
  put ;; finally, put the bytes into the pipe, and they are written to
      ;; the file
#+end_src

#+RESULTS:
#+begin_src kcats
[[type pipe] [file "bar"]]
#+end_src

Neither =put= nor =take= consume the pipe from the stack, for convenience,
as most of the time you'll want to use it again.

Let's look at reading from a file:

#+begin_src kcats :results code :exports both
[[file "bar"]] pipe-out
take string
#+end_src

#+RESULTS:
#+begin_src kcats
"foo" [[file "bar"] [type pipe]]
#+end_src

Note that the amount of bytes you'll get from a file on each take, is
limited. You will only get the entire contents if the file is
small. To get the entire contents at once, use the snippet =[join]
step=, which repeatedly takes from the pipe and joins it with whatever
has been taken so far. Here we start with nothing (=[]=) and keep
appending bytes until there's none left, and finally convert to string.

#+begin_src kcats :results code :exports both
[] "bar" file-out [join] step string
#+end_src

#+RESULTS:
#+begin_src kcats
"hello world!"
#+end_src

*** Infinite sequences and generators
Sometimes in programming, having the concept of an infinite sequence
is handy. You will never actually consume the entire thing, obviously,
but the idea is that you don't know how much you will consume so you
want to consider it infinite.

Here's an example: Let's say you want to create the fibonacci
sequence. Let's see how we can code that without worrying about how
many items in the sequence we'll eventually need. We'll do that using
a =generator=. A generator consists of two things: state, and a
program. Each time we want to generate a value, we run the
program. The program should produce a new value and update the state
if necessary. We just put however many state items we need on the
stack, and then a program that can work with those items.

#+begin_src kcats
1 0 [[+] shielddown swap clone]
#+end_src

So here we start with =1 0=. That's the starting state. Normally we'd
start fibonacci with =1 1= but we're deviating a bit from that, and we'll
see why soon. Then we have a program that takes two numbers as input
and leaves one new number. Let's just =execute= that program and see
the result:

#+begin_src kcats :results code :export both
1 0 [[+] shielddown swap clone] execute
#+end_src

#+RESULTS:
#+begin_src kcats
1 1 1
#+end_src

So why did it produce =1=? Remember the generator must do two things,
produce a new value and update the state. We need to return =1= as the
first fibonacci number, and also keep =1 1= as the state, because for
the following item we need to add =1= and =1=. We =clone= it so it can serve
both purposes.

This gets us somewhere, but not the actual fibonacci sequence. Let's
look at the word =generate=. All it does is run the program, pulls the
generated item to the top of the stack, and puts a new copy of the
program in place so that when we want the next item, we can call
=generate= again:

#+begin_src kcats :results code :export both
1 0 [[+] shielddown swap clone] generate
#+end_src

#+RESULTS:
#+begin_src kcats
1 [[+] shielddown swap clone] 1 1
#+end_src

Notice here that the only difference from before is that the program
is sandwiched between the fibonacci number we produced, and the state.

Let's keep going and call generate again! But wait, before we do that
we need to do something with value we just produced, to get it out of
the way. For now we'll just =discard= it. We've seen it and we want to
see what's next.

#+begin_src kcats :results code :export both
  1 0 [[+] shielddown swap clone] generate ;; what we had before
  drop ;; throw away the first value
  generate ;; the 2nd value
#+end_src

#+RESULTS:
#+begin_src kcats
1 [[+] shielddown swap clone] 1 2
#+end_src

Ok, so the 2nd value is =1= and we can see the state is updated -
instead of =1 1= we have =1 2=.

One more time:
#+begin_src kcats :results code :export both
  1 0 [[+] shielddown swap clone] generate ;; what we had before
  drop ;; throw away the first value
  generate ;; the 2nd value
  drop
  generate ;; the 3rd value
#+end_src

#+RESULTS:
#+begin_src kcats
2 [[+] shielddown swap clone] 2 3
#+end_src

Ok we can see that we can get values one at a time by manually calling
=generate=, but this is not very useful. What we really want is to do
something like get the first =20= numbers in the fibonacci sequence and
collect them into a list. We can do exactly that:

#+begin_src kcats :results code :export both
1 0 [[+] shielddown swap clone] ;; our original generator
20 taker ;; another generator that calls the above one 20 times
assemble ;; collects all the generated items into a list
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765] [[positive?] [dec [generate] dip swap] [drop []] if] [[+] shielddown swap clone] 6765 10946
#+end_src

There's the fibonacci sequence! Hey, what's all that stuff at the end?
We just want fibonacci! That's there in case you wanted to keep
generating more values. If you want to just get the result and throw
away the generators, you can do that with =shield=, which erases all
stack effects except whatever was on top. So we'll just =shield= the
entire thing:

#+begin_src kcats :results code :export both
  [1 0 [[+] shielddown swap clone] ;; our original generator
  20 taker ;; another generator that calls generate 20 times
  assemble] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765]
#+end_src

So what is happening here? We're stacking up generators. Starting at
the top, we have =assemble= which will repeatedly call =generate= on the
generator below it. It keeps going and collecting the generated items
in a list, until the generator below returns =nothing=. Then it stops.

Then below =assemble= we have a generator =20 taker= - what that does is
keeps its own state of how many items we want it to take. It counts
down as it generates items below it, passing them up to =assemble= and
when it hits zero, it returns =nothing= (even if the generator below it
produced something). That will signal =assemble= to stop.

We have other handy generators we can stack up. Let's say for whatever
reason we want to know what are the first 20 *odd* fibonacci numbers?
Well, we have =filterer=:

#+begin_src kcats :results code :export both
  [1 0 [[+] shielddown swap clone] ;; our original generator
  [odd?] filterer ;; a generator that keeps calling the one
                  ;; below it until it gets something that
                  ;; passes the predicate we specified
  20 taker ;; another generator that calls generate 20 times
  assemble] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 3 5 13 21 55 89 233 377 987 1597 4181 6765 17711 28657 75025 121393 317811 514229]
#+end_src

There it is, the first 20 *odd* fibonacci numbers!

Let's say instead we wanted to know the prime factors that make up
each of the first 20 fibonacci numbers. We can do that with =mapper=:

#+begin_src kcats :results code :export both
  [1 0 [[+] shielddown swap clone] ;; our original generator
   ;; a program to give the prime factors of a given number
   [[] swap 2
    [/ 2 >=]
    [[mod zero?]
     [clone sink [put] dipdown / 2]
     [inc]
     if]
    while
    drop put]
   mapper

   20 taker ;; another generator that calls generate 20 times
   assemble] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[[1] [1] [2] [3] [5] [2 2 2] [13] [3 7] [2 17] [5 11] [89] [2 2 2 2 3 3] [233] [13 29] [2 5 61] [3 7 47] [1597] [2 2 2 17 19] [37 113] [3 5 11 41]]
#+end_src

There we have it. We can see that =[2 2 2]= is what makes up 8, etc.

We can use =mapper= multiple times - let's say we don't want to see the
prime factors, just show how many each one has:

#+begin_src kcats :results code :export both
  [1 0 [[+] shielddown swap clone] ;; our original generator
   ;; a program to give the prime factors of a given number
   [[] swap 2
    [/ 2 >=]
    [[mod zero?]
     [clone sink [put] dipdown / 2]
     [inc]
     if]
    while
    drop put]
   mapper
   [count] mapper ;; count the prime factors
   20 taker ;; another generator that calls generate 20 times
   assemble] ;; collects all the generated items into a list
  shield
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 1 1 1 3 1 2 2 2 1 6 1 2 3 3 1 5 2 4]
#+end_src

Other included generators are:

+ dropper :: Inverse of =taker= - drops the first n items of the
  sequence and returns the rest.
+ laster :: drops all the items of the sequence except the last
  one. Useful for when you're only interested in the final state of
  something.
* Implementations
+ [[file:prototype.org::*Prototype implementation][Prototype implementation]]
+ [[file:production.org::*Production implementation][Production implementation]]
* Using
** Building
*** Dependencies
+ emacs
+ Runtime/compiler for the implemenation you're trying to run

*** Creating the source
The source is contained within these org files, along with annotations
and other non-code information. To generate the source code (that the
runtime or compiler needs as separate files) before running or
building, open the org file for the given implementation, and run
=M-x= =org-babel-tangle=.

See [[*Build without using emacs interactvely][Build without using emacs interactvely]]
*** Building and Running
See the Using heading in the file for the implementation you want to
use.
** Debugging
*** Overview
In kcats, we don't need an external debugger. We can debug our
programs right in the kcats interpeter. We can specify the program to
run and step through it.

Let's say this is the program we want to step through. This is how we'd normally run it:
#+begin_src kcats :exports both :results code
0 1 5 inc range [+] step
#+end_src

#+RESULTS:
#+begin_src kcats
15
#+end_src

To debug, we put it into an environment object which we can then use
debugging words like =advance=:

#+begin_src kcats :exports both :results code
  [[expression [0 1 5 inc range [+] step]]] environment
  [advance] 6 times
  eval-step
#+end_src

#+RESULTS:
#+begin_src kcats
  [[stack [[+] 1 0]]
   [expression [execute [2 3 4 5] [+] step]]]
#+end_src

Note that =advance= is like =step-over= in a traditional debugger, and
=eval-step= is like =step-into=.  So above we advance until we reach the
word =step= in the program, and then we step into it. We end up showing
the environment in the middle of execution. The stack has a program
=[+]= on top, and the next word is =execute= which will run that program.

** Developing
*** Emacs mode
#+BEGIN_SRC emacs-lisp
  (defface kcats-brackets 
    '((((class color)) (:foreground "DimGrey" :weight bold)))
    "kcats brackets" :group 'faces)
  (defface kcats-stackop 
    '((((class color)) (:foreground "LightGreen" :inherit 'font-lock-keyword-face)))
    "kcats stack manipulation operation" :group 'faces)

  (defconst kcats-font-lock-keywords
        `(("\\[\\|\\]" 0 'kcats-brackets)
          (";;.*" 0 'font-lock-comment-face)
          (,(regexp-opt '("swap" "swapdown" "drop" "dropdown" "sink" "float" "clone" "snapshot" "evert") 'words) . (0 font-lock-builtin-face))
          (,(regexp-opt '("true" "false" "nothing" "[]") 'words) . (0 font-lock-keyword-face))
          (,(regexp-opt '("first" "second" "last" "put" "take" "pop" "step" "filter"
                          "map" "count" "join" "rest" "wrap" "unwrap" "reverse") 'words) . (0 font-lock-function-name-face))
          (,(regexp-opt '("execute" "dip" "dive" "divedown" "dipdown" "shield" "shielddown" "shielddeep" "inject"
                          "loop" "while" "until" "if" "branch" "recur" "times") 'words) . '(0 font-lock-preprocessor-face))
          ("#?\"" 0 'double-quote prepend)))

  (add-hook 'kcats-mode-hook (lambda () (font-lock-add-keywords nil kcats-font-lock-keywords)))

  (require 'smie) ;; indentation engine

  (setq kcats-mode-syntax-table (let ((table (make-syntax-table)))
      ;; Initialize ASCII charset as symbol syntax
      (modify-syntax-entry '(0 . 127) "_" table)

      ;; Word syntax
      (modify-syntax-entry '(?0 . ?9) "w" table)
      (modify-syntax-entry '(?a . ?z) "w" table)
      (modify-syntax-entry '(?A . ?Z) "w" table)

      ;; Whitespace
      (modify-syntax-entry ?\s " " table)
      (modify-syntax-entry ?\xa0 " " table) ; non-breaking space
      (modify-syntax-entry ?\t " " table)
      (modify-syntax-entry ?\f " " table)
      ;; Setting commas as whitespace makes functions like `delete-trailing-whitespace' behave unexpectedly (#561)
      (modify-syntax-entry ?, "." table)

      ;; Delimiters
      (modify-syntax-entry ?\[ "(]" table)
      (modify-syntax-entry ?\] ")[" table)

      ;; Others
      (modify-syntax-entry ?\; "<" table) ; comment start
      (modify-syntax-entry ?\n ">" table) ; comment end
      (modify-syntax-entry ?\" "\"" table) ; string
      (modify-syntax-entry ?\\ "\\" table) ; escape

      table))

  (define-derived-mode kcats-mode fundamental-mode "kcats"
    "major mode for editing kcats."
    (set-syntax-table kcats-mode-syntax-table)
    (setq-local comment-start ";") ;; try ";;"
    (setq-local comment-end "")

    (smie-setup nil (lambda (method arg)
                      (when (eq method :list-intro)
                        t)))
    (setq font-lock-defaults '(kcats-font-lock-keywords)))

  (add-to-list 'auto-mode-alist '("\\.kcats\\'" . kcats-mode))
  (defun my-restart-kcats-mode ()
    (interactive)
    (let ((kcats-mode-hook nil))
      (normal-mode)))

  (defun kcats-format-buffer ()
    "Format the current buffer according to the kcats language style."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (pcase (char-after)
          (?\[ (kcats-indent))
          (?\] (kcats-dedent))
          (_ (forward-char)))))
    (goto-char (point-min))
    (while (search-forward "[[" nil t)
      (replace-match "[  ["))
    (goto-char (point-min))
    (while (search-forward-regexp "\\(\\[\\|\\]\\)[[:space:]]+\\(\\[\\|\\]\\)" nil t)
      (replace-match "\\1\\2")))

  (defun kcats-indent ()
    "Increase the indentation level by 2 spaces."
    (beginning-of-line)
    (indent-line-to (+ (current-indentation) 2)))

  (defun kcats-dedent ()
    "Decrease the indentation level by 2 spaces."
    (beginning-of-line)
    (indent-line-to (max (- (current-indentation) 2) 0)))
#+END_SRC

#+RESULTS:
: kcats-dedent

*** org-babel mode
#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:kcats (body params)
  "Execute a block of kcats code with org-babel."
  (org-babel-eval
   kcats-babel-executable
   body))

(defcustom kcats-babel-executable "kcats"
  "Location of the kcats binary"
  :type 'string
  :group 'kcats-babel)
#+END_SRC

#+RESULTS:
: kcats-babel-executable

*** Repl mode
#+begin_src emacs-lisp
  (require 'comint)

  (defun kcats-send (proc code)
    "Send the CODE to the kcats interpreter and return the result."
    (message "Sending: %s" code)
    (let* ((code-len (+ (length code) 1))
           (code-str (format "%d\n%s" code-len code)))
      (with-temp-buffer
        (insert code-str)
        (process-send-region proc (point-min) (point-max)))
      (process-send-string proc "\n")
      ;;(accept-process-output proc)
      ))

  (defun kcats-repl ()
    "Start a REPL for process kcats."
    (interactive)
    (let ((buffer (get-buffer-create "*kcats* REPL")))
      (switch-to-buffer buffer)
      (unless (comint-check-proc buffer)
        (let ((buffer (comint-exec buffer "kcats" kcats-babel-executable nil '("-i")))
              (process (get-buffer-process buffer)))
          (set-process-buffer process buffer)
          (set-process-query-on-exit-flag process nil)
          (set-process-sentinel
           process
           (lambda (process event)
             (when (string= event "finished\n")
               (message "kcats process terminated.")))))
        (kcats-repl-mode))))

  (defun string-drop-first-line (s)
    (let ((lines (split-string s "\n" t)))
      (mapconcat 'identity (cdr lines) "\n")))

  (defun kcats-repl-insert-prompt (s)
    (concat s "kcats> "))

  (define-derived-mode kcats-repl-mode comint-mode "kcats REPL"
    "Major mode for interacting with the foo process."
    (smartparens-strict-mode t)
    (add-hook 'comint-preoutput-filter-functions 'string-drop-first-line)
    (add-hook 'comint-preoutput-filter-functions 'kcats-repl-insert-prompt)
    (setq comint-prompt-regexp "^kcats>")
    (setq comint-highlight-input nil)
    (setq comint-use-prompt-regexp t)
    (setq comint-input-sender 'kcats-send)
    (set-syntax-table kcats-mode-syntax-table)
    (setq font-lock-defaults '(kcats-font-lock-keywords)))

  (defun my-restart-kcats-repl-mode ()
      (interactive)
      (let ((kcats-repl-mode-hook nil))
        (normal-mode)))


#+end_src

#+RESULTS:
: my-restart-kcats-repl-mode

* Contributing
** Bug reports
Instead of opening a github issue, add a =TODO= subheading to the
[[*Issues][Issues]] heading. Commit the change and submit it as a pull request. In
the branch where that issue is being fixed, it will be changed to
=INPROGRESS=. When the issue is fixed, the heading will be
removed. (If you disagree that it's been fixed, submit a PR that
reverts the commit to remove it).

You can edit this file right on github, in your own fork of the
project, if you prefer.

Why do things this weird way? I don't want to rely on github, nice as
it is.
* Issues
** TODO Build without using emacs interactively
Users should not be required to know emacs to build the project, only
have it installed. The build should be accessible from bash without
having to use emacs interactively. 
** DONE Remove platform interop from lexicon
That was only there as a cheat when there was only the prototype
implementation. The platforms are different and their function names
don't belong in the lexicon.

I'm not even sure there should be platform interop at all - it doesn't
appear to be possible in the rust impl anyway.

So far what I've done is have some lower level words actually in the
dictionary but marked them like `++lookup`. I haven't decided what to
do about this yet. Lower level words probably should just be first
class citizens and I just need to think of better names. Right now the
low level (single-depth) lookup is `++lookup` and the user-facing
`lookup` does the arbitrary depth. In this case, the user-facing name
probably needs to change to reflect what it does (something like
`drill` or `extract`), and then the low level can just be `lookup`.

That means for all the i/o and crypto interactions, there needs to be
low-level words. I'm not sure yet how to prevent namespace pollution,
as one of the design choices is
** DONE 'unassign' doesn't take a keylist, only a single key
Should change to match =assign= and =lookup=, accept a list instead of
a single bare word.
** INPROGRESS More support for nested/related envs
Debuggers, spawning, ingesting etc
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?

This ties in with durability - where do we store things in general,
and not just libraries? kcats does support the filesystem but I would
like that to be for compatibility only. The "native" kcats way of
storing and retrieving things should be via hash keys. There may also
be a fact database, probably with sparse tables (aka eavt format).

It brings up the question of what should "come with" the language. I
am thinking maybe there's a "barebones" version of the language with
no library management or anything. Then on top of that, build some
durability and networking to distribute code and other data. Then the
question is, what do we need to support in the base language? Seems
like there needs to be database/network functionality there, but
unused? Maybe make it a feature flag?

Let's explore the various options
*** Durability
It's tempting to want the flexibility of EAV (where there's basically
just one big db table with 3 columns and every attribute is a row).

However this may be a little hasty. Perhaps what we're really after
here is custom tables - the idea being that each user's db schema
might be different depending on what data is important to them.

We've basically got a database schema consensus problem. Maybe Alice
has a table CATS with columns SIZE COLOR AGE and Bob has a table CATS
with columns HEIGHT COAT-COLOR AGE. How do they share data? The two
tables are not really compatible without a specialized conversion tool
and even then some data would be missing. So Alice and Bob ideally
should agree on what a CATS schema is, otherwise they can't really
share CAT facts. The advantage of EAV might be that even if they had
different schemas they could stlil perhaps meaningfully talk about AGE
and possibly even COLOR (with a bit of intervention, or even another
fact that equates COLOR and COAT-COLOR in CATS).

The drawback of EAV is of course that it would perform rather terribly
as the database grows. I can't say for sure how many facts could
potentially be stored here, but here are some constraints:

+ Assume individual data only (no facebooks that store millions of
  people's data)
+ Assume popularity of the app (users may try to cram every fact they
  "know" into this db)
+ Assume there's some kind of garbage collection - Alice may collect
  weather observations or predictions constantly but doesn't need to
  keep old data. Maybe facts have a TTL? Not sure how that could be
  determined automatically.

 It's hard to estimate how large the db might get, but I suspect a
  lower bound of supporting 1M entries is safe. As for upper bound,
  it's more difficult to say, but I would think the hardware limits of
  mobile devices would come into play. As of 2023 I think a db size on
  the order of 10gb would be approaching the device's capability
  limits, so maybe 100M entries or so. I think it would be difficult
  to get an EAV database to perform well at that size, especially on
  mobile. Note datomic can handle that size so it's theoretically
  within reach.

  It may be possible to pick a standard db now (sqlite maybe) and not
  worry too much about performance. As long as the facts are portable
  to another db (which shouldn't be that hard), the issue can be
  revisited when it becomes an issue.

  Even using sqlite though, just building proper queries may be
  difficult. It may be possible to skirt that problem too and just do
  a minimal query to get a dataset that fits easily in memory and then
  post-process the rest. Let's say the query is "List all predictors
  (people who made predictions) and their accuracy", you could get all
  the unique predictor ids in a query, then one by one get all their
  predictions, then get all the relevant observations and compare
  them. Slow but not the type of query that will be done often, and
  possibly indexable.
**** Possible dynamic sql db
One possible design is to just use plain old sql (sqlite?) and create
normal tables. However the table names would be namespaced, possibly
with some sort of hash. That way, one person's "Customer" schema could
be in the same database as another person's without interfering.

So for example, the kcats language might need to keep track of library
dependencies. There could be a table =dependencies-01234abcd= with
columns =name=, =version=, =hash=, =blob= etc. Anything else wanting to use the
same schema could refer to it by hash. It would be possible to have
foriegn keys too.

One thing we want to avoid is having kcats users writing sql query
strings, that is not the idiomatic way of dealing with i/o. What
should happen is there's a =query= word that takes a program and db
descriptor of where the db is, and returns a pipe (where results come
out). The program is a "query equivalent" and would need to be
translated to sql and post-processed. This is very much nontrivial and
a naive implementation probably wouldn't perform well but we will try
it anyway. For example instead of writing

#+begin_src sql
  insert into Customers (name, age) values ("Bob", 25); 
  select * from Customers where name="Bob";
#+end_src

you'd write something like
#+begin_src kcats
  customers [[name "Bob"] [age 25]] put
  
  customers [[name] lookup "Bob" =] filter
#+end_src

and 
And then the translation would see we're selecting from customers,
then there's a filter. The filter might not translate to sql so it
will either just select all, or if it sees a certain format for the
predicate it can translate to a =where= clause. This is going to be
complex and bug prone but hopefully can be done in a way that the
worst case is poor performance and then iterate to get better
speed.


I suppose content distribution might need to be done
alongside this.

** DONE Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
** DONE org-babel-execute for kcats
** INPROGRESS At least one example for each word in lexicon
#+begin_src kcats
10 0.5 *
#+end_src

#+RESULTS:
: 5

#+begin_src kcats
"foo" bytes
#+end_src

#+RESULTS:
: #b64 "Zm9v"

#+begin_src kcats
[[a b] [c [[d e]]]] [c d] 5 assign
#+end_src

#+RESULTS:
: [[c [[d 5]]] [a b]]

#+begin_src kcats
[[a b] [c []]] [c] [[d 5]] association assign
#+end_src

#+RESULTS:
: [[c [[d 5]]] [a b]]

#+begin_src kcats
[[a b] [c [[d e]]]] [1 1 0 1] 5 assign
#+end_src

#+RESULTS:
: [[a b] [c [[d 5]]]]

#+begin_src kcats
[[a b] [c [[d e]]]] [1 0] 5 assign
#+end_src

#+begin_src kcats
  4 3 [>] shield [wrap [wrap] dip] dip sink branch 
#+end_src

#+RESULTS:
: 4

#+begin_src kcats
  true 4 2  branch
#+end_src

#+RESULTS:
: [[asked [program]] [reason "type mismatch"] [type error] [unwound [branch]]] 2 4 true

#+begin_src kcats :results code :exports both
  5
  [1 2 "oh fudge"]
  [[+]
   []
   recover]
  map
#+end_src

#+RESULTS:
#+begin_src kcats
[[[type error] [reason "word is not defined"] [asked [handle]] [unwound []]] [[unwound []] [asked [handle]] [reason "word is not defined"] [type error]] [[asked [number]] [type error] [reason "type mismatch"] [unwound [+]]]] 5
#+end_src

#+begin_src kcats
5 1 [+] [] recover
#+end_src

#+RESULTS:
: [[unwound []] [asked [handle]] [reason "word is not defined"] [type error]] 1 5

#+begin_src kcats
1 type
#+end_src

#+RESULTS:
: number

#+begin_src kcats
5.01 5 0.1 swap [- abs] dip <
#+end_src

#+RESULTS:
: true

* Notes
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+BEGIN_SRC kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+END_SRC
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?


* Example programs
** Factorial
*** Recursive definition 
#+BEGIN_SRC kcats
10 
[fact [[clone 0 =]
       [drop 1]
       [clone dec fact *]
       if]]
inscribe
fact
#+END_SRC

*** Recursive with recur
#+BEGIN_SRC kcats
10
[1 <=]
[]
[clone dec]
[execute *]
recur
#+END_SRC

*** Using range
#+BEGIN_SRC kcats
10
inc [1 2] dip range 
[*] step
#+END_SRC

*** Plain loop
#+BEGIN_SRC kcats
10 clone 
true [dec clone [*] dip clone 1 >] loop
drop
#+END_SRC

** Spawn child environments and pipe values back
#+BEGIN_SRC kcats
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[drop] dip ;; done with the pipe
+ ;; add numbers
#+END_SRC
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
#+BEGIN_SRC kcats
100 [0] [[1.0 swap /] dip +] primrec
#+END_SRC

#+RESULTS:
: 5.187377517639621

** Primrec
#+BEGIN_SRC kcats
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [drop 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[drop] swap join] dip ;; add the drop to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+END_SRC
** Fibonacci
#+BEGIN_SRC kcats
10 [1 0] swap [[[+] shield] inject] swap times reverse
#+END_SRC

#+RESULTS:
: [0 1 1 2 3 5 8 13 21 34 55 89]

** Prime numbers (sieve of eratosthenes)
#+BEGIN_SRC kcats :tangle sieve.kcats
2000 clone 2 swap range ;; all the numbers up to n

[sqrt 2] dip  ;; start counter at 2, stop at sqrt of n
[sink =] ;; stop loop when the counter hits sqrt n
[[drop drop] dip]  ;; drop the original args, just leaving the primes
[[[[=] 
   [swap mod positive?]]
  [execute] any?] 
 filter ;; keep the counter but no multiples of it 
 [inc] dip] ;; increment counter
[execute]
recur
#+END_SRC

#+RESULTS:
: [[asked [consume]] [reason "not enough items on stack"] [type error] [unwound [sqrt 2 [[]] unwrap [sink =] [[drop drop] dip] [[[[=] [swap mod positive?]] [execute] any?] filter [inc] dip] [execute] recur]] [handled true]]

Here's a mimic of the python version:

#+begin_src kcats :results code
  ;; num
  10
  [[[] [true put]] dip times] shield ; a n
  2 ;; p a n
  [swapdown clone * > ] ;; while test
  [[wrap lookup] ; if test - fetch by index
   [
   swapdown ;; p n a
   clone ; p
   clone * ; p^2 p n a
   ;; range wants p, n+1, p^2 
   sink ;; p n p^2
   [inc] dip ;; p n+1 p^2
   [range] shield ;; r p n+1 p^2 a
   [dec sink drop] dipdown ;; r p a n
   swapdown ;; r a p
   [ ;; i r a p
    wrap ;;swapdown ;; [i] a r p
    [[]] update ;; set to false: a r p
    swap ;; r a p
   ]
   step ;; a p
   swap 
   ] ; do the for loop
   [] ; else do nothing
   if
   inc ;; p++
  ]
  while 
#+end_src

#+RESULTS:
#+begin_src kcats
[[type error] [asked [association]] [reason "type mismatch"] [unwound [update swap [8 10] [wrap [[]] update swap] step swap inc [swapdown clone * >] shield [[wrap lookup] [swapdown clone clone * sink [inc] dip [range] shield [dec sink drop] dipdown swapdown [wrap [[]] update swap] step swap] [] if inc [swapdown clone * >] shield] loop]]] [[]] [6] 2 [true true true true [] true true true true true] 10
#+end_src

impl of 'repeat'
#+begin_src kcats
true 10 [] sink [wrap [put] join] dip times
#+end_src

#+RESULTS:
: [true true true true true true true true true true]

#+begin_src kcats
true 10 [] sink [wrap [put] join] dip times
#+end_src

#+RESULTS:
: [true true true true true true true true true true]

#+begin_src kcats :results code
     [] [[true] 15 times] inject
     2 swap ;; p a
     [clone clone *] dip swap ;; p^2 a p
     [[[count] shield] dip swap [<] shielddown] ;; b p^2 a p  
     [[wrap [drop []] update] shield ;; do the update 
      float drop sink [+] shielddown swapdown] ;; 
     ;while
#+end_src

#+RESULTS:
#+begin_src kcats
true 4 [true true true true true true true true true true true true true true true] 2
#+end_src

How do we write this code? Generally, how do we decide what order things go on the stack?

It looks like the array of bools is the main piece of data here, that
is used throughout the algorithm. The other commonly used variable is
p, the one that's incremented. I think probably p should remain on
top. The outermost loop needs to know when to stop, and that needs to
compare to num. That can go on the bottom.

The inner loop uses i. That should probably replace p on top when in use.
So it should be =[p a]= and later =[i a p]=.

Now that =lingo= exists, maybe should also write =let= for variables
(where the values are evaluated before updating the dictionary)?  Also
these aren't actually "variables" because you can't change the value,
without an inner =let=.

Actually this is probably best implemented in two parts:
+ a word that takes a set of bindings and evaluates the values,
  leaving a map of word to value
+ a word that takes the map above and inserts it into the
  dictionary. I think =lingo= does this already.

let's try to write the former here. I think we need =map-values= type of
thing here, which requires treating a map as a list.

#+begin_src kcats

#+end_src
#+begin_src kcats
  [[[a [+ 5 6]]
    [b [- 100 8]]]
   [a b +]
   let] 

#+end_src

** Prime factors
#+BEGIN_SRC kcats :results code
8

[] swap 2

[/ 2 >=]
[[mod zero?]
  [clone sink [put] dipdown / 2]
  [inc]
  if]
while

drop put
#+END_SRC

#+RESULTS:
#+begin_src kcats
[2 2 2]
#+end_src

** bidirectional comms from a socket
#+begin_example kcats
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; assembled
 [[type ip-port]
  [address "localhost"]
  [port 9988]] ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 assemble] ;; receive
#+end_example
** Write string to a file
#+begin_example kcats
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_example
** Search the dictionary
#+BEGIN_SRC kcats :results code
  dictionary ;; put the dictionary of all words onto the stack as key value pairs
  [second ;; the value of one of those pairs
   [spec] lookup ;; look up the spec field
   first ;; the input part of the spec
   [program] =] ;; is it taking a single input, a program?
  filter ;; filter the dictionary using the above criteria
  [first] map ;; of what remains, just keep the key (which is the word itself)

  ;; when we run this, we get
  ;;[[shield execute assert]]
  ;; which are the words in the dictionary that take just a program as
  ;; input.
#+END_SRC

#+RESULTS:
#+begin_src kcats
#+end_src
** Copy data from one file to another

#+begin_src kcats
  [[file "/tmp/bar"]] pipe-in
  [[file "/tmp/foo"]] pipe-out 
  [put] step
#+end_src

#+begin_src kcats :results code
  "/tmp/foo" "/tmp/bar"
  pair [[] [file] float assign] map ;; make file descriptors for both
  take pipe-out
  swap unwrap pipe-in
#+end_src

#+RESULTS:
#+begin_src kcats
[[unwound [[type] unwrap = [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[first second] [first first]] unwrap branch [[[[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first swap drop [[[[association] unwrap]]] unwrap swap [[]] unwrap or [[[[nothing?] shield] dip swap [or] shielddown] [] [[take swap [[execute] shielddown] dip swap] dip or] [execute] recur] execute swap drop swap drop [file] unwrap = [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[[[file "/tmp/foo"]] [[[file "/tmp/bar"]]]]] unwrap evert first [[value file-out] [[[[type [ip-port] unwrap =] [clone [port] lookup [[address] lookup] dip serversocket]] [[list?] [+kcats.pipe/->filled]]] decide]] unwrap branch swap unwrap pipe-in]] [type error] [reason "type mismatch"] [actual [[file "/tmp/foo"]]] [asked [list]] [handled true]] [[[file "/tmp/bar"]]]
#+end_src
