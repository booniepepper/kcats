# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to express short
  programs. You can't write just 1 line of C++ or even python. But you
  will be able to write meaningful kcats expressions that are just a
  few words, and be able to put them into an application to get it to
  do what you want. While typical applications are menu-driven, kcats
  based applications will be message-driven, where a message is some
  words sent to a running program. 
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just values (numbers,
words, text, true/false) and quotation marks. No other symbols - no
periods, exclamation points, semicolons, equals, plusses, ampersands,
or asterisks.

Quotations are marked with square brackets, those are the only two
symbols that carry any meaning. 
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as input,
then the resulting stack afterward (both the before and after stack
are surrounded with square braces):

#+BEGIN_EXAMPLE
[true ☯] [false]
[false ☯] [true]
#+END_EXAMPLE

In the example without knowing in advance what the =☯= symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Powerful
The language should allow the user to express himself succinctly and
without a lot of ceremony or repetition.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
The language should be well positioned to handle various types of
programming tasks, including numerical computation, API client/server,
networking applications, machine learning, etc.

** Make tool development as easy as possible
+ Debuggers
+ IDEs

Wherever possible, tooling should be baked into the language.
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put
=1= onto the stack. Then we put =2= onto the stack (so that =2= is on
top and =1= is beneath it). Then we put the word =add= onto the stack
and it will consume the =2= and the =1= and replace them with the sum,
which is =3=.
#+begin_example
1 2 add
=> 3
#+end_example

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add =1=
and =2= (leaving =3= on the stack), and then put =5= and =multiply= on
the stack (which consumes the =5= and =3=, leaving =15=):

#+begin_example
1 2 add 5 multiply
=> 15
#+end_example

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 add 5 multiply 
            1 | 2 add 5 multiply 
          1 2 | add 5 multiply
            3 | 5 multiply
          3 5 | multiply
           15 |  
#+end_example

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.
#+begin_example
[1 2 3] [4 5] join
=> [1 2 3 4 5]
#+end_example

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [multiply add] execute
                    4 | 5 6 [multiply add] execute
                  4 5 | 6 [multiply add] execute
                4 5 6 | [multiply add] execute
 4 5 6 [multiply add] | execute
                4 5 6 | multiply add
                 4 30 | add
                   34 |
#+end_example
Note that, when =multiply add= gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =multiply add= would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_example
4 5 6 [add] [multiply] join execute
=> 34
#+end_example

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote, a message being
passed along and not acted upon until it reaches the recipient.
* Implementations
+ [[file:prototype.org::*Prototype implementation][Prototype implementation]]
+ [[file:production.org::*Production implementation][Production implementation]]
* Tools
** Debugging
*** Trace analyzer
**** Overview
We can trace the execution of any program already (see [[Printing]] and
=before-step= option for evaluation). But once we have the trace
output it can be huge and difficult to find the place where things
went wrong.

We can apply a debugger after the fact, just using the trace output -
it contains all the data about what happened. We can do typical debug
operations like =step into=, =step over=, =breakpoint= etc.

**** Emacs lisp
#+begin_src emacs-lisp
;; Some functions to move around in a buffer containing
;; kcats trace output

(require 'parseedn 'parseclj-alist)

(setq kcats.trace/stack-expression-splitter :.)

(defun kcats.trace/split-line
    (parsed-line)
  (let ((splitter-pos (seq-position parsed-line kcats.trace/stack-expression-splitter)))
    (list (seq-subseq parsed-line 0 splitter-pos)
	  (seq-subseq parsed-line (1+ splitter-pos)))))

(defun kcats.trace/parse-current ()
  (interactive)
  (let ((l (thing-at-point 'line t)))
    (with-temp-buffer
      (insert l)
      (goto-char (point-min))
      (parseedn-read `((object . ,#'identity))))))

(defun kcats.trace/expression-depth ()
  (interactive)
  (length (first (kcats.trace/split-line (kcats.trace/parse-current)))))

(defun kcats.trace/step-over-forward ()
  (interactive)
  (let* ((starting-depth (kcats.trace/expression-depth))
	 (current-depth starting-depth)
	 (lines-unmoved 0))
    (while (and (>= current-depth starting-depth)
		(= lines-unmoved 0))
      (setq lines-unmoved (forward-line 1))
      (setq current-depth (kcats.trace/expression-depth))))
  (search-forward " :. "))

(defun kcats.trace/read-lexicon
    ()
  (beginning-of-buffer)
  (setq kcats.trace/lexicon (parseedn-read `((object . ,#'identity)))))

;; Why is there no "step-over-backward"? Because lots of words can end
;; on the same line, we don't know which one we want to search
;; backward for the beginning of. If you are stepping forward through
;; execution and you go too far, use `point-stack-pop' to return to
;; the last place you were.

;; Why is there no step-out? There is no function call stack. We don't
;; know which function we're currently executing, so we can't tell
;; when we've finished it.
#+end_src

#+RESULTS:
: kcats\.trace/step-over-forward

** Developing
*** Emacs mode
#+begin_src emacs-lisp
(defface kcats-brackets 
  '((((class color)) (:foreground "DimGrey" :weight bold)))
  "kcats brackets" :group 'faces)
(defface kcats-stackop 
  '((((class color)) (:foreground "LightGreen" :inherit 'font-lock-keyword-face)))
  "kcats stack manipulation operation" :group 'faces)

(defconst kcats-font-lock-keywords
      `(("\\[\\|\\]" 0 'kcats-brackets)
	(";;.*" 0 'font-lock-comment-face)
	(,(regexp-opt '("swap" "swapdown" "discard" "sink" "float" "clone" "snapshot" "evert") 'words) . (0 font-lock-builtin-face))
	(,(regexp-opt '("true" "false" "[]") 'words) . (0 font-lock-keyword-face))
        (,(regexp-opt '("first" "second" "pack" "unpack" "step" "filter"
			"map" "count" "join" "rest" "wrap" "unwrap" "reverse") 'words) . (0 font-lock-function-name-face))
	(,(regexp-opt '("execute" "dip" "dipdown" "shield" "shielddown" "shielddowndown" "inject"
			"loop" "while" "if" "branch" "recur" "times") 'words) . '(0 font-lock-preprocessor-face))
        ("#?\"" 0 'double-quote prepend)))

(add-hook 'kcats-mode-hook (lambda () (font-lock-add-keywords nil kcats-font-lock-keywords)))

(require 'smie) ;; indentation engine

(setq kcats-mode-syntax-table (let ((table (make-syntax-table)))
    ;; Initialize ASCII charset as symbol syntax
    (modify-syntax-entry '(0 . 127) "_" table)

    ;; Word syntax
    (modify-syntax-entry '(?0 . ?9) "w" table)
    (modify-syntax-entry '(?a . ?z) "w" table)
    (modify-syntax-entry '(?A . ?Z) "w" table)

    ;; Whitespace
    (modify-syntax-entry ?\s " " table)
    (modify-syntax-entry ?\xa0 " " table) ; non-breaking space
    (modify-syntax-entry ?\t " " table)
    (modify-syntax-entry ?\f " " table)
    ;; Setting commas as whitespace makes functions like `delete-trailing-whitespace' behave unexpectedly (#561)
    (modify-syntax-entry ?, "." table)

    ;; Delimiters
    (modify-syntax-entry ?\[ "(]" table)
    (modify-syntax-entry ?\] ")[" table)

    ;; Others
    (modify-syntax-entry ?\; "<" table) ; comment start
    (modify-syntax-entry ?\n ">" table) ; comment end
    (modify-syntax-entry ?\" "\"" table) ; string
    (modify-syntax-entry ?\\ "\\" table) ; escape

    table))

(define-derived-mode kcats-mode fundamental-mode "kcats"
  "major mode for editing kcats."
  (set-syntax-table kcats-mode-syntax-table)
  (setq-local comment-start ";") ;; try ";;"
  (setq-local comment-end "")
  
  (smie-setup nil (lambda (method arg)
		    (when (eq method :list-intro)
		      t)))
  (setq font-lock-defaults '(kcats-font-lock-keywords)))

(add-to-list 'auto-mode-alist '("\\.kcats\\'" . kcats-mode))
(defun my-restart-kcats-mode ()
  (interactive)
  (let ((kcats-mode-hook nil))
    (normal-mode)))
#+end_src

#+RESULTS:
: my-restart-kcats-mode

* Tasks
** DONE Make a reader for the language
needs to support comments. clojure reader probably sufficient?
** DONE stdlib in a separate kcats file
** DONE Nested envs no longer need to convert back and forth
** INPROGRESS More support for nested/related envs
Debuggers, spawning, ingesting etc
** DONE Native spec
Write spec in terms of predicates that return true if what's on the
stack is valid for the word. Probably not easy to get an explanation
as detailed as clojure.spec, but most of the specs should be very
simple list/number/etc.
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?
** TODO Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
* Notes
** Nested env Runtime structure
How do environments that create new environments control execution?

There could be a top level runtime that controls all the environments
(runs them in different threads, etc)

Or it could just be fully programmable where the entry-point env is
responsible for doing whatever it needs. 

The latter seems like the way to go, but what's the control mechanism?
I think threading a separate concern from how an env is executed (as
in, in a debugger etc)

A threadpool is probably fine, futures would probably do it, at least
as a first pass. But there won't be any top level "show me all the
environments" which would be super handy for use in an IDE. One way to
handle this would be - for any env that needs to send messages home to
some IDE, inherit that behavior from its parent and have the top level
env do that. However then there's the matter of how things like
breakpoints etc would be communicated down to where they're needed.

It's important to be able to distinguish between envs whose purpose is
to do the actual job and those that are part of the execution setup
(envs whose only job is to run other envs, say with logging or
debugging). It's kind of hard have a library that introduces a
hierarchy of envs and then still allow the user to debug it.
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+begin_src kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+end_src
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?


* Example programs
** Factorial
*** Recursive definition 
#+begin_src kcats :tangle no
10 
[fact [[clone 0 =]
       [discard 1]
       [clone dec fact *]
       if]]
inscribe
fact
#+end_src
*** Recursive with recur
#+begin_src kcats :tangle no
5
[clone 1 <=]
[]
[clone dec]
[execute *]
recur

5
[1]
[*]

#+end_src
*** Using range
#+begin_src kcats :tangle no
 10
 1 +
 2 swap
 range unpack
 [*] step
#+end_src
*** Plain loop
#+begin_src kcats :tangle no
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src
** Spawn child environments and pipe values back
#+begin_src clojure :tangle no
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[discard] dip ;; done with the pipe
+ ;; add numbers
#+end_src
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
 #+begin_src clojure :tangle no
 100 [0] [[1.0 swap /] dip +] primrec
 [100 0 swap 1 + 1 swap range [1.0 swap / +] step]
 #+end_src
** Primrec
#+begin_src clojure :tangle no
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
** Fibonacci
#+begin_example kcats
[40 [1 0] swap [[[+] shield] inject] times reverse]
#+end_example
** Prime numbers (sieve of eratosthenes)
#+begin_example

[1000 clone 2 swap range ;; all the numbers up to n
  [.+java.lang.Math/sqrt .+java.lang.Math/ceil .int 2] dip  ;; start counter at 2, stop at sqrt of n
  [ [=] dip swap ] ;; stop loop when the counter hits sqrt n
  [] ;; after loop, nothing left to do 
  [ [ [ [=] 
        [swap mod 0 = not]]
      [execute] any?] 
    filter ;; keep the counter but no multiples of it 
    [inc] dip] ;; increment counter
  [execute]
  recur
  [discard discard] dip] ;; drop the original args, just leaving the primes
#+end_example
** Prime factors
#+begin_example kcats
[300

     [] swap 2

     [/ 2 >]
     [ [mod 0 =]
       [clone sink [pack] dipdown / 2]
       [inc]
       if]
     while

     discard pack]
#+end_example
** bidirectional comms from a socket
#+begin_example clojure
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; assembled
 [[type ip-port]
  [address "localhost"]
  [port 9988]] ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 assemble] ;; receive
#+end_example
** Write string to a file
#+begin_example clojure
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_example
** Search the dictionary
#+begin_src kcats
[dictionary ;; put the dictionary of all words onto the stack as key value pairs
 [second ;; the value of one of those pairs
  [spec] lookup ;; look up the spec field
   first ;; the input part of the spec
   [program] =] ;; is it taking a single input, a program?
 filter ;; filter the dictionary using the above criteria
 [first] map] ;; of what remains, just keep the key (which is the word itself)

;; when we run this, we get
[[shield execute assert]]
;; which are the words in the dictionary that take just a program as
;; input.
#+end_src
