# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a stack-based programming language similar to Joy,
and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Goals
** Easy for a beginner programmer to learn
*** Use as few concepts as possible
The language should use as few concepts as possible. It may include

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Nested datatypes (lists, maps)
+ Functions
+ Channels

It will explicitly *not* use

+ Variables
+ User-defined Types (static or dynamic)
+ Classes
+ Loops
+ Lexical or dynamic scope rules
+ Macros
*** Easy to understand documentation
**** Documentation by example
By documenting by example only, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

Items inside square brackets [] are quotations.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
#+END_EXAMPLE


** Easy to implement
** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.
** Easy static analysis
* Definining some terms
:PROPERTIES:
:CUSTOM_ID: definitions
:END:
- stack :: A first-in, first-out structure. This is mainly where data
           the program needs to manipulate will be stored.
- aggregate :: A list of items, which can be interpreted either as
               data or executable code.
- program :: an aggregate intended to be executable.
- word :: causes the program to do something, usually taking some
          items from the top of the stack and using them to create new
          stack items. Some words may do nothing but put themselves on
          the stack.

- definition :: what exactly a word is supposed to do, exists either
                as inscrutable implementation in the base language,
                or in terms of other existing words.
- dictionary :: a list of words and their definitions.
- environment :: the entire state of the program, which generally
                 consists of a dictionary and one or more stacks.
- predicate :: a word that consumes stack items and leaves either true
               or false on the stack.
- channel :: A method to communicate between stacks. Values are put
             into channels on one stack, and emerge in another.
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library `expound` which gives easier
to understand error messages.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::boolean boolean?)
  (spec/def ::number number?)
  (spec/def ::string string?)
  (spec/def ::bytes bytes?)
#+END_SRC

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be aggregates, which we haven't specced yet. That's ok,
recursive specs are allowed. Aggregates contain items, and items
can also be aggregates.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::item
    (spec/or :aggregate ::aggregate
             :boolean ::boolean
             :number ::number
             :string ::string
             :bytes ::bytes
             :word ::word))
#+END_SRC

Now we'll spec an aggregate, which is just a list. We'll use
clojure's vectors (which are indexed lists). We'll also spec out
programs, which are aggregates but intended to be executed (otherwise
there is no difference).

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::aggregate (spec/coll-of ::item :kind vector?) "aggregate?")
  (expound/def ::program ::aggregate)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::word symbol? "word?")

  (spec/def ::axiom-definition (spec/keys :req [::fn ::spec]))
  (spec/def ::program-definition (spec/keys :req [::fn ::definition]))

  (spec/def ::dictionary (spec/map-of ::word (s/or ::axiom-definition
                                                   ::program-definition)))
#+END_SRC

Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

Since a stack is a list of items, we need to also define what a "stack
item" is - it's any of the types we've specced up until now.
#+BEGIN_SRC clojure :tangle src/kcats/core.clj

  (spec/def ::stack (spec/coll-of ::stack-item
                                  :kind list?))
#+END_SRC

Next we'll spec what an Environment is - it's currently just a
dictionary and a stack put together. Later we might allow multiple stacks.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::environment (spec/keys :req [::stack ::dictionary]))
#+END_SRC
** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a [[#definitions][program]]. First we can say that to evaluate a program, we
will evaluate each item in the program in turn, and update the
environment each time.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (declare eval-item) ;; we'll define this later

  (def eval (partial reduce #'eval-item))
#+END_SRC

Now, we need to define =eval-item=. To evaluate an item, we will take
an environment and item as input, do some operation on the
environment, and return an updated environment.

To decide what operation to do, we'll first look at the item's
type. For example, basic types like numbers, byte arrays and strings
will simply be pushed onto the stack and there's nothing further to do
to evaluate that item.

We'll also define what we mean by "push" - add the item to the top of
the stack.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defmulti eval-item
    "Evaluate one item in the given environment. A single step in a
    program's execution."
    (fn [env item]
      (type item)))

  (defn- push [env item]
    (update env :stack conj item))

  (defmethod eval-item Number [env item]
    (push env item))

  (defmethod eval-item String [env item]
    (push env item))

  (defmethod eval-item Boolean [env item]
    (push env item))

  ;; PersistentVector is the clojure type for an aggregate
  (defmethod eval-item clojure.lang.PersistentVector [env item]
    (push env item))

  (defmethod eval-item (Class/forName "[B") [env item]
    (push env item))
#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  ;; Symbol is the underlying clojure type for words
  (defmethod eval-item clojure.lang.Symbol [env word]
    (let [{f :fn spec :spec} (-> env :dict word)]
      (when spec
        (spec/assert spec (:stack env)))
      (if f
        (f env)
        (push env word))))
#+END_SRC
