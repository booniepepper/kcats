# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Programming languages are daunting for beginners. So much so that the
vast majority of people are simply driven away, to remain completely
reliant on others to get a machine to do what they want.

Programming languages are full of arcane symbols and jargon. Does
anyone who's not a programmer know what "!" means in a program? Or "&"
or "*"? Do they know what a "subclass" is, or a "bean", or a "lexical
scope"? It gets even more arcane with terms like "monad", or "thunk".

While it's not possible to teach programming without introducing new
concepts, it is possible to reduce the number of concepts to an
approachable level, and create a language that's even more expressive
than popular languages like python.

In addition, being able to write tiny programs to tweak behavior is
very valuable, and almost entirely missing from modern computing. For
example, is it that difficult to tell a smartphone, "set alarm for 6am
but only if weather service says it's not raining". It shouldn't
be. But good luck finding an alarm clock app that lets you add your
own simple logic. Modern apps are built with menus decided by
developers - if you want anything that's even a slight variation of
what's on the menu, forget it. You're at their mercy.

Kcats is intended to help solve this problem by being what's "under
the hood" - a language a user can more easily understand and modify
himself. It's not that entire applications need to be written in
kcats, just the user-facing parts.
* Goals
** Easy for a beginner programmer to learn
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

Items inside square brackets [] are quotations.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
false â˜¯ ðŸ’­ true
#+END_EXAMPLE

In the example without knowing in advance what the â˜¯ symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Easy static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put 1
onto the stack. Then we put 2 onto the stack (so that 2 is on top and
1 is beneath it). Then we put the word =add= onto the stack and it
will consume the 2 and the 1 and replace them with the sum, which
is 3.
#+begin_example
1 2 add
=> 3
#+end_example

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add 1
and 2 (leaving 3 on the stack), and then put 5 and =multiply= on the
stack (which consumes the 5 and 3, leaving 15):

#+begin_example
1 2 add 5 multiply
=> 15
#+end_example

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 add 5 multiply 
            1 | 2 add 5 multiply 
          1 2 | add 5 multiply
            3 | 5 multiply
          3 5 | multiply
           15 |  
#+end_example

When there is nothing left to the right of the =|=, the program is
finished and the result is what is left on the stack (in this case
15).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.
#+begin_example
[1 2 3] [4] join
=> [1 2 3 4]
#+end_example

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a "program that looks like a list" is
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [multiply add] execute
                    4 | 5 6 [multiply add] execute
                  4 5 | 6 [multiply add] execute
                4 5 6 | [multiply add] execute
 4 5 6 [multiply add] | execute
                4 5 6 | multiply add
                 4 30 | add
                   34 |
#+end_example
Note that, when =multiply add= gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =multiply add= would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_example
4 5 6 [add] [multiply] join execute
=> 34
#+end_example

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote. If you said to Bob,
"Tell Alice 'bring your tennis racket'", Bob hears "bring your tennis
racket" but he knows that isn't meant for him, it's just a message to
be passed along to Alice. Similarly, when you put a program on the
stack, it's a message to be passed on now, and perhaps acted on later.
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Base Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library =expound= which gives easier
to understand error messages.

#+BEGIN_SRC clojure
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval test]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

What's important here is that we have some basic value types. Values
are stateless - they can be sent over a wire to some remote machine
without losing any meaning (the number 5 is always the number
5). 

There is only one common type in the system that has state (and
therefore would lose meaning being sent to a remote machine): a
pipe. See [[*Pipes][this later section]] for more detail. Kcats allows other
stateful things on the stack (like java objects, clojure atoms etc)
but best practice is that they should only be there temporarily,
usually during the construction of a pipe[fn:2].

#+BEGIN_SRC clojure
(expound/def ::boolean boolean?)
(expound/def ::number number?)
(expound/def ::string string?)
(expound/def ::bytes bytes?)
(expound/def ::integer integer?)
#+END_SRC

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be list, which we haven't specced yet. That's ok, recursive
specs are allowed. Lists contain items, and items can be lists.

Values are a particular kind of item, which is what most =words= will
operate upon. A value list is one where all the contents are
values.
#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(expound/def ::value
  (spec/or :value-list ::value-list
           :boolean ::boolean
           :number ::number
           :string ::string
           :bytes ::bytes
           :word ::word))

(expound/def ::item (constantly true))
#+END_SRC

Now we'll spec a list. We'll use clojure's vectors (which are indexed
lists). We'll also spec out programs, which are lists but intended to
be executed (otherwise there is no difference).

#+BEGIN_SRC clojure
  (expound/def ::list (spec/coll-of ::item :kind vector?) "list?")
  (expound/def ::value-list (spec/coll-of ::value :kind vector?) "value-list?")
  (expound/def ::program ::list)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure
(def word? symbol?)
(expound/def ::word word?)

(expound/def ::axiom-definition (spec/keys :req [::fn ::spec]))
(expound/def ::program-definition (spec/keys :req [::definition]))

(expound/def ::dictionary (spec/map-of ::word
                                       (spec/or :axiom ::axiom-definition
                                                :user-defined ::program-definition)))
#+END_SRC
Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

An expression is a stack too, but it represents words waiting to be
executed - parts of the program that haven't run yet. In kcats, the
program modifies itself heavily, so it is constantly adding pieces to
the expression.
#+BEGIN_SRC clojure
(def stack? (every-pred (complement indexed?) sequential?))

(expound/def ::stack (spec/coll-of ::item
                                   :kind stack?))

(expound/def ::expression (spec/coll-of ::item
                                        :kind stack?))

#+END_SRC

Next we'll spec what an Environment is - it's just a dictionary,
stack, and expression put together.

#+BEGIN_SRC clojure
  (expound/def ::environment (spec/keys :req [::stack ::dictionary ::expression]))
#+END_SRC

Finally, we'll make a bit of syntax for expressing what a particular
word needs on the stack.

#+begin_src clojure
;; since we'll commonly be defining specs for a stack, we'll nearly
;; always not care about anything below a certain depth, so let's make
;; a macro that encapsulates that.
(defmacro stack-spec
  [& args]
  `(spec/cat ~@args
             :others (spec/* ::item)))
#+end_src

[fn:2] There are some pipes that may be technically values (think of a
pipe that produces the infinite sequence 1,2,3...). You could send
that somewhere else, as long as you include what number it last
produced. But you can't send files or sockets somewhere else (they're
pointers to real world resources that may be different or nonexistent
somewhere else). Discerning between the two may be a future feature.

** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a program. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do and we return the
last environment.

#+BEGIN_SRC clojure 
(declare eval-step) ;; we'll define this later

(defn eval
  ([{:keys [max-steps before-step]} env]
   (let [eval-step (if before-step
                     (comp eval-step before-step)
                     eval-step)]
     (loop [{::keys [expression] :as env} env
            step-count 0]
       (if (or (not (seq expression)) ;; nothing left to run
               (and max-steps (>= step-count max-steps)))
         env
         (recur (eval-step env) (inc step-count))))))
  ([env]
   (eval {} env)))

#+END_SRC

Now, we define =onto-stack=, which says what we do to put an item onto
the stack. Simple values like numbers, strings and undefined words,
just go straight onto the stack with no changes. This is the default
and we'll handle everything else as a special case.

#+BEGIN_SRC clojure
(defmulti onto-stack
  "Evaluate one item in the given environment. A single step in a
  program's execution."
  (fn [{[item] ::expression}]
    (type item)))

(defmethod onto-stack :default
  [{[item & others] ::expression :as env}]
  (-> env
      (assoc ::expression others)
      (update ::stack conj item)))
#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

We'll include handling for calling down into the platform language
directly. There will be syntax for calling clojure functions and java
methods as if they are kcats words.

We'll also specify here what a step of evaluation is - it looks at the
next item in the expression. If it has a definition, it's replaced
with its definition. Otherwise it's put onto the stack.

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)
(require '[clojure.string :as string])

(defn invoke*
  [{[word & others] ::expression
    ::keys [dictionary stack]
    :as env}]
  {::stack
   (let [[_ arity fn-name] (->> word str (re-find #"(\.+)(.*)\.?"))
         [args others] (split-at (count arity) stack)
         args (reverse args)] ;; due to stacking reversing the args previously
     (conj others
           (cond
             (not fn-name) word

             (.endsWith fn-name ".") ;; java constructor
             (clojure.lang.Reflector/invokeConstructor
              (Class/forName (->> fn-name
                                  count
                                  dec
                                  (subs fn-name 0)))
              (into-array Object args))

             (and (.startsWith fn-name "+")
                  (.contains fn-name "/")) ;; static method
             (let [[clazz method] (-> fn-name
                                      (subs 1)
                                      (string/split #"/"))]
               (clojure.lang.Reflector/invokeStaticMethod clazz method
                                                          (into-array Object args)))
             
             (.startsWith fn-name "+") ;; instance method
             (clojure.lang.Reflector/invokeInstanceMethod
              (last args)
              (subs fn-name 1)
              (into-array Object (butlast args)))

             ;; clojure function
             (some-> fn-name symbol resolve) (-> fn-name
                                                 symbol
                                                 resolve
                                                 (apply args))
             :else (throw (Exception. (str "Cannot resolve platform word: " word))))))
   ::expression others
   ::dictionary dictionary})

(defmethod onto-stack clojure.lang.Symbol [{[word & others] ::expression
                                            ::keys [dictionary stack]
                                            :as env}]
  (let [{f ::fn spec ::spec} (dictionary word)]
    (when spec
      (spec/assert spec stack))
    (cond
      f (f (update env ::expression rest)) ;; drop this word now that we've used it
      :else (invoke* env))))

(defn definition
  "Returns the definition of an item, if it's a word defined in terms
  of other words"
  [{::keys [dictionary] :as env} item]
  (some-> dictionary (get item) ::definition))

(defn eval-step
  "Evaluate one step in the environment."
  [{[next-item & items :as expression] ::expression ::keys [stack dictionary] :as env}]
  (if-let [d (definition env next-item)]
    (assoc env ::expression (concat (list* d) items)) ;; replace item with definition
    
    ;; eval the thing onto the stack
    (onto-stack env)))
 
(defn print-env
  "Prints the expression/stack and then return env"
  [{::keys [expression stack] :as env}]
  (apply pr (reverse expression))
  (print " . ")
  (apply prn stack)
  env)
#+END_SRC

** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(defn f-stack
  "Apply nitems from stack to f, put result back on stack after
   dropping nitems-drop."
  ([nitems-use nitems-drop f]
   (fn [env]
     (update env ::stack
             (fn [stack]
               (let [use (take nitems-use stack)
                     stack (drop nitems-drop stack)]
                 ;; items are reversed so that we can write code with arguments in
                 ;; the same order as we'd use in other langs, eg so that [2 1 >]
                 ;; -> true
                 ;;
                 ;; The top item in the stack would normally be the first
                 ;; arg, but that was the LAST arg written in the code.
                 (conj stack (apply f (reverse use))))))))
  ([nitems f]
   (f-stack nitems nitems f)))

(defn env-effect
  "Calls f with nitems from stack, it should return a pair (items to
  prepend to the expression, items to replace the nitems with)"
  [nitems f]
  (fn [{::keys [stack expression dictionary]}]
    (let [[a b] (split-at nitems stack)
          [new-expression-items new-stack-items] (apply f a)]
          {::stack (concat new-stack-items b)
           ::expression (concat new-expression-items expression)
           ::dictionary dictionary})))

(defmacro effect
  "Constructs a fn with given in args, whose body is out. That
  function body should return a pair (new-expression-items,
  new-stack-items)"
  [in out]
  `(env-effect ~(count in) (fn ~in ~out)))

(defmacro stack-effect
  "Takes a stack effect notation and turns it into a call to
  env-effect"
  [in out]
  `(env-effect ~(count in) (fn ~in [[] ~out])))
#+END_SRC

Kcats is not going to have a concept of =null= or =nil=. If we want to
express "nothing" we will use an empty list. We'll need some functions
to treat empty lists as clojure treats =nil=.

#+begin_src clojure
(def nothing [])

(defn nothing?
  [x]
  (= nothing x))

(defn nothing->nil
  "Returns argument unless it's a kcats 'nothing' (empty list), in
  which case it returns nil"
  [x]
  (if (nothing? x)
    nil
    x))

(defn nil->nothing
  "Returns argument unless it's nil, in which case it returns empty list"
  [x]
  (if (nil? x)
    nothing
    x))
#+end_src

Now we can go ahead and start filling out axiom words in our default
dictionary.

First we'll make some specs so we get a better error message when a
word doesn't get the stack arguments that it needs.

We'll also wrap a bunch of clojure functions that will be used
basically as-is in kcats.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(defonce core-words (atom {}))

(def arithmetic-words
  (into {} cat
        [(for [sym ['+ '- '/ '* '< '<= '> '>= 'min 'max 'quot 'rem 'mod]]
           [sym
            {::spec (stack-spec :x ::number
                                :y ::number)
             ::fn (f-stack 2 (resolve sym))}])
         (for [sym ['inc 'dec]]
           [sym
            {::spec (stack-spec :x ::number)
             ::fn (f-stack 1 (resolve sym))}])]))

;; need to implement `some` to respect empty list being falsey
(def predicates
  (into {} cat
        [(for [sym ['odd? 'even? 'sequential? 'zero? 'pos? 'neg?
                    'number? 'int? 'true? 'false?
                    'string? 'empty?]]
           [sym {::spec (stack-spec :x ::item)
                 ::fn (f-stack 1 (resolve sym))}])
         (for [sym ['starts-with? 'ends-with?]]
           [sym {::spec (stack-spec :subject ::item
                                    :object ::item)
                 ::fn (f-stack 2 (resolve sym))}])]))

(def axiom-words
  {'discard {::spec (stack-spec :a ::item)
             ::fn (stack-effect [a] [])
             ::examples '[[[1 2 3 discard] [2 1]]
                          [[1 2 3 [a b c] discard] [3 2 1]]]}
   'clone {::spec (stack-spec :a ::item)
           ::fn (stack-effect [a] [a a])
           ::examples '[[[1 2 3 clone] [3 3 2 1]]]}
   'swap {::spec (stack-spec :a ::item, :b ::item)
          ::fn (stack-effect [a b] [b a])
          ::examples '[[[1 2 3 swap] [2 3 1]]]}
   'swapdown {::spec (stack-spec :a ::item, :b ::item, :c ::item)
              ::fn (stack-effect [a b c] [a c b])
              ::examples '[[[1 2 3 swapdown] [3 1 2]]]}
   'rotate {::spec (stack-spec :a ::item, :b ::item, :c ::item)
            ::fn (stack-effect [a b c] [c a b])}
   'execute {::spec (stack-spec :p ::program)
             ::fn (effect [p] [p []])
             ::examples '[[[[1 2 +] execute] [3]]
                          [[2 [+] 4 swap execute] [6]]]}
   'dip {::spec (stack-spec :p ::program
                            :a ::item)
         ::fn (effect [p a] [(conj (vec p) a) []])
         ::examples '[[[1 8 [inc] dip] [8 2]]]}
   'dipdown {::spec (stack-spec :p ::program
                                :a ::item
                                :b ::item)
             ::fn (effect [p a b] [(conj (vec p) b a) []])
             ::examples '[[[1 2 3 [inc] dipdown] [3 2 2]]]}
   'wrap {::spec (stack-spec :a ::item)
          ::fn (stack-effect [a] [[a]])
          ::examples '[[[1 wrap] [[1]]]]}
   ;; TODO: possible security issue with unwrap and bare words on the
   ;; stack: It's possible for malicious code to squat on a word that
   ;; was intended to be data, and not an action word, causing
   ;; unexpected behavior. May want to reconsider whether undefined
   ;; words should be placed onto the stack unquoted.
   'unwrap {::spec (stack-spec :l ::list)
            ::fn (stack-effect [l] l)
            ::examples '[[[[1] unwrap] [1]]]}
   'inscribe {::spec (stack-spec :word ::word
                                 :definition ::program)
              ::fn (fn [{[word word-def & others] ::stack
                         ::keys [expression dictionary]}]
                     {:pre [(-> word name (.startsWith ".") not)]}
                     {::stack others
                      ::expression expression
                      ::dictionary (assoc dictionary word {::definition word-def})})
              ::examples '[[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}
   'describe {::spec (stack-spec :word ::word)
              ::fn (fn [{[word & others] ::stack dict ::dictionary :as env}]
                     (let [dfn (-> dict (get word) ::definition)]
                       (if dfn
                         (assoc env ::stack (conj others dfn))
                         nothing)))}
   'branch {::spec (stack-spec :false-branch ::program
                               :true-branch ::program
                               :condition ::item)
            ::fn (effect [f t b]
                         [(if (nothing->nil b) t f) []])
            ::examples '[[[5 true [3 *] [4 +] branch] [15]]
                         [[6 false [3 *] [4 +] branch] [10]]]}
   'step {::spec (stack-spec :p ::program
                             :a ::list)
          ::fn (effect [p [agg-item & agg-rest :as agg]]
                       (if (seq agg)
                         [(cond-> ['execute]
                            (seq agg-rest) (concat [(vec agg-rest) p 'step]))
                          [p agg-item]]
                         [[] []]))
          ::examples '[[[1 [2 3 4] [*] step] [24]]
                       [[1 [] [*] step] [1]]]}
   'recur {::spec (stack-spec :rec2 ::program
                              :rec1 ::program
                              :true-branch ::program
                              :false-branch ::program)
           ::fn (effect [rec2 rec1 then pred]
                        ['[if]
                         [(vec (concat rec1 [[pred then rec1 rec2 'recur]] rec2))
                          then pred]])
           ::examples '[[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}
   'loop {::spec (stack-spec :p ::program
                             :flag ::item)
          ::fn (effect [p f]
                       [(when (nothing->nil f)
                          (concat p [p 'loop]))
                        []])
          ::examples '[[[10 true [-2 * clone 50 <] loop] [160]]]}
   'pack {::spec (stack-spec :x ::item
                             :l ::list)
          ::fn (stack-effect [x l] [(conj (vec l) x)])
          ::examples '[[[[] 1 pack] [[1]]]
                       [[[1 2 3] 4 pack] [[1 2 3 4]]]]}
   'unpack {::spec (stack-spec :l ::list)
            ::fn (stack-effect [[l & others]] [l (vec others)])
            ::examples '[[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}
   'join {::spec (stack-spec :l ::list
                             :m ::list)
          ::fn (f-stack 2 (comp vec concat))
          ::examples '[[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}
   'range {::spec (stack-spec :from ::integer
                              :to ::integer)
           ::fn (f-stack 2 (comp vec range))
           ::examples '[[[1 5 range] [[1 2 3 4]]]]}
   'evert {::spec (stack-spec :l ::list)
           ::doc "Turns the list on top of the stack inside out (puts
                  the list as the rest of the stack, and vice versa)"
           ::fn (fn [{[l & others] ::stack ::keys [dictionary expression]}]
                  {::stack (apply list (vec others) l)
                   ::expression expression
                   ::dictionary dictionary})
           ::examples '[[[1 2 3 [4 5 6] evert] [[3 2 1] 4 5 6]]]}
   'some? {::spec (stack-spec :a ::item)
           ::fn (f-stack 1 (comp some? nothing->nil))}
   'every? {::spec (stack-spec :p ::program
                               :l ::list)
            ::fn (fn [env]
                   #_(update-stack (fn [[p a & others :as stack]]
                                     (->> a
                                          (every? #(leaves-true? (with-stack env (conj others %)) p))
                                          (conj others)))
                                   env))}
   'intersection {::spec (stack-spec :l ::list
                                     :m ::list)
                  ::fn (f-stack 2 (fn [x y]
                                    (into []
                                          (clojure.set/intersection
                                           (into #{} x)
                                           (into #{} y)))))}})
(swap! core-words merge
       axiom-words
       arithmetic-words
       predicates)

(defn default-env
  ([expression]
   {::stack '()
    ::dictionary @core-words
    ::expression expression})
  ([]
   (default-env '())))

(defn k
  "Run a program with the default env and return the result. Option to
  stop execution after `max-steps` if still unfinished, to prevent
  accidental infinite loops (for debugging purposes)"
  ([opts p]
   (::stack (eval opts (assoc (default-env) ::expression p))))
  ([p] (k {:before-step print-env} p)))

#+END_SRC

Next we can add a way to test that all the examples are working, so
that we notice any bugs as we're developing.

#+begin_src clojure
(in-ns 'kcats.core)
(require '[clojure.test :as test])
(defn test
  "Run through all the examples in the default env and make sure they
  work. Takes optional list of words to test"
  ([words]
   (doseq [[word {::keys [examples]}] (if words
                                        (select-keys @core-words words)
                                        @core-words)]
     (test/testing (str word)
       (doseq [[program exp-stack] examples]
         (->> program
              (k {:max-steps 500})
              vec
              (= exp-stack)
              test/is)))))
  ([] (test nil)))
#+end_src

Next we can add some more words that are defined in terms of the
axiom words, or calling clojure functions.
#+begin_src clojure
;;TODO: Allow these words to be defined in a .kcats file and read in
;; natively. it would probably mean we can't use spec. But we could
;; allow program defs to include examples and other metadata. Might also
;; be nice to have unit testing be implemented in the language itself?
(in-ns 'kcats.core)
(def standard-words
  {'if {::spec (stack-spec :false-branch ::program
                           :true-branch ::program
                           :condition ::program)
        ::definition '[[execute] dipdown branch]
        ::examples '[[[5 [clone 5 =] [3 *] [4 +] if] [15]]
                     [[6 [clone 5 =] [3 *] [4 +] if] [10]]]}
   'primrec {::spec (stack-spec :rec1 ::program
                                :exit ::program
                                :data ::number)
             ::definition '[[execute] swap join ;; add execute to rec1 to be recur's rec2
                            [[discard] swap join] dip ;; add discard to exit condition
                            [[clone zero?]] dipdown  ;; put the condition on bottom
                            [[clone dec]] dip ;; add the r1
                            recur] ;; now it's generic recur
             ::examples '[[[5 [1] [*] primrec] [120]]]}
   '= {::spec (stack-spec :x ::item, :y ::item)
       ::definition '[..=]
       ::examples '[[[1 1 =] [true]]
                    [["hi" "hi" =] [true]]
                    [["hi" "there" =] [false]]
                    [[[] false =] [false]]
                    [[1 "hi" "hi" =] [true 1]]]}
   'count {::spec (stack-spec :l ::list)
           ::definition '[.count]
           ::examples '[[[["a" "b" "c"] count] [3]]]}
   'prepend {::spec (stack-spec :a ::item
                                :l ::list)
             ::definition '[wrap swap join]
             ::examples '[[[[1 2] 3 prepend] [[3 1 2]]]]}
   'inject {::spec (stack-spec :p ::program
                               :l ::list)
            ::doc "Inject the quoted program into the list below
                   it (runs the program with the list as its
                   stack).  Does not affect the rest of the stack."
            ::definition '[swap evert unpack dip evert]
            ::examples '[[[1 2 3 [4 5 6] [* +] inject] [[26] 3 2 1]]]}
   'snapshot {::spec (stack-spec)
              ::doc "Save the whole stack as a list on the stack"
              ::definition '[[] evert clone evert unwrap]
              ::examples '[[[1 2 3 snapshot] [[3 2 1] 3 2 1]]
                           [[snapshot] [[]]]]}
   'nullary {::spec (stack-spec :p ::program)
             ::doc "Runs program keeping stack items produced but
                    protects existing items from being consumed."
             ::definition '[[snapshot] dip inject first]
             ::examples '[[[1 2 3 [=] nullary] [false 3 2 1]]]}
   'first {::spec (stack-spec :l ::list)
           ::definition '[.first]
           ::examples '[[[[4 5 6] first] [4]]]}
   'second {::spec (stack-spec :l ::list)
            ::definition '[.second]
            ::examples '[[[[4 5 6] second] [5]]]}
   'bytes? {::spec (stack-spec :a ::item)
            ::definition '[.bytes?]}
   'string? {::spec (stack-spec :a ::item)
             ::definition '[.string?]}
   'getbytes {::spec (stack-spec :string ::string)
              ::definition '[.+getBytes]}
   'bytes {::spec (stack-spec :a ::item)
           ::definition '[[[[clone string?] [getbytes]]
                           [[clone bytes?] []]]
                          decide]}
   'map {::spec (stack-spec :p ::program
                            :l ::list)
         ::definition '[[snapshot [] swap] ;; save original stack, and
                        ;; add an empty list to
                        ;; hold results
                        dipdown ;; do this underneath the program and list
                        [[clone] dip wrap] ;; program snippet a to
                        ;; copy the original stack
                        ;; that we saved, will make
                        ;; new copy for each item
                        ;; in the list

                        swap pack ;; pack the map program into the
                        ;; partial program a above

                        ;; inject the map program into the stack copy,
                        ;; take the first item and pack it into the result list
                        [join inject first swap [pack] dip] 
                        join ;; add the program snippet b above to the
                        ;; snippet a, to get a program for 'step'
                        step ;; step through the above program, using
                        ;; the list as data
                        discard ;; we don't need the copy of the
                        ;; original stack anymore
                        ]
         ::examples '[[[[1 2 3] [inc] map] [[2 3 4]]]
                      [[1 [1 2 3] [+] map] [[2 3 4] 1]]
                      [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]]]}})

(swap! core-words merge standard-words)
#+end_src

** Logical operators
** Maps/associations
A simple implementation that works well for small lists: specify
associations as lists of pairs.

Then include some words that depend on this functionality.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(expound/def ::pair (spec/coll-of ::item :kind vector? :count 2))

(expound/def ::association-list (spec/coll-of ::pair
                                              :kind vector?))
;;TODO: axiom words should be separated
(def associative-words
  {'assign {::spec (stack-spec :item ::pair,
                               :alist ::association-list)
            ::fn (f-stack 2 (fn [alist [k v :as item]]
                              (let [i (.indexOf (mapv first alist) k)]
                                (if (= -1 i)
                                  (conj alist item)
                                  (assoc alist i item)))))
            ::examples '[[[[[a b] [c d]] [a x] assign] #_-> [[[a x] [c d]]]]
                         [[[[a b] [c d]] [e x] assign] #_-> [[[a b] [c d] [e x]]]]]}
   'lookup {::spec (stack-spec :key ::item
                               :map ::association-list)
            ::fn (f-stack 2 (fn [alist key]
                              (get (into {} alist) key [])))
            ::examples '[[[[[a b] [c d]] a lookup] [b]]
                         [[[[a b] [c d]] e lookup] [[]]]]}
   'decide {::spec (stack-spec :test-expr-pairs ::association-list
                               :other (spec/* ::item))
            ::doc "Takes a list of choices (pairs of test, program) and
            executes the first program whose test passes. if none
            pass, returns 'nothing'. Stack is reset between
            testing conditions."
            ::fn (fn [{[[[test expr :as first-clause]
                         & other-clauses]
                        & others] ::stack
                       ::keys [dictionary expression]}]
                   {::expression (if first-clause
                                   (concat [[test 'nullary] ;; run test resetting stack
                                            expr ;; the then
                                            [(vec other-clauses) 'decide] ;; the else
                                            'if]
                                           expression)
                                   expression)
                    ::stack (cond-> others
                              ;; if conditions are empty result is empty list
                              (not first-clause) (conj []))
                    ::dictionary dictionary})
            ::examples '[[[5 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]
                              [[true] ["something else"]]]
                           decide]
                          ["five" 5]]
                         [[9 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]
                              [[true] ["something else"]]]
                           decide]
                          ["something else" 9]]
                         [[9 [[[3 =] ["three"]]
                              [[5 =] ["five"]]
                              [[7 =] ["seven"]]]
                           decide]
                          [[] 9]]]}
   'type {::spec (stack-spec :alist ::association-list)
          ::definition '[[clone count 1 =] ;; if it's a single item
                         [first first] ;; the type is the key of that first item
                         [[type] unwrap lookup] ;; otherwise look up the key 'type'
                         if]
          ::examples '[[[[[foo 1]] type] [foo]]
                       [[[[type url] [value "http://foo.com"]] type] [url]]]}
   'value {::spec (stack-spec :alist ::association-list)
           ::definition '[[clone count 1 =]
                          [first second]
                          [[value] unwrap lookup]
                          if]
           ::examples '[[[[[foo 1]] value] [1]]
                        
                        [[[[type url] [value "http://foo.com"]] value]
                         ["http://foo.com"]]]}})

(swap! core-words merge associative-words)
#+END_SRC
** Methods
#+begin_src clojure
(swap! core-words merge
       {'addmethod {::spec (stack-spec :condition ::pair
                                       :word ::word)
                    ::definition '[[clone describe] dip ;; get definition of word beneath
                                        ; and keep an extra copy for later inscribe
                                   pack ;; new condition onto end of definition
                                   [rotate ;; new condition to 1st
                                           ;; position - TODO: note this
                                           ;; could fail if the def is
                                           ;; more than just an alist
                                           ;; and 'cond'.
                                    pack] ;; new condition onto end of conditions
                                   inject ;; the above program to run on the conditions
                                   swap inscribe ;; redefine word
                                   ]}})
#+end_src

** Nested Environments
*** Basics
Kcats environments are just data. We can manipulate an environment
within another environment to achieve various features:

+ A debugger (each evaluation step checks to see whether it should
  stop at a breakpoint etc)
+ Spawning copies of the same environment so that we can do things like
  map/filter/some etc (that require us to restore an environment to a
  previous state, and do another calculation with it)
*** Implementation
First let's spec what a nested environment looks like
#+begin_src clojure
  (in-ns 'kcats.core)
  (declare env->clj)

  (expound/def ::nested-environment
    (spec/and ::association-list #(->> % env->clj (spec/valid? ::environment))))
#+end_src

We'll need to move back and forth between clojure's idea of an
environment and the equivalent representation in kcats.

#+begin_src clojure
(in-ns 'kcats.core)

(defn env->clj
  "Convert an env from kcats format to clj"
  [e]
  (let [ec (into {} e)]
    {::stack (-> ec (get 'stack) list* (or '()))
     ::dictionary (merge core-words (into {}
                                          (for [[k v] (get ec 'dictionary)]
                                            [k {::definition v}])))
     ::expression (or (list* (get ec 'expression)) '())}))

(defn env->k
  "Convert an env from clj format to kcats"
  [e]
  [['stack (-> e ::stack vec)]
   ['dictionary (into {}
                      (for [[k {::keys [definition]}] (::dictionary e)
                            :when definition]
                        [k definition]))]
   ['expression (-> e ::expression vec)]])
#+end_src

Now we can define an axiom word that steps through a nested
environment's execution.

#+begin_src clojure
(in-ns 'kcats.core)
(swap! core-words merge
       {'eval-step {::spec (stack-spec :environment ::environment)
                    ::fn (f-stack 1 (comp env->k eval-step env->clj))}
        'spawn {::spec (stack-spec :expression ::list)
                ::fn (fn [{::keys [stack] :as env}]
                       ;;(print-env env)
                       (let [expr (first stack)]
                         (->> expr
                              default-env
                              (eval {:before-step print-env})
                              future))
                       (update env ::stack rest))}})
#+end_src
** Pipes
*** Basics
Pipes are a coordination construct - a way to get values from here to
there, when "there" is further away than a simple function call. In
that sense it "breaks" functional programming by introducing state,
but quite often real programs need to deal with state. That state
could just be something introduced by, and consumed by, the local
environment, or it could be received from another machine thousands of
miles away.

The interface is simple enough - we just need to be able to put values
into a pipe at one end, and take them off at the other. It's also
handy to know whether there's anything in the pipe or not, and whether
the pipe is "full" (nothing more will fit until something at the other
end is removed).

The program doesn't necessarily have access to both ends of the
pipe. For example, when sending data over a socket, the program has
access to the "in" end, but not the "out" (that's on a remote machine). 

#+begin_src clojure :tangle src/kcats/pipe.clj
(ns kcats.pipe
  (:require [kcats.core :as core]
            [clojure.spec.alpha :as spec]
            [expound.alpha :as expound])
  (:refer-clojure :exclude [take empty?])
  (:import [java.util.concurrent BlockingQueue ArrayBlockingQueue SynchronousQueue]))

(defprotocol Select
  (poll [pipe] "Returns a value if available, otherwise nil"))

(defprotocol In
  (put [pipe value] "Puts a value into the pipe, blocks if the pipe is full, returns value on success"))

(defprotocol Out
  (take [pipe] "Takes a value from the pipe, blocks if pipe is empty, returns the value"))

;; a protocol that just marks whether the pipe is generating values
;; itself. The reason to differentiate is that a self-contained pipe
;; can potentially be serialized and sent elsewhere without any loss
(defprotocol SelfContained)

;; some pipes are thin veneers on java concurrent objects

(extend-type BlockingQueue
  In
  (put [q value] (.put q value))
  Out
  (take [q] (.take q))
  Select
  (poll [q] (.poll q)))

(defn ->handoff []
  (SynchronousQueue.))
#+end_src

Now we can make some higher level functions that will actually be what
kcats primitives will be defined in terms of.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(def default-sleep 10)

(defn select
  "Takes a coll of pipes. Whichever one is non-empty first, return the
  pipe and the value that was in it."
  [pipes]
  (loop [[this-pipe & remaining-pipes] pipes]
    (if this-pipe
      (if-let [item (poll this-pipe)]
        ;; found it, return the pipe and value as a tuple
        [this-pipe item]
        (recur remaining-pipes))
      ;; everything empty, start over
      (do (Thread/sleep default-sleep)
          (recur pipes)))))
#+end_src

Now we can define a few different kinds of pipes, starting with simple
"local" types.
*** Standard Values
Passes values from in to out - similar to core.async or golang
channels.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defn ->buffered [buffer-size]
  (ArrayBlockingQueue. buffer-size))
#+end_src
*** Atoms
This is a pipe that when you take, always returns the last value
put. It's never full, whatever you put just overwrites what was there
before. It has to be initialized with a value, therefore it's also
never empty. It's functionally equivalent to a clojure atom and is
implemented in terms of one.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type clojure.lang.Atom
  In
  (put [a value] (reset! a value))
  Out
  (take [a] (deref a))
  Select
  (poll [a] (take a))
  SelfContained)

(defn ->atom
  "Creates a new atom pipe with initial value v"
  [v]
  (atom v))
#+end_src

*** Timeout
This is an (out) pipe that when you take, it will block for a
predefined period of time (decided when the pipe is created), and then
return the boolean value =true=.

The purpose of this kind of pipe is to use with =select= - where you
have a set of pipes and you want to take from whichever one is
non-empty first. You can include a timeout pipe in there to guarantee
that at least one of them will return something eventually.

#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(deftype Timeout [until-timestamp]
  Out
  (take [this] (let [t (- until-timestamp (System/currentTimeMillis))]
                 (when (pos? t)
                   (Thread/sleep t))
                 true))
  Select
  (poll [this] (or (> (System/currentTimeMillis) until-timestamp) nil)))

(defn ->timeout
  "Creates a new timeout pipe that waits t milliseconds and then
  returns a single value (true) from the pipe"
  [t]
  (->Timeout (+ (System/currentTimeMillis) t)))
#+end_src

*** Closing
Pipes need to be closed pretty often (eg there's no more bytes to be
read from a file, so we need to know when to stop waiting for more)
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defprotocol Close
  (close [pipe] "Closes the pipe from either end")
  (closed? [pipe] "Returns true if the pipe has been closed"))
#+end_src

*** Input/Output streams
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type java.io.InputStream
  Out
  (take [is]
    (let [buf (make-array Byte/TYPE 1024)
          bytes-read (.read is buf)]
      (if (= -1 bytes-read)
        (throw (Exception. "EOF on inputstream while reading"))
        (let [retbuf (make-array Byte/TYPE bytes-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [is] (take is))
  Close
  (close [is] (.close is))
  (closed? [is] (try (-> is .available (= 0))
                     (catch java.io.IOException ioe
                       true))))

(extend-type java.io.OutputStream
  In
  (put [os bs] (doto os (.write bs)))
  Close
  (close [os] (doto os (.flush) (.close)))
  (closed? [os] false))
#+end_src

*** Words
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(require '[clojure.java.io])

(expound/def ::in (partial satisfies? In))
(expound/def ::out (partial satisfies? Out))
(expound/def ::core/pipe (spec/or :in ::in
                                  :out ::out))

(swap! core/core-words merge
       {'atom {::core/spec (core/stack-spec :value ::core/item)
               ::core/fn (core/stack-effect [v] [(->atom v)])}
        'buffer {::core/spec (core/stack-spec :buffer-size ::core/integer)
                 ::core/fn (core/stack-effect [s] [(->buffered s)])}
        'timeout {::core/spec (core/stack-spec :timeout-ms ::core/integer)
                 ::core/fn (core/stack-effect [t] [(->timeout t)])}
        'handoff {::core/spec (core/stack-spec)
                  ::core/fn (core/stack-effect [] [(->handoff)])} 
        'select {::core/spec (core/stack-spec :pipes (spec/coll-of ::out))
                 ::core/fn (core/stack-effect [pipes]
                                              (let [[p v] (select pipes)]
                                                [v p pipes]))}
        'take {::core/spec (core/stack-spec :pipe ::out)
               ::core/fn (core/stack-effect [p] [(take p) p])}
        'put {::core/spec (core/stack-spec :value ::core/item
                                           :pipe ::in)
              ::core/fn (core/stack-effect [v p] [(doto p (put v))])}
        'close {::core/spec (core/stack-spec :pipe ::core/pipe)
                ::core/fn (core/stack-effect [p] (do (close p) [p]))}
        'pipe-in {::core/spec (core/stack-spec :obj ::item)
                  ::core/definition
                  '[
                    [[[type [ip-port] unwrap =]
                      [clone port lookup [address lookup] dip
                       ..java.net.Socket. 
                       .+getOutputStream]]
                     [[type [file] unwrap =]
                      [value
                       .clojure.java.io/file
                       .clojure.java.io/output-stream]]]
                    decide]}
        'pipe-out {::core/spec (core/stack-spec :obj ::item)
                   ::core/definition
                   '[
                     [[[type [file] unwrap =]
                       [value
                        .clojure.java.io/file
                        .clojure.java.io/input-stream]]]
                     decide]}
        'spit {::core/spec (core/stack-spec :contents ::core/item
                                            :target ::core/item)
               ::core/definition '[[pipe-in] dip bytes put close discard]}
        'slurp {::core/spec (core/stack-spec :target ::item)
                ::core/definition '[]}})
#+end_src
*** Notes
core.async has an out-of-band close message. Do we need that? Seems
handy but also adds complexity as it becomes an error condition trying
to put/take into a closed pipe, that would then need to be handled.

Seems acceptable to me that pipes are just there and if you want to
tell whoever's at the other end that you're done sending, just send
something that tells them that.

It might be nice for the receiver to be able to let the sender know
he's "hanging up", but I think that function is better handled at a
higher level of abstraction (something built on top of bidirectional
pipes, which is just two pipes with the sender and receiver swapped)
* Tasks
** TODO Make a reader for the language
needs to support comments. clojure reader probably sufficient?
** TODO stdlib in a separate kcats file
** TODO Nested envs no longer need to convert back and forth
** TODO More support for nested/related envs
Debuggers, spawning, ingesting etc
* Notes
** Instruction set
It might be prudent to define some low level words, and then define
the higher level words in terms of those words. Essentially trading
some performance for portability. Here's a stab at what some of the
low level words would be. We could refer to positions on the stack and
expression with an integer (positive = on stack, negative = on
expression)

- shift* items from the expression to the stack, or vice versa (neg),
  int argument. Oops the problem here is if you shift stuff from
  stack->expr whatever you shifted will get eval'd next, instead of
  what you probably wanted

- move* better than swap as you can specify what you're moving AND how
  far. This has the problem of needing to know how long the section of
  program is that you need to move things past. I'm not sure this is
  useful either, as moving things into the expression is not very useful
  
- exchange* items at the given locations (eg -1 1 swap would swap the
  top of the stack and top of the expression)

- swap* shorthand for 1 2 exchange* (swap the top two items)

- conj* the item on top of the stack into the agg just below it

- concat* the top n (or 2?) items (lists)

- execute* unwrap agg on ToS, move it into expr (to be eval'd)

- discard* get rid of items on the stack

- clone* duplicate items on the stack

- cleave* the env into two, execute the program on ToS on one of
  them, put result on other. drop the mutated env. -  see below

- booleans and* or* not*

- =* 

- branch*

- unwrap* - unwraps the list at position n

- inscribe*

- describe* 

Using this we can define =dip= like this (nope, does not work due to
neg shift being worthless)

#+BEGIN_EXAMPLE
  1 2 swap* -1 shift* conj*

  3 1 2 [* +] . dip
  3 1 [* +] 2 . -1 shift* conj*
  3 1 [* +] . 2 conj*
  3 1 [* + 2]  
#+END_EXAMPLE


ok how about this

#+BEGIN_EXAMPLE
  swap* conj* execute*

  3 4 2 5 [* +] . dip
  3 4 2 5 [* +] . swap* conj* execute*
  3 4 2 [* +] 5 . conj* execute*
  3 4 2 [* + 5] . execute*
  3 4 2 . * + 5
  3 8 . + 5
  11 . 5
  11 5
#+END_EXAMPLE

re cleave*, seems like there is some overlapping functionality
between parallelism and preserving the stack for things like
=nullary=. In both cases we're cloning the environment (or part of
it) so that multiple modifications don't conflict with each other.

The only difference is how we join the cloned stacks back together.

With nullary, we clone the env, run the program on the clone, take
the top of the stack and put it back on the original. throw the clone
env away.

With map, we clone the env (one for each item in the list), run the
program in parallel on each env, gather up the top items in each env,
and put it as a list on top of the original stack.

The question is, can we leverage kcats itself to manage the intra-env
computations? Seems like theoretically we could - make a new stack
consisting of the other stacks as list items in the new one. Then you
can process that arbitrarily and whatever remains can be used. Seems
like maybe channels should be a dependency here, since that would
easily pipe the right value back to the right env.

So, what's needed here is another combinator (like genrec etc) that
takes two programs:

+ one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

+ one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the =pop= would drop the =7= off the stack, so we're
testing that it gets resurrected for each item in the list =[1 2 3]=.

Let's define =f= as something that would take the input stack and leave

=7 [[1 swap pop inc] [2 swap pop inc] [3 swap pop inc]]= (concat'ing the
mapping function program onto each piece of data)

Then that list-of-lists is what's used to make new environments (in
the implementation of cleave*), each top-level item is a program to
run.

Then you'd have 3 environments, after the program had run, stacks look like this:

2
3
4

Then we'd need to specify how map gathers up the top items from this
stack and adds them to the original:

1 3 exchange pop pop

#+BEGIN_EXAMPLE
So, what's needed here is another combinator (like genrec etc) that
takes two programs:

,* one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

,* one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the pop

map

7 [1 2 3] [inc] . map

env1
7 1 . inc
7 2

env2
7 2 . inc
7 3

env3
7 3 . inc
7 4


,* distribute items f(stack) -> new env(s) expression (in the case of map, enstacken or whatever takes the agg on ToS as the items to be added)
,* run all the envs (one per item in the list below ToS) 
,* reduce all the ToSs (in the case of map we're already done)

Let's try nullary

2 3 [+] nullary

,* enstacken
,* run all (one)
,* conj o
#+END_EXAMPLE
** Dispatch
*** Basics
A multimethod is a function broken into two parts:

+ a dispatch (where the arguments are examined to figure out where to
  send them)
+ method call (based on the dispatch results, pass the same args to
  some other function)

Concatenative languages make composing functions easy so it's possible
all the language needs is a convenient way to create dispatches.

#+BEGIN_EXAMPLE
  [from where] [thing] get => the thing

  network {url "http://foo.com"} get => (a pipe to read data from)
  network {url "http://foo.com"} get bytes => (byte array)

  [foo bar baz quux] mapping foo get => bar
#+END_EXAMPLE

Defining a multifn

#+BEGIN_EXAMPLE
  ;; [program to prepend to method] multi word inscribe
  [type get] multi foo inscribe

  [url [sdf asdf]] foo addmethod
#+END_EXAMPLE

There are a few ways to approach this
*** Approaches
**** Clojure-like 
Tried and true, but requires the implementation of a type hierarchy to
do dispatch by type properly

**** Predicate based
This is where the implementation of multimethods is just =cond=. The
conditions are data (just like everything else) and to add methods,
you just insert a condition. 

A series of predicate/method pairs- Iterate over the pairs, and the
first one where the pred returns true, execute the
method. Performance-wise, it could be slower if there's lots of
methods defined. However there's no dispatch function to execute so in
some cases it could be faster. (Note also, that because there's a
stack here, we could always have a dispatch value available too)
Ordering of the methods would become important. For example, if you
had a predicate like =object?= (that is basically always true) you'd
have to make sure that's last in the list.

There's another performance issue - sometimes predicates are expensive
to calculate repeatedly. Let's say you have a list of a billion
integers, and you have a method that is dispatched to with =[int?
every?]=. There's a couple strategies to combat having to examine
every item in that list, especially multiple times:

+ Cache the result as metadata on the value. Predicates could, instead
  of popping the value off the stack and leaving a boolean, leave the
  value but with an added metadata, of which predicate was already run
  on it, and the result. Predicates can short-circuit by seeing if the
  metadata is there before actually running.
+ Allow anyone to populate that metadata. If you know a huge list is
  already going to return true on some predicate, you can just add the
  meta at creation time. Of course this is a foot gun so you have to
  be careful and understand these are assertions that can be wrong.

Generally I am not going to worry about performance yet but I want it
to be addressable with backward compatible additions to the language.

#+begin_example
  ;; basic multimethod pattern
  [clone [[pred1...] [method1]
          [pred2...] [method2]
          ...] 
#+end_example
#+BEGIN_EXAMPLE
  ;; old example code 

  [[odd?] execute [[true [inc]] [false []]] swap get execute]

  ;; so the pattern here is [dispatch-fn execute methods swap get execute]

  ;; if we want to add a method, we can just insert it with add

  ;; we can create an empty multi from a dispatch:

  [[odd?] list [execute [] swap get execute] concat ;; or some such

  ;; then to update an already inscribed method
  [[foo] dup describe ... (updating) ... 

  ;; another way to do this is to just run predicates until one matches,
     that might do away with types entirely and just leave predicates.

  [[int? [+]] [string? [concat]] loop-and-execute ;; loop thru these and
  execute the first program where the pred matches.

  ;; for example
  5 6 [[[int?] [+]] [[string?] [join]] loop-and-execute
  11

  "hi" " there" [[[int?] [+]] [[string?] [join]] loop-and-execute
  "hi there"

  ;; should the predicates leave the value on the stack?
  5 odd?
  5 true
  ;; or drop it?
  5 odd?
  true

  ;; generally we probably still want to keep values that we're running
  ;; a pred on, but maybe best to explicitly clone
  5 clone odd?
  5 true

  ;; or should we actually reset the stack like with map? the benefit is
     that preds don't have to be tidy. but really i can't think of any
     reason they wouldn't be. The whole point of them is that they only
     need one value as input.
#+END_EXAMPLE


** Pipes
This is a general coordination construct. A pipe is a one way
communication channel, you put values in at one end, and take them off
at the other. Where the data actually goes (in memory, over network,
to a file, etc) is up to the implementation.

There are a few words that a pipe needs to respond to:
+ put - put a value into the pipe (may block)
+ take - take a value out of the pipe (may block)
+ close - close the input end of the pipe (no more puts)

And then some higher level words that let you do more complex things:
+ choose - given a list of pipes, block until one has a value ready,
  then return [val pipe].
+ copy - given two pipes, the values that emerge from the first will
  also emerge from the 2nd.
+ dump - given a pipe and a list, put all the items of the
  list into the pipe.

Unlike go/coreasync, there are no non-blocking operations, as envs are
equivalent to go blocks, so everything is in a go block.
#+BEGIN_EXAMPLE
  ;; create a pipe 

  
#+END_EXAMPLE


*** Problem
Pipes have non-representable content. For example, a pipe is made from
a clojure Atom, how do we represent that as a pure value? You can
maybe encode the memory reference and pass it around somehow - but you
can't take an atom and send it over the wire to a different
process. That isn't the same atom, it can't dereference some other
process's memory. 

This kind of makes the goal of "everything is a value and
serializable" unattainable, but maybe we can get close enough.

We could get sophisticated and pass an atom over the wire but as it
passes, wrap it in such a way that putting a value into it gets sent
back to its origin. That would be pretty powerful (and possibly
dangerous).

*** Implementation of 'close'
Should pipes implement this? (That there's nothing left to put/take so
don't bother waiting)?

I think it might be best to let pipes be a lower-level construct and
implement 'close' at a higher level. For example, add a 2nd atom pipe
that starts off with the value =false= and flips to =true= when
there's nothing left to put/take.

This is not terribly efficient but probably easiest to work with.

** Hash maps
*** Use a map literal or not?
Do we add a new literal type for maps? ={a 1 b 2}= ?

Or do we just use a list literal and specify that we want to look at
it like a map? =[a 1 b 2] hashmap=?

Data's just data, should it also carry around how it's supposed to be
looked at? A hashmap is just a list with some optimizations (the data
is grouped by hash so that you can find an item in O(1) time - but you
can always construct a hashmap from a list as the list has all the
data).

All data can be represented as lists (possibly nested), eg a graph
=1->2<-3= is =[[1 2] [3 2]]=

Do we just not bother to turn a list into something else until we
reach a word that expects a certain semantic? for example:

=[a 1 b 2] b get= we're clearly using =get= as a hashmap get, not
trying to get a vector item at an index b. (however if you allowed
integer keys, it would become ambiguous - but let's ignore that for
now). So maybe the language impl can see that we intend to use this
list as a map, and create a hashmap under the covers. (note I no
longer think this is necessary esp for smaller maps. elisp just uses
association lists (O(n) lookup) and for small maps it's actually going
to be faster than hashmap lookup. The vast, vast majority is going to
fall into that category. Hashmaps should be available for larger data
but not the default for literals.
*** Hashmap/ case statement equivalence
There's no difference between a hashmap with get, and a case statement
in this language. So maybe we shouldn't bother with hashmap types? We
could just have a program that we pass around and can modify?
 
=[a 1 b 2] b case=
** Types
How do we express types? We're definitely going to want to dispatch
methods based on "type" (whatever that may mean). One approach is to
just treat any map with a =type= field as an object. We'd need some
kind of inheritance functionality to be able to count, say, a =float=
type as a =number= type. However a single =type= may not be expressive
enough. In other languages, a type might be labelled with all the
interfaces or protocols it implements. I'm not sure that's necessary -
to find out if a type has a method implementation, we could possibly
introspect the dictionary and see what methods have a dispatch for
that type. It seems to me that would only be needed for exploratory
purposes (to find out what you can do with a given type), not at
runtime.

#+BEGIN_EXAMPLE
[type get] multi fetch inscribe ;; return bytes
[url [prog to get url]] [fetch] method put ;; uh oh, how do we avoid actually calling fetch here?? needs to be quoted
[[type url] [url "http://google.com"]] fetch
;; or how about a shorthand
[url "http://google/com"] hint fetch ;; where hint converts into a map with 2 values

[file [prog to read file]] [fetch] method put
[file "/tmp/blah.kcats"] hint fetch read eval ;; run a script?
#+END_EXAMPLE

What about generics? How to express "list of int"?

Could we make use of a predicate(s)? eg[ [value 1] [type integer?] ]
*** Discussion
At the lowest level, all values are just a sequence of bits. Machines
might be optimized for certain sizes and operations, but those are
implementation details.

Of course, the problem comes when a program gets a sequence of bits
but doesn't know what it's supposed to do with it. For example the =+=
operator might be intended to do arithmetic addition if the bits are
meant to be numbers, and concatenation if they're meant to be
text. How does it know which one it's got, when they're both just
sequences of bits and there's not necessarily any way to tell?

Type information included along with the value is the "typical"
solution, along with hierarchies etc. At least, there has to be a key
of some kind included that lets the program look up, in some way, what
it's supposed to do with the actual bits given a certain operator or
word.

Let's say there's a key k and the word w. The goal is to have a f(k,
w) that returns a program that manipulates the bits in the desired
way.
*** Predicate based
Since we make use of programs (executable lists) all over the place,
why not for type specification? We could have some native predicates
like =int?= =string?= etc, from which you can build up more complex
type-discerning predicates. Then dispatch is just going thru all the
methods until you hit one that matches.

#+begin_example

#+end_example
** Quoting
Do we need a special quote syntax other than lists? I'm thinking
of quoting a single word, (using lisp syntax here) is '(foo)
equivalent to 'foo? Obviously in lisp it isn't. I don't think it will
be in kcats either. For example the equivalent of assoc, it seems
reasonable to use a word as a key, but as soon as you put the word on
the stack, it's executed before we can assoc a value. That's not what
we intended. One way out is to do =[word] unwrap= which would just
leave =word= bare on the stack. Doing this might be rare enough that
it's ok to be that clunky vs making the language more complex to
support =quote=.

There's a couple examples I thought of where we might miss having a
special quote reading function.
 
+ If you want to be able to read a literal list and eval recursively
  so that you get the same access to evaluation in a literal that
  you'd get in other languages. eg in clojure 
  #+begin_src clojure :tangle no
    {:a (+ 1 1)}
    ;;eval's to
    {:a 2}
  #+end_src
  to get this in kcats you'd have to do something like
  #+begin_src fundamental
    [[a [1 1 +]] eval-recurse
  #+end_src
  The problem here is that when we only have one list construct, we
  can't tell where we're supposed to stop recursing and start
  evaluating. So we might end up recursing into =[1 1 +]= instead of
  executing it as a program. Also, the bare word =a= is a problem,
  it's not supposed to be eval'd in this case. But =eval-recurse= has
  no way to know that.

  The quoting functionality only fixes the latter issue. The former is
  tough because even with a way to distinguish, what's on the stack
  it's evaluating in? What's the equivalent of 
  #+begin_src clojure :tangle no
    (let [x 3]
      {:a (inc x)
       :b (* x 5)})
  #+end_src
 
  The reality is there isn't an equivalent because in a stack based
  lang, there are no "locals" with names. There are only stack items.
  
  So how would eval-recurse even work? Something like this?
  #+begin_src fundamental 
    1 [1 [1 +]] eval-recurse
    ;; if it's an atom, eval it, otherwise eval-recurse
    1 [1 [1 +]] [eval-recurse] map
    ;; done
    1 [1 2] 
  #+end_src
  
** Feature dependency tree
*** Types
**** Multimethods
***** Pipes
needs multi's because words like get/put should probably be generic
and have specific methods for pipes.

** Nullary/unary/etc?
Do we need these? If a program knows that the items it consumes will
be needed later, it can =clone= them. And if a program is going to run
another program that it knows will consume items it needs, it can also
=clone= them first.

So at first glance it would seem that nullary et al aren't needed. 

Even if they were needed, these names are too difficult for the target
audience to understand. We need better names and I can't think of any
right now.

Note: I later realized that nullary isn't as voodoo as I originally
thought. There's no magic in implementing nullary, if you have the
=stack= (or =evert=) word (capture the stack as a list). Then you can
just clone it and it's easy to revert the stack back to a previous
state from the copy. My current thinking is having this word isn't
going to confuse users since it's not magic or exceptional.

** better names?
- dipd :: dipdown 
- ifte :: if
- swaack :: swapstack, switch, pivot, evert*
- primrec :: ?
- infra :: inject*
- cond :: choose, decide*
- assoc :: set, associate, assign*, link
- map :: ? 
- pipe-out :: tap? drain?
- pipe-in :: fill?
- handoff :: ?
- spawn :: ?
- nullary :: ? 
** Nested env Runtime structure
How do environments that create new environments control execution?

There could be a top level runtime that controls all the environments
(runs them in different threads, etc)

Or it could just be fully programmable where the entry-point env is
responsible for doing whatever it needs. 

The latter seems like the way to go, but what's the control mechanism?
I think threading a separate concern from how an env is executed (as
in, in a debugger etc)

A threadpool is probably fine, futures would probably do it, at least
as a first pass. But there won't be any top level "show me all the
environments" which would be super handy for use in an IDE. One way to
handle this would be - for any env that needs to send messages home to
some IDE, inherit that behavior from its parent and have the top level
env do that. However then there's the matter of how things like
breakpoints etc would be communicated down to where they're needed.

It's important to be able to distinguish between envs whose purpose is
to do the actual job and those that are part of the execution setup
(envs whose only job is to run other envs, say with logging or
debugging). It's kind of hard have a library that introduces a
hierarchy of envs and then still allow the user to debug it.
** Example programs
*** Factorial
**** Recursive definition 
#+begin_src clojure
 10 
 [fact [[clone 0 =]
        [discard 1]
        [clone dec fact *]
        if]]
 inscribe
 fact
#+end_src
**** Recursive with recur
#+begin_src clojure
 5
 [clone 1 <=]
 []
 [clone dec]
 [execute *]
 recur

 5
 [1]
 [*]
 
#+end_src
**** Using range
#+begin_src clojure
 10
 1 +
 2 swap
 range unpack
 [*] step
#+end_src
**** Plain loop
#+begin_src clojure
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src
*** Spawn child environments and pipe values back
#+begin_src clojure
[handoff clone ;; 2 copies of a pipe (one in, one out)
 wrap [1 1 + put] join ;; build a program containing the pipe and some arthmetic problem, which puts the result in the pipe
 spawn ;; a new env to run the above program
 [2 3 +] dip ;; do another calculation in this env
 take ;; the value from the pipe, which will come from the spawned env 
 [discard] dip ;; done with the pipe
 +] ;; add numbers
#+end_src
*** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
 #+begin_src clojure
 100 [0] [[1.0 swap /] dip +] primrec
 [100 0 swap 1 + 1 swap range [1.0 swap / +] step]
 #+end_src
*** Primrec
#+begin_src clojure
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
