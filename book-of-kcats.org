# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to express short
  programs. You can't write just 1 line of C++ or even python. But you
  will be able to write meaningful kcats expressions that are just a
  few words, and be able to put them into an application to get it to
  do what you want. While typical applications are menu-driven, kcats
  based applications will be message-driven, where a message is some
  words sent to a running program. 
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just values (numbers,
words, text, true/false) and quotation marks. No other symbols - no
periods, exclamation points, semicolons, equals, plusses, ampersands,
or asterisks.

Quotations are marked with square brackets, those are the only two
symbols that carry any meaning. 
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as input,
then the resulting stack afterward (both the before and after stack
are surrounded with square braces):

#+BEGIN_EXAMPLE
[true ☯] [false]
[false ☯] [true]
#+END_EXAMPLE

In the example without knowing in advance what the =☯= symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Powerful
The language should allow the user to express himself succinctly and
without a lot of ceremony or repetition.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
The language should be well positioned to handle various types of
programming tasks, including numerical computation, API client/server,
networking applications, machine learning, etc.

** Make tool development as easy as possible
+ Debuggers
+ IDEs

Wherever possible, tooling should be baked into the language.
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put
=1= onto the stack. Then we put =2= onto the stack (so that =2= is on
top and =1= is beneath it). Then we put the word =add= onto the stack
and it will consume the =2= and the =1= and replace them with the sum,
which is =3=.
#+begin_example
1 2 add
=> 3
#+end_example

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add =1=
and =2= (leaving =3= on the stack), and then put =5= and =multiply= on
the stack (which consumes the =5= and =3=, leaving =15=):

#+begin_example
1 2 add 5 multiply
=> 15
#+end_example

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 add 5 multiply 
            1 | 2 add 5 multiply 
          1 2 | add 5 multiply
            3 | 5 multiply
          3 5 | multiply
           15 |  
#+end_example

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.
#+begin_example
[1 2 3] [4 5] join
=> [1 2 3 4 5]
#+end_example

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [multiply add] execute
                    4 | 5 6 [multiply add] execute
                  4 5 | 6 [multiply add] execute
                4 5 6 | [multiply add] execute
 4 5 6 [multiply add] | execute
                4 5 6 | multiply add
                 4 30 | add
                   34 |
#+end_example
Note that, when =multiply add= gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =multiply add= would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_example
4 5 6 [add] [multiply] join execute
=> 34
#+end_example

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote, a message being
passed along and not acted upon until it reaches the recipient.
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Base Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Project file
We're building this clojure project with leiningen, so let's make a
project file.

#+begin_src clojure :tangle project.clj
(defproject kcats "0.1.0-SNAPSHOT"
  :description "The kcats programming language"
  :jvm-opts ["-Xverify:none"]
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.0"]
                 [expound "0.7.2"]]
  :repl-options {:init-ns kcats.core})
#+end_src
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library =expound= which gives easier
to understand error messages.

#+BEGIN_SRC clojure
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval test]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

What's important here is that we have some basic value types. Values
are stateless - they can be sent over a wire to some remote machine
without losing any meaning (the number 5 is always the number
5). 

There is only one common type in the system that has state (and
therefore would lose meaning being sent to a remote machine): a
pipe. See [[*Pipes][this later section]] for more detail. Kcats allows other
stateful things on the stack (like java objects, clojure atoms etc)
but best practice is that they should only be there temporarily,
usually during the construction of a pipe[fn:2].

#+BEGIN_SRC clojure
(spec/def ::boolean boolean?)
(expound/defmsg ::boolean "should be true/false")
(spec/def ::number number?)
(expound/defmsg ::number "should be a number")
(spec/def ::string string?)
(expound/defmsg ::string "should be a string")
(spec/def ::bytes bytes?)
(expound/defmsg ::bytes "should be bytes")
(spec/def ::integer integer?)
(expound/defmsg ::integer "should be an integer")
#+END_SRC

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be list, which we haven't specced yet. That's ok, recursive
specs are allowed. Lists contain items, and items can be lists.

Values are a particular kind of item, which is what most =words= will
operate upon. A value list is one where all the contents are
values.
#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(expound/def ::value
  (spec/or :value-list ::value-list
           :boolean ::boolean
           :number ::number
           :string ::string
           :bytes ::bytes
           :word ::word))

(expound/def ::item (constantly true))
#+END_SRC

Now we'll spec a list. We'll use clojure's vectors (which are indexed
lists). We'll also spec out programs, which are lists but intended to
be executed (otherwise there is no difference).

#+BEGIN_SRC clojure
(spec/def ::list (spec/coll-of ::item :kind vector?))
(expound/defmsg ::list "should be a list")

(spec/def ::value-list (spec/coll-of ::value? :kind vector?))
(expound/defmsg ::value-list "should be a value list")

(spec/def ::program (spec/coll-of ::item :kind vector?))
(expound/defmsg ::program "should be a program")
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In our dictionary, we have to start with something - some
words that aren't defined in terms of other words. We'll call them
=axiom words= and their meaning is expressed as a clojure
function. All the rest of the words are in terms of other words we've
already defined.

#+BEGIN_SRC clojure
(def word? symbol?)
(expound/def ::word word?)

;; TODO these keyword reqs are outdated
(expound/def ::axiom-definition (spec/keys :req [::fn ::spec]))
(expound/def ::program-definition (spec/keys :req [::definition]))

(expound/def ::dictionary (spec/map-of ::word
                                       (spec/or :axiom ::axiom-definition
                                                :user-defined ::program-definition)))
#+END_SRC

Next we'll spec a stack. We want it to easily implement a
first-in-first-out (FIFO) stack, (meaning the last item you put in is
accessible in constant time), and clojure's built-in list type does
this.

An expression is a stack too, but it represents words waiting to be
executed - parts of the program that haven't run yet. In kcats, the
program modifies itself heavily, so it is constantly adding pieces to
the expression.
#+BEGIN_SRC clojure
(def stack? (every-pred (complement indexed?) sequential?))

(expound/def ::stack (spec/coll-of ::item
                                   :kind stack?))

(expound/def ::expression (spec/coll-of ::item
                                        :kind stack?))

#+END_SRC

Next we'll spec what an Environment is - it's just a dictionary,
stack, and expression put together.

We'll call this an "association list" so that it's not tied directly
to clojure maps (which don't exist in kcats). We're going to want to
represent environments in kcats and not just as clojure data
structures. See [[*Maps/associations][Association Lists]]. We're also going to use symbols
instead of clojure keywords, because again, kcats only has the
equivalent of symbols. This will allow us to, for example, use clojure
libs to read kcats data.
#+BEGIN_SRC clojure
(expound/def ::pair (spec/coll-of ::item :kind vector? :count 2))

(expound/def ::association-list (spec/or :map map?
                                         :pairs (spec/coll-of ::pair
                                                              :kind vector?)))

(expound/def ::environment ::association-list) ;; TODO: specifically call out keys

#+END_SRC

Finally, we'll add some functions that help us build specs for new
kcats words that we'll define later.

#+begin_src clojure
;; since we'll commonly be defining specs for a stack, we'll nearly
;; always not care about anything below a certain depth, so let's make
;; a macro that encapsulates that.
(defmacro stack-spec
  [& args]
  `(spec/cat ~@args
             :others (spec/* ::item)))
#+end_src

[fn:2] There are some pipes that may be technically values (think of a
pipe that produces the infinite sequence 1,2,3...). You could send
that somewhere else, as long as you include what number it last
produced. But you can't send files or sockets somewhere else (they're
pointers to real world resources that may be different or nonexistent
somewhere else). Discerning between the two may be a future feature.
** Stack specs
When writing a kcats program, you have a lot of words available to
use. How do we know what a word does? Hopefully there are some
examples, but having a brief description of what the word does to the
stack is also helpful. Other stack based languages use a stack spec,
which tells you what items the word uses from the stack and what it
will replace them with. It looks like this: =a -> a a=. That's the
spec for =clone=. It takes =a= from the top of the stack (which can be
anything), and leaves =a= and then =a= again.

We will use a slight variation of this syntax. We'll represent the
same thing in kcats data structures, and we'll support optional type
information. So in this format, =clone= spec would be =[[[item a]]
[[item a] [item a]]=. A list of two items: what is taken from the
stack, and what's left afterward. Only the top stack items are
relevant here, there could be any number of items underneath, but they
aren't touched. The order of items in each list is that the first item
is the top of the stack.

Some words can do very arbitrary things to the stack, for example,
=execute=. It executes the program on top of the stack, which could do
anything to the stack - add lots of items, remove lots of items, or
both. To express this behavior we use =*=, which means "any number of
stack changes". The spec for =execute= is =[[program][*]]= - it takes
a program from the top of the stack and excutes it, so what happens to
the stack then is determined by the contents of that program. 

Let's look at the the spec for =dip= - it's =[[program [item a]][a
\*]]=. What does this mean? This word takes a program on the top of
the stack, and an item underneath called =a=. When it's done, =a= is on
top and the rest of the stack has changed arbitrarily (because of the
=*=). That's because =dip= takes =a= away, executes the program, then
puts =a= back on top. In the input half of the spec, there's a type
for =a= (=item=) but when we refer to =a= in the output half, we don't
list the type again (we already said what type =a= is). 

Having these specs for all the words in kcats data allows us to
programmatically search for words. Here's an example of doing that [[*Search the
 dictionary][Searching the dictionary]].

We'll add some functions that support stack specs and validate whether
they actually are followed.

#+BEGIN_SRC clojure
(def spec-arbitrary-effect-designator '*)

(defn build-spec
  "Build a native clojure spec from the stack-spec"
  [spec]
  (if (seq spec)
    (clojure.core/eval
     `(spec/tuple ~@(for [s spec]
                      (keyword "kcats.core" (str (cond-> s
                                                   (not (symbol? s)) (first)))))))
    (constantly true)))

(defn cache-spec
  "if the given env doesn't have a prebuilt native clojure spec, build
  some from the stack spec"
  [{:syms [dictionary] :as env} word]
  (let [spec (get-in dictionary [word 'spec])
        [in-spec out-spec] spec
        existing (get-in dictionary [word 'clojure-spec-in])]
    (if (and (not existing) in-spec)
      (-> env
          (assoc-in ['dictionary word 'clojure-spec-in] (build-spec in-spec))
          (assoc-in ['dictionary word 'clojure-spec-out] (build-spec out-spec)))
      env)))

(defn validate-stack-spec-before
  [[in] word {:syms [stack dictionary]}]
  (when (> (count in) (count stack))
    (throw (Exception. (format "Word '%s' expects at least %d items in stack, but there were only %d"
                               word (count in) (count stack)))))
  (let [spec (get-in dictionary [word 'clojure-spec-in])]
    (when spec
      (binding [spec/*explain-out* expound/printer]
        (spec/assert spec (vec (take (count in) stack)))))))

(defn- assigned-variables
  [spec stack out?]
  (let [values (dissoc (zipmap spec (take (count spec) stack))
                       spec-arbitrary-effect-designator)]
    (into {}
          (for [[spec val] values
                :when (or out? (vector? spec))]
            [(if out? spec (second spec)) val]))))

(require '[clojure.set :as set])

(defn validate-placeholders
  [[in out] before after]
  (let [before (assigned-variables in before false)
        after (assigned-variables out after true)
        diff (set/difference (into #{} after) (into #{} before))]
    (when (seq diff)
      (throw (ex-info "Spec placeholder(s) not respected" {:in-spec in
                                                           :out-spec out
                                                           :unexpected-values diff})))))

;; TODO: this doesn't work because some words don't really finish
;; executing immediately, they add more stuff to the expression.  To
;; really do this, might need to build up a list of validations to
;; perform when going below a given stack height. This seems like
;; something a nested environment setup might be good for (inner env
;; has validation on, outer does not)
(defn validate-stack-spec-after
  [[in out :as spec] word {before 'stack} {after 'stack}]
  (let [exp-length-change (- (count in) (count out))
        actual-length-change (- (count before) (count after))]
    
    ;; length check
    (and (-> out last (not= spec-arbitrary-effect-designator))
         (not= exp-length-change actual-length-change)
         (throw (Exception. (format "Word '%s' was supposed to %s %d item %s the stack, but instead %s %d"
                                    word
                                    (if (neg? exp-length-change) "remove" "add")
                                    (Math/abs exp-length-change)
                                    (if (neg? exp-length-change) "from" "to")
                                    (if (neg? actual-length-change) "removed" "added")
                                    (Math/abs actual-length-change)))))
    (validate-placeholders spec before after)))
#+END_SRC
*** TODO Add facilities to take a program and calculate its stack effect.

For example: =clone discard= 

The specs (respectively) are  =[[[item a]] [[item a] [item a]]]= and =[[item] []]=

So if we run it on a stack =[1]=. The first step will apply labels to
what's on the stack, so the =1= gets a label =[item a]=. The result is
=[1 1]= and then the labels are applied again (since the resulting 1's
are copies of the original, they already have this label.

** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a program. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do, and we return the
last environment.

We also allow some execution options, like being able to stop after a
certain number of steps (to prevent infinite looping), or do something
before each step (like printing out the environment as a way of
tracing what's happening).
#+BEGIN_SRC clojure 
(declare eval-step) ;; we'll define this later

(defn eval
  [env]
  (loop [{:syms [expression] :as env} env]
    (if (seq expression)
      (recur (eval-step env))
      env)))
#+END_SRC

We'll include handling for calling down into the platform language
directly. There will be syntax for calling clojure functions and java
methods as if they are kcats words. This allows us to leverage the
platform functionality directly in kcats without having to write more
code in the platform language.

#+begin_src clojure
(in-ns 'kcats.core)
(require '[clojure.string :as string]
         '[clojure.edn :as edn])
;; TODO: needs to support no-arg fns, java fields, clojure vars
;; Invocation requires several things:
;; * Indication that it's meant to be invoking platform functionality
;; * Stack effect (how many args consumed and produced)
;; * Platform function type (fn, constructor, instance, static, etc)
;;
;; 
;; + call clojure fn (drop all args and replace w return val)
;; * call java, drop passed in argument or return value
;; ! call java, keep passed in argument or return value
;; for java calls, the first char refers to the return value, 2nd is
;; the object, 3rd and beyond are arguments
;;
;; Regarding argument order: it's the order in which they were put on
;; the stack. last arg is at the top of stack.
;;
;; ++foo : clojure fn foo, consume 2 args, return 1 value (a b -> c)
;; !Bar. : Java no-arg construct Bar instance ( -> b)
;; !*Baz. : construct with one arg (a -> b)
;; **quux : call void instance method quux for side effect (a -> )
;; *!quux : call quux to mutate object (a -> a)
;; *!*quux : call quux to mutate object with arg (a b -> a)
;; !**quux ; call quux with arg, to get return value (a b -> c)
;; !*Foo/bar : call static bar on class Foo. (a -> b)
;; **Foo/blort : call static blort, side effect only (a ->)

(declare nil->nothing) 

(defn invoke*
  [{[word & others] 'expression
    :syms [dictionary stack]
    :as env}]
  {'stack
   (let [[_ arity fn-name] (->> word
                                str
                                (re-find #"([\\+\\!\\*]*)(.*)\.?"))
         java? (not (.contains arity "+"))
         [args others] (split-at (cond-> (count arity)
                                   java? (dec)) ;; has an extra marker for return val
                                 stack)
         args (reverse args) ;; due to stacking reversing the args previously
         into-array (fn [args] ;; for java calls, turn byte seqs back into arrays
                      (into-array Object
                                  (for [arg args]
                                    (cond-> arg
                                      (bytes? arg) (byte-array)))))
         ] 
     (concat
      (nil->nothing
       (cond
         (not (seq arity)) [word] ;; just a regular word

         (or (.contains arity "!")
             (.contains arity "*")) ;; java call
         (let [[ret-flag & arity] (seq arity)
               mutated-args (keep-indexed
                             (fn [i arg]
                               (when (= \! (nth arity i))
                                 arg))
                             args)
               ret (cond
                     (.endsWith fn-name ".") ;; java constructor
                     (clojure.lang.Reflector/invokeConstructor
                      (Class/forName (->> fn-name
                                          count
                                          dec
                                          (subs fn-name 0)))
                      (into-array args))

                     (.contains fn-name "/") ;; static method
                     (let [[clazz method] (string/split fn-name #"/")]
                       (->> args
                            into-array
                            (clojure.lang.Reflector/invokeStaticMethod clazz method)))

                     :else (->> args ;; instance method
                                rest
                                into-array
                                (clojure.lang.Reflector/invokeInstanceMethod
                                 (first args)
                                 fn-name)))]
           (cond-> mutated-args
             (= ret-flag \!) ;; keep the return value
             (conj ret)))

         ;; clojure function
         (some-> fn-name symbol resolve) (-> fn-name
                                             symbol
                                             resolve
                                             (apply args)
                                             vector)
         :else (throw (Exception. (str "Cannot resolve platform word: " word)))))
      others))
   'expression others
   'dictionary dictionary})
#+end_src

Where the real action happens is when we evaluate a word. Each defined
word is either in terms of other words, or has a clojure function that
will run when that word is evaluated. If it's not defined, then the
word will act like everything else and just be put on the stack.

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.

#+begin_src clojure
(defn onto-stack
  "Move one item from the expression to the stack. "
  [{[item & others] 'expression :syms [dictionary stack] :as env}]
  (if (word? item)
    (let [{:syms [dictionary] :as env} (cache-spec env item)
          {f 'fn spec 'spec} (dictionary item)]
      (validate-stack-spec-before spec item env)
      (if f
        (f (update env 'expression rest)) ;; drop this word now that we've used it
        (invoke* env)))
    (-> env
        (assoc 'expression others)
        (update 'stack conj item))))

(defn definition
  "Returns the definition of an item, if it's a word defined in terms
  of other words"
  [{:syms [dictionary] :as env} item]
  (some-> dictionary (get item) (get 'definition)))

(declare repr)

(defn eval-step
  "Evaluate one step in the environment."
  [{[next-item & items :as expression] 'expression :syms [stack dictionary] :as env}]
  (try
    (if-let [d (definition env next-item)]
      (assoc env 'expression (concat (list* d) items)) ;; replace item with definition
      
      ;; eval the thing onto the stack
      (onto-stack env))
    (catch Exception e
      (throw (ex-info (str "Error during evaluation of " (repr next-item))
                      {:environment (dissoc env 'dictionary)}
                      e)))))
 
(defn step-over
  "Executes the next word in the expression completely, returning the
  environment."
  [{:syms [expression] :as env}]
  (let [depth (count expression)]
    (loop [{:syms [expression] :as env} env]
     (if (< (count expression) depth)
       env
       (recur (eval-step env))))))
#+end_src
** Printing
Printing out (or serializing) kcats data is mostly just printing the
underlying clojure data structures, as-is. However we want to note the
difference between raw data and data that's been put into an optimized
structure for processing. A map (or mapping, dictionary etc) lets you
look up a value given a key. The raw data is just a list of key/value
pairs. Arranging it in a hashmap is a performance optimization. When
we print out data, it's the raw format we want. In kcats there's no
difference in raw data, between a list of pairs and a map. Under the
covers though, it may actually be a hashmap. 

We're going to define our representation of raw data that only uses
square brackets and words (in clojure, those are vectors and
symbols). Then we can just print out these representations and we have
our serialized data format.
#+begin_src clojure
(defn repr
  "The kcats canonical representation, in clojure data
  structures. Converts clojure maps to vectors, keywords to symbols."
  [x]
  (cond
    (map? x) (mapv (fn [[k v]] [(repr k) (repr v)]) x)
    (keyword? x) (-> x name symbol)
    (bytes? x) x
    (coll? x) (mapv repr x)
    :else x)) 

(defn print-env
  "Prints the expression/stack and then return env"
  [{:syms [expression stack] :as env}]
  (binding [*print-length* 10
            *print-level* 8]
    (apply clojure.core/pr (reverse (repr expression)))
    (print " :. ")
    (apply clojure.core/prn (repr stack)))
  env)
#+end_src
** Concept of nothing/nil/null
Kcats is not going to have a separate concept of =null= or =nil=. If
we want to express "nothing" we will use an empty list =[]=. We'll
need some functions to treat empty lists as clojure treats =nil=.

#+begin_src clojure
(def nothing [])

(def nothing? (partial = nothing))

(defn nothing->nil
  "Returns argument unless it's a kcats 'nothing' (empty list), in
  which case it returns nil"
  [x]
  (if (nothing? x)
    nil
    x))

(defn nil->nothing
  "Returns argument unless it's nil, in which case it returns empty list"
  [x]
  (if (nil? x)
    nothing
    x))
#+end_src
** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words, but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(defn apply-stack
  "Apply n items from stack to f, put result back on stack."
  [stack n f]
  (let [use (take n stack)
        stack (drop n stack)]
    ;; items are reversed so that we can write code with arguments in
    ;; the same order as we'd use in other langs, eg so that [2 1 >]
    ;; -> true
    ;;
    ;; The top item in the stack would normally be the first
    ;; arg, but that was the LAST arg written in the code.
    (conj stack (apply f (reverse use)))))

(defn f-stack
  [n f]
  (fn [env]
    (update env 'stack apply-stack n f)))

(defn env-effect
  "Calls f with nitems from stack, it should return a pair (items to
  prepend to the expression, items to replace the nitems with)"
  [nitems f]
  (fn [{:syms [stack expression dictionary]}]
    (let [[a b] (split-at nitems stack)
          [new-expression-items new-stack-items] (apply f a)]
          {'stack (into b (reverse new-stack-items))
           'expression (into expression (reverse new-expression-items))
           'dictionary dictionary})))

(defn- strip-types
  "stack specs will have inputs like [[string a]] but we just want [a]"
  [spec]
  (vec (for [s spec]
         (if (vector? s) (second s) s))))

(defmacro effect
  "Constructs a fn with given in args, whose body is out. That
  function body should return a pair (new-expression-items,
  new-stack-items)"
  [in out]
  `(env-effect ~(count in) (fn ~(strip-types in) ~out)))

(defmacro stack-effect
  "Takes a stack effect notation and turns it into a call to
  env-effect"
  [in out]
  `(env-effect ~(count in) (fn ~(strip-types in) [[] ~out])))

(defmacro spec-effect
  "Takes a spec and generates the function (only useful for words that
  rearrange stack items but don't modify any single values)"
  [in out]
  `(stack-effect ~(strip-types in) ~(strip-types out)))
#+END_SRC

We're going to start adding definitions of words here, but only the
actual functions that carry out the word's meaning. All the other data
about the word (specs, docs, examples etc) will go in the lexicon
later. We put this here because this has to be clojure code.
#+BEGIN_SRC clojure
(in-ns 'kcats.core)
(import [java.io ByteArrayOutputStream])
(require '[clojure.java.io :as io]
         '[clojure.edn :as edn])

;; some state to hold our core words, so we can build them up a chunk
;; at a time.
(defonce core-words (atom {}))

;; math symbols are ok - non-programmers already know what they mean
(def thin-wrappers
  (into {} cat
        [;; use autopromoting versions of arithmetic operators
         (for [sym ['+' '-' '*']]
           [(-> sym str (subs 0 1) symbol) ;; drop the '
            {'fn (f-stack 2 (resolve sym))}])
         (for [sym ['inc 'dec 'odd? 'even? 'sequential? 'zero? 'pos?
                    'neg?  'number? 'int? 'true? 'false?  'string?
                    'empty? 'first 'second 'string? 'bytes? 'count
                    'word? 'reverse]]
           [sym {'fn (f-stack 1 (resolve sym))}])
         (for [sym ['/ 'min 'max 'quot 'rem 'mod '< '<= '> '>=
                    'starts-with? 'ends-with? '= 'range]]
           [sym {'fn (f-stack 2 (resolve sym))}])]))

(defn from-spec
  "Build a native function from the spec (in cases where the spec
  completely describes it, like for stack motion words, eg swap)"
  [{:syms [spec] :as dfn}]
  (println "from spec" dfn)
  (let [[in out] spec]
    (assoc dfn
           'fn (clojure.core/eval `(spec-effect ~in ~out))
           'spec spec)))

(defn inscribe [dictionary [word word-def]]
  (let [existing (get dictionary word)
        word-def (into {} word-def)] ;; support kcats data structure
    (assoc dictionary
           word
           (if ('definition word-def)
             word-def
             (if ('fn existing)
               ;; keep existing native fn
               (merge word-def existing)
               ;; no native fn and no definition
               ;; means we generate the fn from spec
               (from-spec word-def))))))

;; add some functions to support immutable byte arrays
(defn conj-byte
  "adds another byte to ArraySeq bs"
  [bs b]
  (let [c (count bs)
        bs (byte-array (inc c) bs)]
    (seq (doto bs
           (aset-byte c b)))))

(defn concat-bytes
  "joins two byte ArraySeqs"
  [a b]
  (seq (byte-array (concat a b))))

(def bytes? (partial instance? clojure.lang.ArraySeq$ArraySeq_byte))

(def axiom-words
  {'execute (effect [p] [p []])
   'wrap (stack-effect [a] [[a]])
   ;; TODO: possible security issue with unwrap and bare words on the
   ;; stack: It's possible for malicious code to squat on a word that
   ;; was intended to be data, and not an action word, causing
   ;; unexpected behavior. May want to reconsider whether undefined
   ;; words should be placed onto the stack unquoted.
   'unwrap (stack-effect [l] l)
   'rest (stack-effect [l] [(vec (rest l))])
   'fail (stack-effect [s] (throw (Exception. s)))
   'dip (effect [p a] [(conj (vec p) [a] 'unwrap) []])
   'dipdown (effect [p a b] [(conj (vec p) [a b] 'unwrap) []])
   'list? (stack-effect [a] [(vector? a)])
   'number? (stack-effect [a] [(number? a)])
   'string (stack-effect [a] [(if (bytes? a)
                                (-> a .array String.)
                                (str a))])
   'read (stack-effect [s] [(edn/read-string s)])
   
   ;; maybe this should be something likefirst
   ;; timesfive [[definition [5 *]] [examples [...]]] inscribe
   'inscribe (fn [{[word-def word & others] 'stack
                   :syms [stack expression dictionary]}]
               {'dictionary (inscribe dictionary [word word-def])
                'stack others
                'expression expression})
   'branch (effect [f t b]
                   [(if (nothing->nil b) t f) []])
   'step (env-effect 2 (fn [p [agg-item & agg-rest :as agg]]
                         (if (seq agg)
                           [(cond-> ['execute]
                              (seq agg-rest) (concat [(vec agg-rest) p 'step]))
                            [p agg-item]]
                           [[] []])))
   'recur (effect [rec2 rec1 then pred]
                  ['[if]
                   [(vec (concat rec1 [[pred then rec1 rec2 'recur]] rec2))
                    then pred]])
   'loop (effect [p f]
                 [(when (nothing->nil f)
                    (concat p [p 'loop]))
                  []])
   
   'unpack (env-effect 1 (fn [[l & others]]
                           [[] [(nil->nothing l) (vec others)]]))
   'evert (fn [{[l & others] 'stack :as env}]
            (assoc env 'stack (apply list (vec others) l)))
   'and (f-stack 2 (fn [a b]
                     (and (nothing->nil a)
                          (nothing->nil b))))
   'or (f-stack 2 (fn [a b]
                    (or (nothing->nil a)
                        (nothing->nil b))))
   'not (f-stack 1 (fn [a]
                     (not (nothing->nil a))))
   'dictionary (fn [{:syms [dictionary] :as env}]
                 (update env 'stack conj dictionary)) 
   'lexicon (fn [env]
              ;; read one definition at a time from this file
              ;; update the dictionary with each one
              (let [rdr (-> "src/kcats/lexicon.kcats"
                            io/file
                            io/reader
                            java.io.PushbackReader.)]
                (reduce (fn [env dfn]
                          (try
                            (update env 'dictionary
                                   inscribe dfn)
                            (catch Exception e
                              (throw (ex-info "Error updating dictionary"
                                              {:definition dfn}
                                              e)))))
                        env
                        (->> #(edn/read {:eof nil} rdr)
                             repeatedly
                             (take-while identity)))))})

(swap! core-words merge
       (into {} (for [[word dfn] axiom-words]
                  [word {'fn dfn}]))
       thin-wrappers)

(defn default-env
  ([expression]
   {'stack '()
    'dictionary @core-words
    'expression (conj (list* expression) 'lexicon)})
  ([]
   (default-env '())))

(defn exec
  "Add p to the expression in env so that it executes when the env is
  evaluated"
  [env p]
  (update env 'expression concat p))

(defn k
  "Run a program with the default env and return the result."
  [p]
  (-> (default-env)
      (exec p)
      eval
      (get 'stack)
      repr))

(defn run
  [env p]
  (eval (exec env p)))

#+END_SRC

Next we can add a way to test that all the examples are working, so
that we notice any bugs as we're developing.

#+begin_src clojure
(in-ns 'kcats.core)
(require '[clojure.test :as test])
(defn test
  "Run through all the examples in the default env and make sure they
  work. Takes optional list of words to test"
  ([env words]
   (let [env (eval env)
         dict ('dictionary env)]
     (doseq [[word {:syms [examples]}] (if words
                                          (select-keys dict words)
                                          dict)]
       (test/testing (str word)
         (doseq [[program exp-stack] examples]
           (-> (->> program
                    (update env 'expression concat)
                    eval)
               (get 'stack)
               repr
               (= exp-stack)
               test/is))))))
  ([env] (test env nil)))
#+end_src

Now that we have enough axiom words, we can define more words as a
standard library, in native kcats. It will be a list of pairs (we'll
go into more detail on this particular data type in [[*Maps/associations][Association Lists]]).

#+begin_src kcats :tangle src/kcats/lexicon.kcats
;; TODO: platform specific definitions shouldn't live here, but for
;; now we'll allow it.


;; axiom defs

[= [[spec [[item item] [boolean]]]
    [examples [[[1 2 =] [false]]
              [[1 1 =] [true]]
              [[[] [] =]  [true]]
              [[[1] [] =]  [false]]
              [[[1 [false]] [1 [false]] =]  [true]]
              [[[1.0 ["foo"]] [1.0 ["foo"]] =]  [true]]
              [[[1.0 ["foo"]] [1.0 ["bar"]] =]  [false]]]]]]

[+ [[spec [[number number] [number]]]
          [examples [[[1 2 +] [3]]
                     [[1.1 2.2 +] [3.3]]
                     [[1 2.2 +] [3.2]]]]]]

[- [[spec [[number number] [number]]]
          [examples [[[2 1 -] [1]]
                     [[1.1 2.2 -] [-1.1]]
                     [[2.2 1 -] [1.2]]]]]]

[* [[spec [[number number] [number]]]]]
[/ [[spec [[number number] [number]]]]]
[min [[spec [[number number] [number]]]]]
[max [[spec [[number number] [number]]]]]
[quot [[spec [[number number] [number]]]]]
[rem [[spec [[number number] [number]]]]]
[mod [[spec [[number number] [number]]]]]
[< [[spec [[number number] [boolean]]]]]
[<= [[spec [[number number] [boolean]]]]]
[>= [[spec [[number number] [boolean]]]]]


[> [[spec [[number number] [boolean]]]
          [examples [[[2 1 >] [true]]
                     [[1.1 2.2 >] [false]]
                     [[2.2 1 >] [true]]]]]]

[inc [[spec [[number] [number]]]
      [examples [[[1 inc] [2]]
                     [[-1 inc] [0]]
                     [[99 inc] [100]]]]]]

[dec [[spec [[number] [number]]]]]

[odd? [[spec [[number] [boolean]]]]]
[even? [[spec [[number] [boolean]]]]]
[pos? [[spec [[number] [boolean]]]]]
[zero? [[spec [[number] [boolean]]]]]
[neg? [[spec [[number] [boolean]]]]]


[discard [[spec [[item] []]]
          [examples [[[1 2 3 discard] [2 1]]
                     [[1 2 3 [a b c] discard] [3 2 1]]]]]]

[clone [[spec [[[item a]]
               [[item a] [item a]]]]
        [examples [[[1 2 3 clone] [3 3 2 1]]]]]]

[swap [[spec [[[item a] [item b]]
              [[item b] [item a]]]]
       [examples [[[1 2 3 swap] [2 3 1]]]]]]

[swapdown [[spec [[[item a] [item b] [item c]]
                  [[item a] [item c] [item b]]]]
           [examples [[[1 2 3 swapdown] [3 1 2]]]]]]

[float [[spec [[[item a] [item b] [item c]]
               [[item c] [item a] [item b]]]]
        [examples [[[1 2 3 float] [1 3 2]]]]]]

[sink [[spec [[[item a] [item b] [item c]]
              [[item b] [item c] [item a]]]]
       [examples [[[1 2 3 sink] [2 1 3]]]]]]

[execute [[spec [[program] [*]]]
          [examples [[[[1 2 +] execute] [3]]
                     [[2 [+] 4 swap execute] [6]]]]]]

[wrap [[spec [[item] [list]]]
       [examples [[[1 wrap] [[1]]]
                  [[[1 2] wrap] [[[1 2]]]]]]]]

[unwrap [[spec [[list] [*]]]
         [examples [[[[1] unwrap] [1]]]]]]

[rest [[spec [[list] [list]]]
       [examples [[[[1 2 3] rest] [[2 3]]]]]]]

[reverse [[spec [[list] [list]]]
          [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]]

[fail [[spec [[string] [*]]]]]

[dip [[spec [[program [item a]] [[item a] *]]]
      [examples [[[1 8 [inc] dip] [8 2]]
                 [[1 2 [dec] unwrap
                   [+] dip] [dec 3]]]]]]

[list? [[spec [[item] [boolean]]]
        [examples [[[[1] list?] [true]]
                   [[[] list?] [true]]
                   [[5 list?] [false]]]]]]

[number? [[spec [[item] [boolean]]]
          [examples [[[[1] number?] [false]]
                     [[[] number?] [false]]
                     [[5 number?] [true]]
                     [[5.01 number?] [true]]]]]]

[string [[spec [[item] [string]]]
         [examples [[[1 string] ["1"]]
                    [[[1 2 3] string] ["[1 2 3]"]]
                    [[[] string] ["[]"]]]]]]

[read [[spec [[string] [item]]]
       [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]]

[inscribe [[spec [[list word] []]]
           [examples [[[[add3] unwrap [[definition [3 +]]
                                       [spec [[number] [number]]]]
                        inscribe
                        5 add3] [8]]]]]]

[branch [[spec [[[program false-branch]
                 [program true-branch]
                 [item condition]]
                [*]]]
         [examples [[[5 true [3 *] [4 +] branch] [15]]
                    [[6 false [3 *] [4 +] branch] [10]]]]]]

[step [[spec [[program list] [*]]]
       [examples [[[1 [2 3 4] [*] step] [24]]
                  [[1 [] [*] step] [1]]]]]]

[recur [[spec [[[program rec2]
                [program rec1]
                [program true-branch]
                [program pred]]
               [*]]]
        [examples [[[3
                     [1 <=] [] [clone dec] [execute *]
                     recur]
                    [6]]]]]]

[loop [[spec [[program [item flag]] [*]]]
       [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]]

[unpack [[spec [[list] [item list]]]
         [examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]]]]

[join [[spec [[item item] [item]]]
       [definition [[[[list?] [++concat +vec]]
                     [[[string?] both?] [++str]]
                     [[[bytes?] both?] [++concat-bytes]]]
                    decide]]
       [examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]
                  [["ab" "cd" join] ["abcd"]]
                  [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]]]]

[range [[spec [[integer integer] [list]]]
        [examples [[[1 5 range] [[1 2 3 4]]]]]]]

[evert [[spec [[list] [list *]]]
        [examples [[[1 2 3 [4 5 6] evert] [[3 2 1] 4 5 6]]]]]]

[and [[spec [[item item] [item]]]
      [examples [[[1 odd? 2 even? and] [true]]]]]]

[or [[spec [[item item] [item]]]
     [examples [[[1 odd? 3 even? or] [true]]]]]]

[not [[spec [[item] [boolean]]]
      [examples [[[1 even? not] [true]]
                 [[false not] [true]]
                 [[true not] [false]]
                 [[[] not] [true]]]]]]

[lexicon [[spec [[] []]]]]

[pack [[spec [[item list] [list]]]
       [definition [[[[swap bytes?]
                      [++conj-byte]]

                     [[swap string?]
                      [!*java.lang.String/valueOf !**concat]]                            

                     [[true] [[+vec] dip ++conj]]]
                    decide]]
       [examples [[[[] 1 pack] [[1]]]
                  [[[1 2 3] 4 pack] [[1 2 3 4]]]
                  [["foo" \d pack] ["food"]]
                  [["foo" bytes 32 pack string] ["foo "]]]]]]

[shield [[spec [[program]
                [item]]]
         [doc "Runs program keeping top of stack produced but protects existing items from being consumed."]
         [definition [[snapshot] dip inject first]]
         [examples [[[1 2 3 [=] shield] [false 3 2 1]]]]]]

[shielddown [[spec [[program item]
                    [item]]]
             [definition [shield swap discard]]
             [examples [[[1 2 3 [=] shielddown] [false 2 1]]]]]]

[shielddowndown [[spec [[[program p] [item consumed] [item consumed]]
                        [[item result]]]]
                 [definition [shield [discard discard] dip]]
                 [examples [[[1 2 3 [+ +] shielddowndown] [6 1]]]]]]

[if [[spec [[[program false-branch]
             [program true-branch]
             [program condition]]
            [*]]]
     [definition [[shield] dipdown branch]]
     [examples [[[5 [5 =] [3 *] [4 +] if] [15]]
                [[6 [5 =] [3 *] [4 +] if] [10]]]]]]

[dipdown [[spec [[program
                  [item a]
                  [item b]]
                 [[item a] [item b] *]]]
          [examples [[[1 2 3 [inc] dipdown] [3 2 2]]]]]]

[every? [[spec [[program list] boolean]]
         [definition [[shielddown] swap prepend ;; building r1, run pred with unary
                      [unpack swap] swap pack ;; add rest of dip program
                      [dip swap not] join ;; add the rest of outer dip
                      wrap [dip or] join ;; add rest of r1
                      ;; put the other recur clauses under r1
                      [false
                       [[[nothing?] shield] dip
                        swap [or] shielddown] ;; the 'if' 
                       [not]] ;; then
                      dip ;; underneath the r1
                      [execute] recur ;; r2 and recur!
                      swap discard]]
         [examples [[[[2 4 6] [even?] every?] [true]]
                    [[[2 4 5] [even?] every?] [false]]
                    [[[] [even?] every?] [true]]
                    [[[2 4 6] [] every?] [true]]
                    [[11 [2 4 6] [+ odd?] every?] [true 11]]
                    [[12 [[even?] [pos?] [3 rem 0 =]] [execute] every?] [true 12]]]]]]

[any? [[spec [[program list] boolean]]
       [definition [[shielddown] swap prepend ;; building r1, run pred with unary
                    [unpack swap] swap pack ;; add rest of dip program
                    [dip swap] join ;; add the rest of outer dip
                    wrap [dip or] join ;; add rest of r1
                    ;; put the other recur clauses under r1
                    [false
                     [[[nothing?] shield] dip
                      swap [or] shielddown] ;; the 'if' 
                     []] ;; then
                    dip ;; underneath the r1
                    [execute] recur ;; r2 and recur!
                    swap discard]]
       [examples [[[[2 4 6] [even?] any?] [true]]
                  [[[3 5 7] [even?] any?] [false]]
                  [[[] [even?] any?] [false]]
                  [[[2 4 6] [] any?] [2]]
                  [[11 [3 5 6] [+ odd?] any?] [true 11]]
                  [[-15 [[even?] [pos?] [3 rem 0 =]] [execute] any?] [true -15]]]]]]

[primrec [[spec [[[program rec1]
                  [program exit]
                  [number data]]
                 [*]]]
          [definition [[execute] swap join ;; add execute to rec1 to be recurs rec2
                       [[discard] swap join] dip ;; add discard to exit condition
                       [[zero?]] dipdown  ;; put the condition on bottom
                       [[clone dec]] dip ;; add the r1
                       recur]] ;; now its generic recur
          [examples [[[5 [1] [*] primrec] [120]]]]]]

[= [[spec [[item item]
           [boolean]]]
    [examples [[[1 1 =] [true]]
               [["hi" "hi" =] [true]]
               [["hi" "there" =] [false]]
               [[[] false =] [false]]
               [[1 "hi" "hi" =] [true 1]]]]]]

[count [[spec [[list]
               [number]]]
        [examples [[[["a" "b" "c"] count] [3]]]]]]

[prepend [[spec [[item list]
                 [list]]]
          [definition [wrap swap join]]
          [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]]

[assert [[spec [[program]
                [*]]]
         [definition [snapshot ;; save stack to print in err message
                      [shield] dip swap ;; run the assertion under the saved stack
                      [discard] ;; if passes, drop the saved stack, dont need
                      [string ["assertion failed "] dip join fail] ;; else throw err
                      branch]]]]

[inject [[spec [[program list]
                [list]]]
         [doc "Inject the quoted program into the list below
                   it (runs the program with the list as its
                   stack).  Does not affect the rest of the stack."]
         [definition [swap evert unpack dip evert]]
         [examples [[[1 2 3 [4 5 6] [* +] inject] [[26] 3 2 1]]]]]]

[snapshot [[spec [[] [list]]]
           [doc "Save the whole stack as a list on the stack"]
           [definition [[] evert clone evert unwrap]]
           [examples [[[1 2 3 snapshot] [[3 2 1] 3 2 1]]
                      [[snapshot] [[]]]]]]]

[first [[spec [[list] [item]]]
        [examples [[[[4 5 6] first] [4]]]]]]

[second [[spec [[list] [item]]]
         [examples [[[[4 5 6] second] [5]]]]]]

[bytes? [[spec [[item] [boolean]]]]]

[string? [[spec [[item] [boolean]]]
         [examples [[["hi" string?] [true]]
                    [["" string?] [true]]
                    [[["hi"] string?] [false]]
                    [[true string?] [false]]]]]]

[word? [[spec [[item] [boolean]]]
        [examples [[[foo word?] [true]]
                   [[[foo] unwrap word?] [true]]
                   [[true word?] [false]]]]]] ;; TODO: but arguably 'true' is a word

[bytes [[spec [[item] [bytes]]]
        [definition [[[[string?] [!*getBytes bytes]]
                      [[+clojure.core/bytes?] [+seq]] ;; convert to immutable byte sequence
                      [[list?] [+pr-str bytes]]] ;; if it's a list we want to serialize it
                     decide]]]]

[map [[spec [[program list] [list]]]
      [definition [[snapshot [] swap] ;; save original stack, and
                   ;; add an empty list to
                   ;; hold results
                   dipdown ;; do this underneath the program and list
                   [wrap swap clone float] ;; program snippet a to
                   ;; copy the original stack
                   ;; that we saved, will make
                   ;; new copy for each item
                   ;; in the list

                   swap pack ;; pack the map program into the
                   ;; partial program a above

                   ;; inject the map program into the stack copy,
                   ;; take the first item and pack it into the
                   ;; result list. the join here is to literally
                   ;; add the list item to the stack copy,
                   ;; without actually executing it, in case its
                   ;; a bare word
                   [[swap join] dip inject first swap [pack] dip]
                   join ;; add the program snippet b above to the
                   ;; snippet a, to get a program for step
                   step ;; step through the above program, using
                   ;; the list as data
                   discard ;; we dont need the copy of the
                   ;; original stack anymore
                  ]]
      [examples [[[[1 2 3] [inc] map] [[2 3 4]]]
                 [[1 [1 2 3] [+] map] [[2 3 4] 1]]
                 [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]]
                 [[7 9 [+] [] map] [[+] 9 7]]]]]]

[filter [[spec [[program list] [list]]]
         [definition [[snapshot [] swap]
                      dipdown
                      ;; clone the original value so we can save it in results if needed
                      [[clone] dip clone wrap swapdown]
                      swap pack
                      [join inject first
                       ;; if passes filter, pack it into results
                       [[pack]]
                       ;; othewise discard it
                       [[discard]]
                       branch
                       swapdown
                       dip]
                      join step discard]]
         [examples [[[[1 2 3] [odd?] filter] [[1 3]]]
                    [[[2 4 6] [odd?] filter] [[]]]
                    [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]]]]

[nothing? [[spec [[item] [boolean]]]
           [definition [[] =]]
           [examples [[[[] nothing?] [true]]
                      [[1 nothing?] [false]]
                      [[false nothing?] [false]]]]]]

[something? [[spec [[item] [boolean]]]
             [definition [nothing? not]]
             [examples [[[1 something?] [true]]
                        [[false something?] [true]]
                        [[[] something?] [false]]]]]]

[while [[spec [[[program body]
                [program pred]]
               [*]]]
        [definition [swap wrap [shield] join ;; add shield to the pred program
                     clone dipdown ;; run it on the previous ToS
                     join loop]]
        [examples [[[3 [0 >] [clone dec] while] [0 1 2 3]]]]]]

[times [[spec [[[program body]
                [integer howmany]]
               [*]]]
        [definition [[dec] swap pack [dip] join ;; build [dec body dip]
                     [0 >] swap
                     while
                     discard]]]]

[pair [[spec [[item item] [list]]]
       [definition [[wrap] dip pack]]
       [examples [[[1 2 pair] [[1 2]]]
                  [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]]]]

[both? [[spec [[program item item] [boolean]]]
        [definition [sink pair swap every?]]
       [examples [[[1 2 [odd?] both?] [false]]
                  [[1 3 [odd?] both?] [true]]]]]]
#+end_src
** The top level
When we're working interactively it'd be nice to have a persistent
state - you can run commands to add things to the stack and execute
words, then examine the results, and repeat. We'll add top level
state, and some functions we can call from the clojure repl to
manipulate it. This will help with debugging.

#+begin_src clojure
(defonce state (atom nil))

(defn clear! []
  (get (reset! state (default-env)) 'stack))

(defn push! [items]
  (get (swap! state (fn [{:syms [expression] :as env}]
                             (eval (assoc env 'expression (concat items expression)))))
       'stack))

;; some debug functions to make debugging less wordy in clojure

(defn- nested-result [program]
  (-> program push! first (dissoc 'dictionary)))

(defn debug! [program]
  (clear!)
  (nested-result [program 'environment]))

(defn step-into! []
  (nested-result ['eval-step]))

(defn step-over! []
  (nested-result ['advance]))

(defn break-when! [condition]
  (nested-result [condition 'swap 'break]))
#+end_src

** Maps/associations
A simple implementation that works well for small lists: specify
associations as lists of pairs.

Then include some words that depend on this functionality.

#+BEGIN_SRC clojure
(in-ns 'kcats.core)

(defn lookup
  [alist k]
  (let [m? (map? alist)]
    (get (if m?
           alist
           (into {} alist))
         k
         [])))

(defn assoc-in
  "Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created."
  {:added "1.0"
   :static true}
  [m [k & ks] v]
  (let [m (into {} m)]
    (if ks
      (assoc m k (assoc-in (get m k) ks v))
      (assoc m k v))))

(def associative-words
  {'associative? (stack-effect [x] [(spec/valid? ::association-list x)])
   'assign (f-stack 3 #'assoc-in)
   'unassign (f-stack 2 (fn [alist key]
                          (vec (remove #(-> % first (= key)) alist))))
   'decide (fn [{[[[test expr :as first-clause]
                   & other-clauses]
                  & others] 'stack
                 :syms [dictionary expression]}]
             {'expression (if first-clause
                             (concat [[test 'shield] ;; run test resetting stack
                                      expr ;; the then
                                      [(vec other-clauses) 'decide] ;; the else
                                      'if]
                                     expression)
                             expression)
              'stack (cond-> others
                        ;; if conditions are empty result is empty list
                        (not first-clause) (conj []))
              'dictionary dictionary})})

(swap! core-words merge (into {}
                              (for [[word f] associative-words]
                                [word {'fn f}])))
#+END_SRC

The rest of the definitions can be added to the lexicon.

#+begin_src kcats :tangle src/kcats/lexicon.kcats
;; Associative words

[associative? [[spec [[item] [boolean]]]]]

[assign [[spec [[[item value]
                 [list keys]
                 association-list]
                [association-list]]]
         [examples [[[[[a b] [c d]] [a] 5 assign]
                     [[[a 5] [c d]]]]

                    [[[[a b] [c d]] [e] 5 assign]
                     [[[a b] [c d] [e 5]]]]

                    [[[[a b] [c [[d e]]]] [c d] 5 assign]
                     [[[a b] [c [[d 5]]]]]]]]]]

[update [[spec [[program [list keys] association-list]
                [association-list]]]
         [definition [[[lookup] shield] dip ;; m ks v p
                      shielddown
                      assign]]
         [examples [[[[[a 1] [b 2]] [b] [inc] update]
                     [[[a 1] [b 3]]]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update]
                     [[[a [[c 4] [d 5]]] [b 2]]]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update]
                     [[[a [[c 15] [d 5]]] [b 2]]]]

                    [[[[a 1] [b 2]] [d] [5] update]
                     [[[a 1] [b 2] [d 5]]]]

                    [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update]
                     [[[a [[c 3] [d 5] [e 11]]] [b 2]]]]]]]]

[lookup [[spec [[[list keys] association-list] [item]]]
         [definition [[[[swap associative?] ;; it's a map
                        ;; [swap something?] ;; it's not empty
                        [something?]] ;; the keylist is not empty
                       [execute]
                       every?]
                      [unpack swap [++lookup] dip] ;; extract the first key and lookup
                      while

                      [something?]
                      ;; fail if we could not drill down all the way
                      ["Lookup attempted on non associative value" fail]
                      [discard]  ;; get rid of remaining keylist
                      if]]
         [examples [[[[[a b] [c d]] [a] lookup] [b]]
                    [[[[a b] [c d]] [e] lookup] [[]]]
                    [[[[outer [[a b] [c d]]]] [outer c] lookup] [d]]]]]]

[unassign [[spec [[[item key] association-list] [association-list]]]
           [examples [[[[[a b] [c d]] a unassign]
                       [[[c d]]]]
                      
                      [[[[a b] [c d]] e unassign]
                       [[[a b] [c d]]]]]]]]

[decide [[spec [[[association-list test-expr-pairs]] [*]]]
         [doc "Takes a list of choices (pairs of test, program) and
                executes the first program whose test passes. if none
                pass, returns 'nothing'. Stack is reset between
                testing conditions."]
         [examples [[[5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide]
                     ["five" 5]]
                    
                    [[9 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide]
                     
                     ["something else" 9]]
                    [[9 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]]
                      decide]
                     [[] 9]]]]]]

;; TODO: fix the case where you just want a value [[type foo]] - only
;; one item but you want the value, not key
[type [[spec [[association-list] [item]]]
       [definition [[count 1 =] ;; if it's a single item
                    [first first] ;; the type is the key of that first item
                    [[type] lookup] ;; otherwise look up the key 'type'
                    if]]
       [examples [[[[[foo 1]] type] [foo]]
                  [[[[type url] [value "http://foo.com"]] type] [url]]]]]]

[value [[spec [[association-list] [item]]]
        [definition [[count 1 =] ;; if it's a single item
                     [first second] ;; the value is the value of that first item
                     [[value] lookup] ;; otherwise look up the key 'value'
                     if]]
        [examples [[[[[foo 1]] value] [1]]
                   
                   [[[[type url] [value "http://foo.com"]] value]
                    ["http://foo.com"]]]]]]
[zip [[spec [[[list values] [list keys]] [association-list]]]
      [definition [[[]] dipdown ;; add empty result below ToS
                   [[unpack wrap] ;; unpack the next key, wrap it
                    ;; to make a "pair" (adding
                    ;; value later)
                    dip ;; run that underneath the current value
                    pack ;; the value into the "pair" we created earlier
                    swap [pack] dip] ;; add the new pair to the results
                   step ;; through all the values
                   discard]] ;; the now-empty list of keys
      [examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]]]]
#+end_src
** Methods
We want a way of adding methods to a word that's already set up as a
simple 'decide' form. This will add the method at the beginning -
adding it at the end is not good because often there's a catchall
condition at the end, and adding beyond that means the new condition
is unreachable. Adding at the beginning is not always what the user
wants either, though. So maybe this could be improved by taking
another argument: a program to combine the item and the existing list
(that defaults to =prepend= here).
#+begin_src kcats :tangle src/kcats/lexicon.kcats
[addmethod [[spec [[[pair condition] [program combinator] word] []]]
            [definition [float ;; work with the word first to get definition: w c b
                         [wrap dictionary swap lookup] shield ;; leave the word and put def on top: def w c b
                         [wrap swap pack] dipdown float ;; [c b] def w 
                         [  ;; b c decide cs
                         float ;; decide b c cs
                         [execute] dip] ;; run combinator which will work on c cs 
                         join inject ;; join with [c b], the above program to run on the definition
                         swap inscribe]]]] ;; redefine word
#+end_src

** Programmable Runtime
*** Basics
In kcats, the interpreter is a pure function of the environment data
it's given (with some caveats). That environment data is representable
as kcats data structures. That means that the kcats interpreter can
take that environment data from anywhere, and do whatever arbitrary
operations on it, including stepping through the execution of the
environment and producing more environment values. In other words,
kcats is its own debugger. I'm not sure if any other languages
implement this feature, certainly it should be straightforward to do
in many stack-based languages. For those familiar with lisp, you know
that you can use lisp to manipulate lisp code at compile time. In
kcats, you similarly have the power to manipulate code before it is
executed. In addition you have the power to manipulate *how* the code
is executed.

Of course, most real programs are not purely functional (they refer to
files on disk or network locations). So that must be taken into
account as always.

What we'll implement here is nested environments - where the outer
environment's stack contains data for an inner environment. The outer
environment can then use words like =eval-step= to step through the
execution of the inner environment, or do whatever other arbitrary
operations on it.
*** Implementation
Let's add some words that help us step through execution of an
environment expressed as kcats data. First some core words to do low
level operations (create an environment to execute a program in, and
also step through the execution of that environment):
#+begin_src clojure
(in-ns 'kcats.core)

(swap! core-words merge
       {'eval-step {'spec '[[environment] [item]]
                    'fn (f-stack 1
                                 (comp eval-step
                                       (partial into {})))} ;; turn kcats data into clj map
        'environment {'spec '[[program] [environment]]
                      'fn (f-stack 1 (comp default-env list*))}})
#+end_src

We can make some handy words to help debug programs.

#+begin_src kcats :tangle src/kcats/lexicon.kcats
[tos [[spec [[environment] [item]]]
      [definition [[stack] lookup first]]
      [examples [[[[[stack [1 2 3]]
                    [expression [[+] step]]]
                   tos]
                  [1]]]]]]

[toe [[spec [[environment] [item]]]
      [definition [[expression] lookup first]]
      [examples [[[[[stack [1 2 3]]
                    [expression [[+] step]]]
                   toe]
                  [[+]]]]]]]

[break [[spec [[environment [program condition]]
               [environment [program condition]]]]
        [definition [[[[[expression] lookup something?] ;; something still in the expression
                       [swap execute not]] ;; check condition not true yet
                      [execute]
                      every?] ;; break?
                     [eval-step]  ;; evaluate the environment one step
                     while]]]]

[advance [[spec [[environment environment]]]
          [definition [[[expression] lookup count] shield swap ;; count up the expression length, we'll run until it's smaller than this
                       
                       [[expression] lookup count
                        [[pos?] [<=]] [execute] every?] ;; only stop if expr empty or shorter than we started off
                       [eval-step]  ;; evaluate the environment one step
                       while]]]]
#+end_src

*** Other examples
**** Count the number of times each word is executed while running a program.

#+begin_src kcats
[[] ;; empty list to put word counts in
 [10 [0 >] [clone dec] while]  ;; the sample program to run
 environment 
 [[expression] lookup something?] ;; something still in the expression, keep running
 [[[expression] lookup first] shield ;; get the item we're about to execute
  swap ;; put it under the environment
  [[word?] ; if it's a word
   [wrap
    [[something?] ;; if word count not empty
     [inc] ;; increment the counter
     [1] ;; if it is empty start the counter at 1
     if]
    update] ;; the results, the count for the word about to execute
   [discard] ;; if it's not a word, do nothing
   if] dip
  eval-step] ;; evaluate the environment one step
 while 
 discard] ;; drop the environment and just report the word counts
#+end_src

**** TODO spec checking
clojure spec check can be replaced with predicate programs, that will
be run with =shield= before the actual word and if it returns false,
will raise an error. 
**** TODO Trace output
#+begin_src kcats
[[0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
 [[expression] lookup something?] ;; break?
 [+print-env eval-step]  ;; evaluate the environment one step
 while]

#+end_src
**** DONE Step count limiting
When testing or debugging, limit the number of steps to avoid a
possible infinite loop.
#+begin_src kcats
[200 ;; step count remaining
 [10 [0 >] [clone dec] while]  ;; the sample program to run
 environment
 
 [[expression] lookup something? ;; something still in the expression
  [pos?] dip and] ;; still step budget remaining
 [eval-step ;; evaluate the environment one step
  [dec] dip] ;; decrease the step budget 
 while
 
 [stack] lookup] ;; return the output
#+end_src
**** DONE Breakpoint
#+begin_src kcats
[[[[toe [+] unwrap =]
   [tos 3 >]]
  [execute]
  every?] ;; when to stop - when we're about to add and tos already >3
 [0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
 [[[[expression] lookup something?] ;; something still in the expression
   [swap execute not]] ;; don't stop yet
  [execute]
  every?] ;; break?
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src
**** TODO Step over
#+begin_src kcats
[[0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
[[expression] lookup count] shield swap;; count up the expression length, we'll run until it's smaller than this
 
 [[expression] lookup count
  [[pos?] [<=]] [execute] every?] ;; only stop if expr empty or shorter than we started off
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src
** Pipes
*** Basics
Pipes help you coordinate - they give you a way to get values from
here to there. You might know where the pipe comes out, but you don't
know or care how it gets there. Pipes should be used for communicating
rather than calculating. You can send or receive from the filesystem
or the network via pipes. You can also use pipes to send or receive
values to/from other environments.

The interface is simple enough - we just need to be able to put values
into a pipe at one end, and take them off at the other. It's also
handy to know whether there's anything in the pipe or not, and whether
the pipe is "full" (nothing more will fit until something at the other
end is removed).

The program doesn't necessarily have access to both ends of the
pipe. For example, when sending data over a socket, the program has
access to the "in" end, but not the "out" (that's on a remote
machine - whatever you put in is sent over the network).

Pipes can also contain infinite sequences, which are handy
sometimes. For example, a pipe that contains 1, 2, 3 etc. Each time
you take from it, you'll get a number one higher than the last. In
reality the pipe doesn't have infinite stuff it it, it's just being
put in as needed.
#+begin_src clojure :tangle src/kcats/pipe.clj
(ns kcats.pipe
  (:require [kcats.core :as core]
            [clojure.spec.alpha :as spec]
            [expound.alpha :as expound])
  (:refer-clojure :exclude [take empty?])
  (:import [java.util.concurrent BlockingQueue ArrayBlockingQueue SynchronousQueue]
           [java.util Queue]))

(defprotocol Select
  (poll [pipe] "Returns a value if available, otherwise nil"))

(defprotocol In
  (put [pipe value] "Puts a value into the pipe, blocks if the pipe is full, returns value on success"))

(defprotocol Out
  (take [pipe] "Takes a value from the pipe, blocks if pipe is empty, returns the value"))

;; a protocol that just marks whether the pipe is generating values
;; itself. The reason to differentiate is that a self-contained pipe
;; can potentially be serialized and sent elsewhere without any loss
(defprotocol SelfContained)
#+end_src

Now we can make some higher level functions that will actually be what
kcats primitives will be defined in terms of.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(def default-sleep 10)

(defn select
  "Takes a coll of pipes. Whichever one is non-empty first, return the
  pipe and the value that was in it."
  [pipes]
  (loop [[this-pipe & remaining-pipes] pipes]
    (if this-pipe
      (if-let [item (poll this-pipe)]
        ;; found it, return the pipe and value as a tuple
        [this-pipe item]
        (recur remaining-pipes))
      ;; everything empty, start over
      (do (Thread/sleep default-sleep)
          (recur pipes)))))

(defn put!
  [pipe value]
  (doto pipe (put value)))

#+end_src

#+begin_src clojure :tangle no
;; TODO: I don't think it makes any sense to make a pipeline when the
;; pipes don't alter the content. We need to really link up envs where
;; each env takes from one pipe, does processing and puts into
;; another.
(defn pipeline
  "Takes a coll of pipes, connects them together into a
  pipeline (starting with the first item's `in` and ending with the
  last item's `out`). Handles moving things through the pipeline
  automatically so that they act as a single pipe."
  [pipes]
  ;; check that we can actually pipeline these pipes (no file/socket
  ;; operations in the middle, etc)
  (doseq [[in out] (partition 2 1 pipes)]
    (if-not (satisfies? Out in)
      (throw (ex-info "Trying to add pipe to pipeline, but we don't have access to the Out end"
                      {:pipe in}))
      (if-not (satisfies? In out)
        (throw (ex-info "Trying to add pipe to pipeline, but we don't have access to the In end"
                        {:pipe out})))))
  ;; start from the end, siphoning things out
  (future (loop [[in out & remaining] pipes]
            (if (and in out)
              (if-let [item (poll in)]
                (if-not (empty )))
              ))))

#+end_src

Now we can define a few different kinds of pipes, starting with simple
"local" types.
*** Closing
When waiting at the end of a pipe for more items to emerge, it'd be
nice to know if whoever's at the other end has gone away (doesn't
intend to ever send anything else). It's also nice to know, when
putting items into a pipe, that whoever is taking them out has gone
away. We'll call that "closing" the pipe, regardless of which end does
it.

This can get a little complicated because often there is more than one
process at one end of the pipe or the other. Imagine 3 people all
standing at the end of a pipe, and all putting items into it, and then
one person seals the pipe shut forever. The other two people might not
appreciate that, if they weren't done with the pipe. Only close the
pipe if you're sure that everyone's done with it.

It may turn out that best practice is to never allow more than one
process per pipe, instead joining pipes together, such that the joint
only closes when all the input pipes close (or the output closes).

This implementation provides no logic (yet) to automatically close a
pipe when all its inputs or outputs close.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defprotocol Close
  (close [pipe] "Closes the pipe from either end")
  (closed? [pipe] "Returns true if the pipe has been closed"))

;; Objects that don't implement the protocol can never be closed but
;; we can still ask if they're closed (it'll always be false)

(defn is-closed
  [obj]
  (and (instance? Close obj) (closed? obj)))

;; or we could also just add a dummy protocol impl to Object

(extend-type Object
  Close
  (close [obj])
  (closed? [obj] false))
#+end_src

We can now implement this on some pipe types
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)
;; some pipes are thin veneers on java concurrent objects

;; TODO: finish close impl
(extend-type BlockingQueue
  In
  (put [q value] (.put q value))
  Out
  (take [q] (.take q))
  Select
  (poll [q] (.poll q)))

(extend-type Queue
  Out
  (take [q] (.poll q))
  Select
  (poll [q] (take q))
  Close
  (close [q] nil)
  (closed? [q] (-> q .peek nil?)))

(defn ->handoff []
  (SynchronousQueue.))
#+end_src
*** Tunnels (bi-directional pipes)
Pipes are a nice construct to get things from here to there, but quite
often we also want to have data flow in both directions. Instead of
having to manually construct two pipes for this purpose, we'll have a
tunnel concept which consists of two pipes, one that is in-only and
other that is out-only. The primary example of this is a network
socket to a remote machine or process.

#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defrecord Tunnel
    [in out]
  In
  (put [tunnel obj]
    (do (put in obj)
        tunnel)) ;; leave the tunnel on the stack, not the in-pipe only
  Select
  (poll [tunnel] (poll out))
  Out
  (take [tunnel] (take out))
  Close
  (close [tunnel]
    (doseq [t [in out]]
      (close t)))
  (closed? [tunnel]
    (or (closed? in)
        (closed? out))))
#+end_src
*** Standard Values
Passes values from in to out - similar to core.async or golang
channels.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(defn ->buffered [buffer-size]
  (ArrayBlockingQueue. buffer-size))

(defn ->filled [coll]
  (let [q (ArrayBlockingQueue. (count coll) false coll)]
    (reify
      Out
      (take [this] (.take q))
      Select
      (poll [this] (.poll q))
      Close
      (close [this] (.clear q))
      (closed? [this] (-> q .size (= 0))))))

#+end_src
*** Atoms
This is a pipe that when you take, always returns the last value
put. It's never full, whatever you put just overwrites what was there
before. It has to be initialized with a value, therefore it's also
never empty. It's functionally equivalent to a clojure atom and is
implemented in terms of one.

Note =swap!= is missing. This maybe could be implemented as =[take]
dip shielddown put= (with the program on top, and the pipe
underneath) - but that is not the same as =swap!= because it lacks the
retry logic (if someone else changed the value while the update is
happening). To fix this, a kcats-native atom is probably
necessary. 

Might be able to get the same sort of functionality from a 2pipe/env
combo that you can send programs to: in-pipe takes programs that act
as swap! fns, out-pipe returns current value. But that is more of a
clojure ref than an atom. 

The problem here is that clojure atoms actually return something when
you =put= into them: the previous value. Pipes don't really have that
swapping feature. They *could* but it seems a little forced since I
can't think of anything else that would use it.

Being able to get and set atomically is pretty hard to do without for
an atom. Maybe atoms should not implement the =In= protocol at all,
and instead have their own separate Atom protocol that has an
=exchange= word (swap is already taken!)

#+begin_src clojure

#+end_src


  For example:
#+begin_src clojure :tangle no
;; swap! is done with a program that replaces previous ToS
;; note no stack items are consumed
10 6 atom [inc +] put .
=>  <Atom 17> 10

;; equivalent of reset! is to just put another value on top
10 6 atom [99] put .
=> <Atom 99> 10

#+end_src
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type clojure.lang.Atom
  In
  (put [a value] (reset! a value))
  Out
  (take [a] (deref a))
  Select
  (poll [a] (take a))
  SelfContained)

(defn ->atom
  "Creates a new atom pipe with initial value v"
  [v]
  (atom v))
#+end_src
*** Timeout
This is an (out) pipe that when you take, it will block for a
predefined period of time (decided when the pipe is created), and then
return the boolean value =true=.

The purpose of this kind of pipe is to use with =select= - where you
have a set of pipes and you want to take from whichever one is
non-empty first. You can include a timeout pipe in there to guarantee
that at least one of them will return something eventually.

#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(deftype Timeout [until-timestamp]
  Out
  (take [this] (let [t (- until-timestamp (System/currentTimeMillis))]
                 (when (pos? t)
                   (Thread/sleep t))
                 true))
  Select
  (poll [this] (or (> (System/currentTimeMillis) until-timestamp) nil)))

(defn ->timeout
  "Creates a new timeout pipe that waits t milliseconds and then
  returns a single value (true) from the pipe"
  [t]
  (->Timeout (+ (System/currentTimeMillis) t)))
#+end_src

*** Input/Output streams
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(extend-type java.io.InputStream
  Out
  (take [is]
    (let [buf (make-array Byte/TYPE 1024)
          bytes-read (.read is buf)]
      (if (= -1 bytes-read)
        (throw (java.io.EOFException. "EOF on inputstream while reading"))
        (let [retbuf (make-array Byte/TYPE bytes-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [is] (take is))
  Close
  (close [is] (.close is))
  (closed? [is] (try (-> is .available (= 0))
                     (catch java.io.IOException ioe
                       true))))

;; add state to remember if InputStream is closed

(defrecord InputStream [is closed?]
  Out
  (take [this]
    (let [buf (make-array Byte/TYPE 1024)
          bytes-read (.read is buf)]
      (if (= -1 bytes-read)
        (reset! closed? true)
        (let [retbuf (make-array Byte/TYPE bytes-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [this] (poll is))
  Close
  (close [is]
    (.close is)
    (reset! closed? true))
  (closed? [is] @closed?))

(defn make-inputstream [is]
  (->InputStream is (atom false)))

(extend-type java.io.OutputStream
  In
  (put [os bs] (doto os (.write bs) (.flush)))
  Close
  (close [os] (doto os (.flush) (.close)))
  (closed? [os] false))
#+end_src

*** Reader/Writers
Unfortunately java Readers (or Readables) don't have any mechanism to
check whether the EOF has been reached without actually doing a
read. So there's no direct way to implement =closed?= without keeping
some extra state, namely of what the status of the last read was. If
it returned -1, then we know EOF has been reached.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

;; Since java Readables can't be queried for closed stream (read just
;; returns -1 but it doesn't keep track of that previous state itself),
;; we'll wrap it in a record that adds a boolean for that state.
(defrecord Reader [rdr closed?]
  Out
  (take [{:keys [rdr closed?]}]
    (let [buf (java.nio.CharBuffer/allocate 1024)
          chars-read (.read rdr buf)]
      (if (= -1 chars-read)
        (do (reset! closed? true)
            (make-array Byte/TYPE 0))
        (let [retbuf (make-array Byte/TYPE chars-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [this] (take this))
  Close
  (close [{:keys [rdr closed?]}]
    (.close rdr)
    (reset! closed? true))
  (closed? [{:keys [closed?]}] @closed?))

(defn make-reader
  [rdr]
  (->Reader rdr (atom false)))

(extend-type Readable
  Out
  (take [rdr]
    (let [buf (java.nio.CharBuffer/allocate 1024)
          chars-read (.read rdr buf)]
      (if (= -1 chars-read)
        (throw (java.io.EOFException. "EOF on reader while reading"))
        (let [retbuf (make-array Byte/TYPE chars-read)]
          (System/arraycopy #^bytes buf 0
                            #^bytes retbuf 0 ^int (alength retbuf))
          retbuf))))
  Select
  (poll [is] (take is))
  Close
  (close [is])
  (closed? [is] (try (-> is .available (= 0))
                     (catch java.io.IOException ioe
                       true))))

#+end_src

*** Sockets
A server socket creates a stream of sockets, 
(one for each accepted connection from a client)

Then a socket has both in and out, via the input/output streams.
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)
(extend-type java.net.Socket
  Out
  (take [s] (try
              (-> s .getInputStream take)
              (catch java.io.EOFException eofe
                )))
  Select
  (poll [s] (-> s .getInputStream poll))
  In
  (put [s obj] (doto s
                 (-> .getOutputStream (put obj))))
  Close
  (close [s] (.close s))
  (closed? [s] (.isClosed s)))

(extend-type java.net.ServerSocket
  Out
  (take [ss] (.accept ss))
  Select
  (poll [ss] (take ss))
  Close
  (close [ss] (.close ss))
  (closed? [ss] (.isClosed ss)))
#+end_src
*** Words
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(expound/def ::in (partial satisfies? In))
(expound/def ::out (partial satisfies? Out))
(expound/def ::core/pipe (spec/or :in ::in
                                  :out ::out))

(->> (for [[w f] {'atom (core/stack-effect [v] [(->atom v)])
                  'buffer (core/stack-effect [s] [(->buffered s)])
                  'timeout (core/stack-effect [t] [(->timeout t)])
                  'filled (core/stack-effect [l] [(->filled l)])
                  'handoff (core/stack-effect [] [(->handoff)]) 
                  'select (core/stack-effect [pipes]
                                             (let [[p v] (select pipes)]
                                               [v p pipes]))
                  'take (core/stack-effect [p] [(take p) p])
                  'put (core/f-stack 2 put)
                  'close (core/stack-effect [p] (do (close p) [p]))
                  'closed? (core/stack-effect [p] [(closed? p)]) 
                  'spawn (fn [{:syms [stack] :as env}]
                           (let [expr (first stack)]
                             (->> expr
                                  core/default-env
                                  core/eval
                                  future))
                           (update env 'stack rest))
                  'stdout (core/f-stack 0 (fn [] System/out))}]
       [w {'fn f}])
     (into {})
     (swap! core/core-words merge))
#+end_src

#+begin_src kcats :tangle src/kcats/lexicon.kcats
[atom [[spec [[item] [pipe]]]]]

[buffer [[spec [[integer] [pipe]]]]]

[timeout [[spec [[integer] [pipe]]]]]

[filled [[spec [[list] [pipe]]]]]

[handoff [[spec [[] [pipe]]]]]

[select [[spec [[[list pipes]] [item pipe [list pipes]]]]]]

[take [[spec [[[pipe out]] [item [pipe out]]]]]]

[put [[spec [[item [pipe in]] [[pipe in]]]]]]

[close [[spec [[[pipe p]] [[pipe p]]]]]]

[closed? [[spec [[pipe] [boolean]]]]]

[pipe-in [[spec [[item] [pipe]]]
          [definition [[[[type [file] unwrap =]
                         [value
                          +clojure.java.io/file
                          +clojure.java.io/output-stream]]
                        [[type [stdout] unwrap =]
                         [stdout]]]
                       decide]]]]

[tunnel [[spec [[item] [pipe]]]
         [definition [[[[type [ip-port] unwrap =]
                        [clone
                         [port] lookup
                         [[address] lookup] dip
                         !**java.net.Socket.]]]
                      decide]]]]

[pipe-out [[spec [[item] [pipe]]]
           [definition [[[[type [file] unwrap =]
                          [value
                           +clojure.java.io/file
                           +clojure.java.io/input-stream
                           +kcats.pipe/make-inputstream]]
                         [[type [ip-port] unwrap =]
                          [[port] lookup !*java.net.ServerSocket.]]
                         [[list?]
                          [+kcats.pipe/->filled]]]
                        decide]]]]

[assemble [[spec [[pipe program] [item]]]
           [definition [swap
                        [take swap] swap pack
                        [dip] join
                        [[closed? not]] dip
                        while
                        discard]]
           [doc "Takes a large value out of a pipe by
                 `take`ing it piece by piece, and assembling the
                 pieces with `reducer`. `reducer` should take a
                 piece, and the so-far assembled value and return a
                 new value with the piece incorporated."]]]

;; TODO: is there any point to this? If we already have a
;; complex/large value in memory, we don't save any memory by
;; breaking it down, we can just shove the whole thing into
;; the pipe with a single put. For flat lists, we can just
;; `[put] step`. Maybe doing the byte conversion piece-wise is
;; useful, so I'm going to keep it for now.
;; At least with the `assemble` we probably don't want to get
;; a 1gb entire file with a single `take` if we end up
;; throwing away most of the contents as we go.
;;
;; As a higher-level abstraction might be useful to have pipes
;; with paired reducer/splitter so the other end knows how to
;; assemble. Maybe send the reducer over the pipe first?
[disassemble [[spec [[program item [pipe in]] [[pipe in]]]]
              [doc "Puts a large value into a pipe by
                    taking it apart with the `splitter`
                    program. This program should take a large value
                    and break it into two parts, such that the
                    topmost will fit into the pipe."]
              [definition [[swap [put] dip] join ;; build a while body that includes splitter
                           [nothing? not] swap
                           while
                           discard]]]] ;; drop the 'nothing' value

;; TODO: definition incomplete
;; while neither pipe is closed, take from input, run
;; program, put into output
[pump [[spec [[program [pipe in] [pipe out]] [[pipe in] [pipe out]]]]
       [definition [wrap [shield] join
                    ;; create a list to use with any
                    [[] sink [pack] dip swapdown [pack] dip
                     [[closed?] any?] dip swap]]]]]

[spit [[spec [[item [item target]] []]]
       [definition [[pipe-in] dip bytes put close discard]]]]

;;[slurp [[spec [[[item target]] [item pipe]]]]]

[spawn [[spec [[program] []]]]]
#+end_src
*** Notes
core.async has an out-of-band close message. Do we need that? Seems
handy but also adds complexity as it becomes an error condition trying
to put/take into a closed pipe, that would then need to be handled.

Seems acceptable to me that pipes are just there and if you want to
tell whoever's at the other end that you're done sending, just send
something that tells them that.

It might be nice for the receiver to be able to let the sender know
he's "hanging up", but I think that function is better handled at a
higher level of abstraction (something built on top of bidirectional
pipes, which is just two pipes with the sender and receiver swapped)
** Crypto
We're going to need to call some platform crypto functions, so lets
make them accessible.
#+begin_src kcats :tangle src/kcats/lexicon.kcats
[hash [[spec [[bytes] [bytes]]]
       [definition [[[[bytes?] [["SHA-256"
                                 !*java.security.MessageDigest/getInstance] dip
                                !**digest +seq]]
                     [[string?] [bytes hash]]
                     [[list?] [string hash]]]
                    decide]]]]

[key [[spec [[item] [bytes]]]
      [definition [bytes

                   ["SHA1PRNG" !*java.security.SecureRandom/getInstance] dip
                   ,*!*setSeed

                   ["EC" !*java.security.KeyPairGenerator/getInstance 256] dip
                   ,*!**initialize 
                   
                   !*generateKeyPair
                   [!*getPublic] shield

                   wrap [ec-keypair] join
                   swap
                   !*getPrivate pack
                   [public type private] swap zip]]]]

[encode [[spec [[[item as] [item data]] [item]]]
         [definition [[[[type base64 =]
                        [discard
                         bytes
                         [!java.util.Base64/getEncoder] dip
                         !**encodeToString]]
                       [[swap type ec-keypair =]
                        [discard
                         [public] lookup
                         !*getEncoded]]]
                      decide]]]]

[decode [[spec [[[item as] [item data]] [item]]]
         [definition [[[[type base64 =]
                        [discard
                         bytes
                         [!java.util.Base64/getDecoder] dip
                         !**decode]]
                       [[type publickey =]
                        [discard
                         !*java.security.spec.X509EncodedKeySpec.
                         "EC" !*java.security.KeyFactory/getInstance
                         swap !**generatePublic]]]
                      decide]]]]

[sign [[spec [[[item message] [bytes key]] [bytes]]]
       [definition [["SHA256withECDSA" !*java.security.Signature/getInstance] dipdown
                    [*!*initSign] dip
                    ,*!*update
                    !*sign]]]]

[verify [[spec [[[item signature] [item message] [item key]] [boolean]]]
         [definition [float ;; key to top
                      ["SHA256withECDSA" !*java.security.Signature/getInstance] dip ;; under key
                      ,*!*initVerify
                      float ;; message to top
                      ,*!*update
                      swap
                      !**verify]]]]

[scriptverify [[spec [[[bytes expected-scripthash]
                       [bytes script]
                       [bytes signature]
                       [bytes message]]
                      [[list failures]]]]
               [definition [[[hash] dip =] ;; make sure the script is the one that is expected
                            [discard ;; the hash
                             execute ;; the script
                             [[]] ;; no failure if script returns true
                             [["Message forgery - script authentication rejected"]]
                             branch] 
                            [discard ;; the hash
                             discard ;; the script
                             discard ;; the sig
                             discard ;; the message
                             ["Message forgery - verification script doesn't match hash"]]
                            if]]]]
#+end_src

#+begin_src clojure :tangle src/kcats/crypto.clj
(ns kcats.crypto
  (:require [kcats.core :as core])
  (:import [java.security MessageDigest SecureRandom KeyPairGenerator Signature]))
#+end_src
#+begin_src kcats
;; in progress example sign
["foo" key [private] lookup
 "We strike at dawn"
 "SHA256withECDSA" .+java.security.Signature/getInstance
 swap discard ;; drop the full key
 [..+initSign] void
 [..+update] void]

;; next iteration
["foo" key 
 "We attack at dawn" bytes 
 [[[private] lookup] dip sign] shield
 ;[discard "bar" key] dipdown ;; try different key for verify
 ;;20 pack ;; add another byte to the sig, to make it invalid
 [[public] lookup] dipdown verify]
#+end_src

We're going to need a way of encoding the public keys. java has its
own (you can call .getEncoded()), and decode like this (haven't tried yet):

#+begin_src java
KeyFactory kf = KeyFactory.getInstance("ECDSA");
PublicKey pubKey2 = kf.generatePublic(new X509EncodedKeySpec(encodedPubKey));
#+end_src

kcats example of key encode/decode
#+begin_src kcats
["foo" key [public] lookup !*getEncoded
 !*java.security.spec.X509EncodedKeySpec.
 "EC" !*java.security.KeyFactory/getInstance
 swap !**generatePublic]

;; should make this part of the 'decode' word somehow
#+end_src

How to encode things like byte arrays. Have to be careful here as byte
arrays are mutable, passing to a pipe can lead to concurrency
issues. But that applies to all mutable objects.
#+begin_src clojure
; encode byte array as base64
(defmethod print-method (Class/forName "[B") [b w]
  (.write w "#bytes \"")
  (.write w (String. (.encode (java.util.Base64/getEncoder) b)))
  (.write w "\""))

(defmethod print-method clojure.lang.ArraySeq$ArraySeq_byte [b w]
  (.write w "#bytes \"")
  (.write w (String. (.encode (java.util.Base64/getEncoder) (.array b))))
  (.write w "\""))

; reading the printed byte array back into bytes
#_(prn (edn/read-string {:readers
                              {'bytes (fn [s]
                                            (.decode (java.util.Base64/getDecoder) s))}}
                             "#bytes \"aGVsbG8gd29ybGQ=\""))

#+end_src

Example of message authenticity script and verification
#+begin_src kcats
["we attack at dawn" bytes ;; the message
 "foo" key ;; create sender's keypair
 [[private] lookup
  swap sign] shield ;; add signature: s/k/m

 ;; now make the verification script
 swap
 [] encode ;; the public key encoded as base64
 wrap [[[publickey []]] decode sink verify] ;; the meat of the script that verifies the message
 join ;; with the encoded pubkey

 ;; get the script hash
 [hash] shield ;; hash/scr/sig/msg
 ;; now mess with the hash to cause failure (commenting out below should result in success)
 ;"foo" bytes join
 
 ;; the actual verify
 ;; arrange as h/sc/si/m
 [[hash] dip =] ;; make sure the script is the one that is expected
 [discard ;; the hash
  ;; mess with the message to make a bad sig
  ;;[" friday" bytes join] dipdown
  execute] ;; the script
 ["Message forgery - verification script doesn't match hash" fail]
 if]
#+end_src
* Experimental Production implmentation
** Status
Experimental, currently learning a new language.
** Base Language
We will use Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
** Project File
#+begin_src toml :tangle Cargo.toml
[package]
name = "kcats"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#rug = "1.15.0"
edn-format = "3.2.3"
base64 = "0.13.0"
internment = "0.6.0" 

[dev-dependencies]
test-case = "2.0.0"
#+end_src
** Stack
Let's start by defining some data structures in a separate module
#+begin_src rust :tangle src/types.rs
use std::collections::VecDeque;
use std::fmt;
use std::{collections::HashMap, hash::Hash};
use std::rc::Rc;
use internment::Intern;
use std::ptr;
use std::hash::Hasher;

pub type Word = Intern<String>;

pub type List = VecDeque<Item>;

pub type KeyList = VecDeque<KeyItem>;

pub type Stack = List;

pub type Bytes = Vec<u8>;

pub type Int = i64;

pub type Float = f64;

#[derive(Clone)]
pub struct BuiltinWord {
    pub word: Word,
    pub f: Rc<StepFn>
}

#[derive(Debug, Clone, PartialEq)]
pub enum Item {
    Int(Int),
    Float(Float),
    Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    Builtin(BuiltinWord),
    List(List),
    Nothing,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum KeyItem {
    Int(Int),
    Boolean(bool),
    Bytes(Bytes),
    String(String),
    Word(Word),
    Builtin(BuiltinWord),
    List(VecDeque<KeyItem>),
    Nothing,
}

#[derive(Debug, Clone, PartialEq)]
pub struct WordDocs {
    pub examples: Option<List>,
    pub spec: Option<List>,
}

pub type StepFn = dyn Fn(Environment) -> StepResult;

pub type AxiomWords = HashMap<Word, StepFn>;

#[derive(Clone)]
pub struct AxiomDef {
    pub docs: WordDocs,
    pub f: Rc<StepFn>
}

// dictionary entries are equal if they have the same function reference,
// no need to compare the function values
impl PartialEq for AxiomDef {
    fn eq(&self, other: &Self) -> bool {
        self.docs == other.docs && ptr::eq(self.f.as_ref(), other.f.as_ref())        
    }
}

impl PartialEq for BuiltinWord {
    fn eq(&self, other: &Self) -> bool {
        self.word == other.word
    }
}

impl Eq for BuiltinWord {}

impl Hash for BuiltinWord {

    fn hash<H: Hasher>(&self, state: &mut H) {
        self.word.hash(state);
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct DerivedDef {
    pub docs: WordDocs,
    pub definition: List,
}

pub trait Doc {
    fn examples(self) -> Option<List>;
}

impl Doc for WordDef {
    fn examples(self) -> Option<List> {
        match self {
            WordDef::Axiom(a) => a.docs.examples,
            WordDef::Derived(a) => a.docs.examples,
        }
    }
}

impl Doc for DerivedDef {
    fn examples(self) -> Option<List> {
        self.docs.examples
    }
}

#[derive(Clone, PartialEq)]
pub enum WordDef {
    Axiom(AxiomDef),
    Derived(DerivedDef),
}

pub type Dictionary = HashMap<Word, WordDef>;

#[derive(Clone, PartialEq)]
pub struct Environment {
    pub stack: Stack,
    pub expression: Stack,
    pub dictionary: Dictionary,
}

#[derive(PartialEq)]
pub struct Error {
    pub environment: Option<Environment>,
    pub message: String,
}

impl From<String> for Error {
    fn from(s: String) -> Self {
        Error {
            environment: None,
            message: s,
        }
    }
}

impl From<&str> for Error {
    fn from(s: &str) -> Self {
        Error::from(s.to_string())
    }
}

impl TryFrom<Item> for List {
    type Error = Error;
    fn try_from(i: Item) -> Result<Self, Self::Error> {
        println!("item is {:?}", i);
        if let Item::List(l) = i {
            println!("cast item is {:?}", l);
            println!("cast item len {}", l.len());

            Ok(l)
        } else {
            Err(Error::from("Expected item to be list, but it wasn't"))
        }
    }
}

pub fn get_item(i: Item, index: usize) -> Option<Item> {
    if let Item::List(l) = i {
        match l.get(index) {
            Some(x) => Some(x.clone()),
            None => None,
        }
    } else {
        None
    }
}

// print out envs in error messages
impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ds = f.debug_struct("Error");
        ds.field("message", &self.message);
        if let Some(env) = &self.environment {
            ds.field("environment", &env);
        }
        ds.finish()
    }
}

impl fmt::Debug for BuiltinWord {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ds = f.debug_struct("BuiltinWord");
        ds.field("word", &self.word);
        ds.finish()
    }
}

pub type StepResult = Result<Environment, Error>;

pub type ItemResult = Result<Item, Error>;

pub fn word(s: &str) -> Item {
    Item::Word(Word::from(s))
}

pub fn to_key_item(i: Item) -> Result<KeyItem, Error> {
    match i {
        Item::Int(i) => Ok(KeyItem::Int(i)),
        Item::String(i) => Ok(KeyItem::String(i)),
        Item::List(l) => Ok(KeyItem::List(
            l.iter()
                .map(|i| to_key_item(i.clone()))
                .collect::<Result<KeyList, Error>>()?,
        )),
        Item::Word(w) => Ok(KeyItem::Word(w)),
        Item::Builtin(w) => Ok(KeyItem::Builtin(w)),
        Item::Boolean(b) => Ok(KeyItem::Boolean(b)),
        Item::Bytes(bs) => Ok(KeyItem::Bytes(bs)),
        Item::Nothing => Ok(KeyItem::Nothing),
        _ => Err(Error::from("item is not allowed as a hashmap key")),
    }
}

pub fn to_value_item(i: KeyItem) -> Item {
    match i {
        KeyItem::Int(i) => Item::Int(i),
        KeyItem::String(i) => Item::String(i),
        KeyItem::List(l) => {
            Item::List(l.iter().map(|i| to_value_item(i.clone())).collect::<List>())
        }
        KeyItem::Word(w) => Item::Word(w),
        KeyItem::Builtin(b) => Item::Builtin(b),
        KeyItem::Boolean(b) => Item::Boolean(b),
        KeyItem::Bytes(bs) => Item::Bytes(bs),
        KeyItem::Nothing => Item::Nothing,
    }
}

pub fn to_entry(mut i: Item) -> Result<(KeyItem, Item), Error> {
    match i {
        Item::List(mut l) => {
            let v = l.pop_back();
            let k = l.pop_back();
            let e = l.pop_back();
            match (k, v, e) {
                (Some(k), Some(v), None) => Ok((to_key_item(k)?, v)),
                _ => Err(Error::from("Item must be a duple")),
            }
        }
        _ => Err(Error::from("Hash entry must be a list (of length 2)")),
    }
}

pub fn to_hash(mut l: List) -> Result<HashMap<KeyItem, Item>, Error> {
    l.iter()
        .map(|i| to_entry(i.clone()))
        .collect::<Result<HashMap<KeyItem, Item>, Error>>()
}

#+end_src

#+RESULTS:
: error: Could not compile `cargoUFeO0S`.

#+begin_src rust :tangle src/main.rs :crates '((rug . "1.15.0") (edn-rs . "0.17.0"))
mod types;
use crate::types::*;
mod axiom;
mod serialize;
use std::collections::HashMap;
use std::io;
use std::iter::FromIterator;
use std::mem;
use std::rc::Rc;
use internment::Intern;

fn eval_step(mut env: Environment) -> StepResult {
    //println!("{:?}", env);
    let next_item = env.expression.pop_front();
    
    if let Some(val) = next_item {
        match val {
            Item::Word(word) => {
                if let Some(dfn) = env.dictionary.get(&word) {
                    match dfn {
                        WordDef::Axiom(d) => (d.f.clone())(env),
                        WordDef::Derived(d) => {
                            let mut items = d.definition.clone();
                            mem::swap(&mut items, &mut env.expression);
                            env.expression.extend(items);

                            Ok(env)
                        }
                    }
                } else {
                    Err(Error {
                        environment: Some(env.clone()),
                        message: format!("Unknown word: {}", word),
                    })
                }
            }
            Item::Builtin(builtin) => {
                Ok((builtin.f)(env)?)
            }
            _ => {
                // not a word, just push onto stack
                env.stack.push_front(val);
                Ok(env)
            }
        }
    } else {
        Err(Error::from("Expression is empty"))
    }
}

fn eval(mut env: Environment) -> StepResult {
    let mut result: StepResult = Result::Ok(env);
    loop {
        if let Ok(env) = result {
            if !env.expression.is_empty() {
                result = eval_step(env);
            } else {
                break Ok(env);
            }
        } else {
            break result;
        }
    }
}

fn print_result(r: StepResult) {
    match r {
        Err(e) => {
            println!("{:#?}", e)
        }
        Ok(env) => {
            let s = env.stack.clone();
            println!("{}", serialize::emit(&Item::List(s)));
        }
    }
}

fn standard_env(program: Option<List>) -> Environment {
    let mut prog_expr = match program {
        Some(p) => Stack::from(p),
        _ => Stack::new(),
    };

    let expr = Stack::from(vec![word("lexicon")]);

    let mut initialized = eval(Environment {
        stack: Stack::new(),
        expression: expr,
        dictionary: axiom::standard_dictionary(),
    })
    .unwrap();

    initialized.expression = prog_expr;
    initialized
}

fn main() {
    let mut program = String::new();
    match io::stdin().read_line(&mut program) {
        Ok(_) => {
            let parsed = serialize::parse(program, &Some(axiom::standard_dictionary()));
            print_result(eval(standard_env(Some(parsed))));
        }
        Err(error) => println!("error: {}", error),
    }
}

fn test_example(mut env: Environment, w: Word, program: List, expected: List) -> Option<Error> {
    let p = program.clone();
    env.expression.extend(program);
    //let res = eval(env).ok()?;
    match eval(env) {
        Err(e) => Some(e),
        Ok(res) => {
            if res.stack == expected {
                None
            } else {
                Some(Error {
                    environment: Some(res.clone()),
                    message: format!(
                        "Result for {} did not match expected: \n{}\n{}",
                        w,
                        serialize::emit(&Item::List(expected)),
                        serialize::emit(&Item::List(p))
                    ),
                })
            }
        }
    }
}

fn test_word(standard_env: Environment, w: Word) -> Vec<Error> {
    if let Some(d) = standard_env.dictionary.get(&w) {
        d.clone()
            .examples()
            .iter()
            .filter_map(|ex| {
                let x = ex.get(0).unwrap().clone();
                if let (Item::List(p), Item::List(exp)) =
                    (get_item(x.clone(), 0).unwrap(), get_item(x, 1).unwrap())
                {
                    test_example(standard_env.clone(), w.clone(), p.clone(), exp.clone())
                } else {
                    Some(Error::from("Invalid example"))
                }
            })
            .collect::<Vec<Error>>()
    } else {
        Vec::new()
    }
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use test_case::test_case;

    use super::*;

    #[test_case("+" ; "plus")]
    #[test_case("-" ; "minus")]
    #[test_case("=" ; "eq")]
    #[test_case(">" ; "gt")]
    #[test_case("branch")]
    #[test_case("clone")]
    #[test_case("count")]
    #[test_case("dip")]
    #[test_case("dipdown")]
    #[test_case("discard")]
    #[test_case("evert")]
    #[test_case("execute")]
    #[test_case("first")]
    #[test_case("float")]
    #[test_case("if")]
    #[test_case("inc")]
    #[test_case("inject")]
    #[test_case("join")]
    #[test_case("list?" ; "is_list")]
    #[test_case("loop")]
    #[test_case("number?" ; "is_number")]
    #[test_case("pack")]
    #[test_case("range")]
    #[test_case("recur")]
    #[test_case("shield")]
    #[test_case("shielddown")]
    #[test_case("shielddowndown")]
    #[test_case("sink")]
    #[test_case("snapshot")]
    #[test_case("step")]
    #[test_case("string?" ; "is_string")]
    #[test_case("swap")]
    #[test_case("swapdown")]
    #[test_case("unpack")]
    #[test_case("unwrap")]
    #[test_case("wrap")]
    fn test_lexicon(word: &str) {
        let e = standard_env(None);
        assert_eq!(test_word(e.clone(), Intern::new(word.to_string())), Vec::<Error>::new());
    }
}

// if let (Item::List(program), Item::List(expected)) = (program, expected) {

//     } else {
//         Err(Error::from("Example should be a pair"))
//     }

// for ex in d.examples().iter() {
//             let e = List::try_from(*ex).ok().unwrap();
//             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
//             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

//             test_example(standard_env.clone(), w, p,exp)
//         }.retain(|i| i.is_some()).collect::<Vec<Error>>()
#+end_src

#+RESULTS:
: error: Could not compile `cargo7G4HYj`.

Here are the axiom functions. Some of them are just functions of the
topmost stack items, and we'll call them with =f_stack1= etc. The rest
modify the expression or dictionary and are functions of the environment.
#+begin_src rust :tangle src/axiom.rs
// some axiom word functions
use super::serialize;
use crate::types::*;
use internment::Intern;
use std::collections::{HashMap, VecDeque};
use std::fs;
use std::mem;
use std::rc::Rc;

fn f_stack1(f: fn(Item) -> ItemResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        if let Some(x) = env.stack.pop_front() {
            env.stack.push_front(f(x)?);
            Ok(env)
        } else {
            stack_underflow()
        }
    }
}

fn f_stack2(f: fn(Item, Item) -> ItemResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        let i = env.stack.pop_front();
        let j = env.stack.pop_front();
        match (i, j) {
            (Some(i), Some(j)) => {
                env.stack.push_front(f(j, i)?);
                Ok(env)
            }
            _ => stack_underflow(),
        }
    }
}

fn axiom_entry<'a>(s: &str, f: Rc<StepFn>) -> (Word, WordDef) {
    (
        Word::from(s),
        WordDef::Axiom(AxiomDef {
            docs: WordDocs {
                examples: None,
                spec: None,
            },
            f: f,
        }),
    )
}

fn unimplemented(s: &'static str) -> (Word, WordDef) {
    axiom_entry(
        s,
        Rc::new(move |_: Environment| Err(Error::from(format!("Unimplemented word: {}", s)))),
    )
}

pub fn standard_dictionary() -> Dictionary {
    HashMap::from([
        axiom_entry("*", Rc::new(f_stack2(mult))),
        axiom_entry("+", Rc::new(f_stack2(plus))),
        axiom_entry("-", Rc::new(f_stack2(minus))),
        axiom_entry("/", Rc::new(f_stack2(div))),
        axiom_entry("<", Rc::new(f_stack2(lt))),
        axiom_entry("<=", Rc::new(f_stack2(lte))),
        axiom_entry("=", Rc::new(env_effect2(eq))),
        axiom_entry(">", Rc::new(f_stack2(gt))),
        axiom_entry(">=", Rc::new(f_stack2(gte))),
        axiom_entry("branch", Rc::new(branch)),
        axiom_entry("clone", Rc::new(clone)),
        axiom_entry("count", Rc::new(env_effect1(count))),
        axiom_entry("dec", Rc::new(f_stack1(dec))),
        axiom_entry("dip", Rc::new(dip)),
        axiom_entry("dipdown", Rc::new(dipdown)),
        axiom_entry("discard", Rc::new(discard)),
        axiom_entry("evert", Rc::new(evert)),
        axiom_entry("execute", Rc::new(execute)),
        axiom_entry("first", Rc::new(env_effect1(first))),
        axiom_entry("float", Rc::new(float)),
        axiom_entry("inc", Rc::new(f_stack1(inc))),
        axiom_entry("join", Rc::new(f_stack2(join))),
        axiom_entry("lexicon", Rc::new(lexicon)),
        axiom_entry("list?", Rc::new(env_effect1(is_list))),
        axiom_entry("loop", Rc::new(env_effect2(loop_))),
        axiom_entry("number?", Rc::new(env_effect1(is_number))),
        axiom_entry("pack", Rc::new(f_stack2(pack))),
        axiom_entry("range", Rc::new(range)),
        axiom_entry("recur", Rc::new(recur)),
        axiom_entry("sink", Rc::new(sink)),
        axiom_entry("step", Rc::new(step)),
        axiom_entry("string?", Rc::new(env_effect1(is_string))),
        axiom_entry("swap", Rc::new(swap)),
        axiom_entry("swapdown", Rc::new(swapdown)),
        axiom_entry("unpack", Rc::new(unpack)),
        axiom_entry("unwrap", Rc::new(unwrap)),
        axiom_entry("wrap", Rc::new(wrap)),
    ])
}

pub fn stack_underflow() -> StepResult {
    Err(Error::from("Stack underflow"))
}

pub fn invalid_type(w: &str) -> Error {
    Error::from(format!("Invalid type for {}", w))
}

pub fn plus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i + j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i + j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float + j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i + j as Float)),
        _ => Err(invalid_type("+")),
    }
}

pub fn minus(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i - j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i - j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float - j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i - j as Float)),
        _ => Err(invalid_type("-")),
    }
}

pub fn mult(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i * j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i * j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float * j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i * j as Float)),
        _ => Err(invalid_type("*")),
    }
}

pub fn div(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i / j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i / j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float / j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i / j as Float)),
        _ => Err(invalid_type("/")),
    }
}

pub fn inc(i: Item) -> ItemResult {
    if let Item::Int(i) = i {
        Ok(Item::Int(i + 1))
    } else {
        Err(invalid_type("inc"))
    }
}

pub fn dec(i: Item) -> ItemResult {
    if let Item::Int(i) = i {
        Ok(Item::Int(i - 1))
    } else {
        Err(invalid_type("dec"))
    }
}

pub fn gt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i > j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i > j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean(i as Float > j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i > j as Float)),

        _ => Err(invalid_type(">")),
    }
}

pub fn lt(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i < j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i < j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean((i as Float) < j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i < j as Float)),

        _ => Err(invalid_type("<")),
    }
}

pub fn gte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i >= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i >= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean(i as Float >= j)),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i >= j as Float)),

        _ => Err(invalid_type(">=")),
    }
}

pub fn lte(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::Int(i), Item::Int(j)) => Ok(Item::Boolean(i <= j)),
        (Item::Float(i), Item::Float(j)) => Ok(Item::Boolean(i <= j)),
        (Item::Int(i), Item::Float(j)) => Ok(Item::Boolean((i as Float).le(&j))),
        (Item::Float(i), Item::Int(j)) => Ok(Item::Boolean(i <= j as Float)),

        _ => Err(invalid_type("<=")),
    }
}

pub fn join(i: Item, j: Item) -> ItemResult {
    match (i, j) {
        (Item::List(mut i), Item::List(j)) => {
            i.extend(j);
            Ok(Item::List(i))
        }
        (Item::String(mut i), Item::String(j)) => {
            i.push_str(&j);
            Ok(Item::String(i))
        }
        _ => Err(invalid_type("join")),
    }
}

pub fn pack(i: Item, j: Item) -> ItemResult {
    match i {
        Item::List(mut i) => {
            i.push_back(j);
            Ok(Item::List(i))
        }
        _ => Err(invalid_type("pack")),
    }
}

pub fn clone(mut env: Environment) -> StepResult {
    if let Some(last) = env.stack.front().map(|v| (*v).clone()) {
        env.stack.push_front(last);
        Ok(env)
    } else {
        stack_underflow()
    }
}

fn swap2(mut env: Environment, offset: usize) -> StepResult {
    let len = env.stack.len();
    if len >= offset + 2 {
        env.stack.swap(offset, offset + 1);
        Ok(env)
    } else {
        stack_underflow()
    }
}

pub fn swap(mut env: Environment) -> StepResult {
    swap2(env, 0)
}

pub fn swapdown(mut env: Environment) -> StepResult {
    swap2(env, 1)
}

pub fn sink(mut env: Environment) -> StepResult {
    if env.stack.len() >= 3 {
        env.stack.swap(0, 2);
        env.stack.swap(0, 1);
        Ok(env)
    } else {
        stack_underflow()
    }
}

pub fn float(mut env: Environment) -> StepResult {
    if env.stack.len() >= 3 {
        env.stack.swap(0, 2);
        env.stack.swap(1, 2);
        Ok(env)
    } else {
        stack_underflow()
    }
}

pub fn discard(mut env: Environment) -> StepResult {
    if let Some(_) = env.stack.pop_front() {
        Ok(env)
    } else {
        stack_underflow()
    }
}

fn extend_front(l: &mut List, mut to_prepend: List) -> () {
    mem::swap(l, &mut to_prepend);
    l.extend(to_prepend);
}

fn append_expression(mut env: Environment, mut items: VecDeque<Item>) -> StepResult {
    extend_front(&mut env.expression, items);
    Ok(env)
}

type EffectResult = Result<(Option<List>, Option<List>), Error>;

pub fn env_effect1(f: fn(Item) -> EffectResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        if let Some(i) = env.stack.pop_front() {
            let (expr_items, stack_items) = f(i)?;
            if expr_items.is_some() {
                extend_front(&mut env.expression, expr_items.unwrap());
            }
            if stack_items.is_some() {
                extend_front(&mut env.stack, stack_items.unwrap());
            }

            Ok(env)
        } else {
            stack_underflow()
        }
    }
}

pub fn env_effect2(f: fn(Item, Item) -> EffectResult) -> impl Fn(Environment) -> StepResult {
    move |mut env: Environment| {
        let i = env.stack.pop_front();
        let j = env.stack.pop_front();
        if let (Some(i), Some(j)) = (i, j) {
            let (expr_items, stack_items) = f(i, j)?;
            if expr_items.is_some() {
                extend_front(&mut env.expression, expr_items.unwrap());
            }
            if stack_items.is_some() {
                extend_front(&mut env.stack, stack_items.unwrap());
            }

            Ok(env)
        } else {
            stack_underflow()
        }
    }
}

pub fn eq(i: Item, j: Item) -> EffectResult {
    Ok((None, Some(List::from(vec![Item::Boolean(i == j)]))))
}

pub fn count(i: Item) -> EffectResult {
    if let Item::List(l) = i {
        Ok((
            None,
            Some(List::from(vec![Item::Int(l.len().try_into().unwrap())])),
        ))
    } else {
        Err(invalid_type("+"))
    }
}

pub fn is_string(i: Item) -> EffectResult {
    Ok((
        None,
        Some(List::from(vec![Item::Boolean(
            if let Item::String(_) = i { true } else { false },
        )])),
    ))
}

pub fn is_number(i: Item) -> EffectResult {
    Ok((
        None,
        Some(List::from(vec![Item::Boolean(
            if let Item::Int(_) | Item::Float(_) = i {
                true
            } else {
                false
            },
        )])),
    ))
}

pub fn is_list(i: Item) -> EffectResult {
    Ok((
        None,
        Some(List::from(vec![Item::Boolean(
            if let Item::List(_) | Item::Nothing = i {
                true
            } else {
                false
            },
        )])),
    ))
}

pub fn first(i: Item) -> EffectResult {
    if let Item::List(mut l) = i {
        let x = List::from(vec![if let Some(i) = l.pop_front() {
            i
        } else {
            Item::Nothing
        }]);
        Ok((None, Some(x)))
    } else {
        Err(invalid_type("+"))
    }
}

pub fn loop_(p: Item, f: Item) -> EffectResult {
    if let Item::List(mut p) = p {
        Ok({
            if is_truthy(f) {
                let p2 = p.clone();
                p.push_back(Item::List(p2));
                p.push_back(word("loop"));
                (Some(p), None)
            } else {
                (None, None)
            }
        })
    } else {
        Err(invalid_type("loop"))
    }
}

pub fn execute(mut env: Environment) -> StepResult {
    if let Some(item) = env.stack.pop_front() {
        match item {
            Item::List(program) => append_expression(env, program),
            _ => Err(invalid_type("+")),
        }
    } else {
        stack_underflow()
    }
}

pub fn wrap(mut env: Environment) -> StepResult {
    if let Some(item) = env.stack.pop_front() {
        let mut v = List::new();
        v.push_front(item);
        env.stack.push_front(Item::List(v));
        Ok(env)
    } else {
        stack_underflow()
    }
}

pub fn unwrap(mut env: Environment) -> StepResult {
    if let Some(item) = env.stack.pop_front() {
        if let Item::List(mut l) = item {
            for i in l {
                env.stack.push_front(i);
            }
            Ok(env)
        } else {
            Err(Error::from(format!(
                "Can only unwrap on list, found {:?}",
                item
            )))
        }
    } else {
        stack_underflow()
    }
}

pub fn dip(mut env: Environment) -> StepResult {
    let s1 = env.stack.pop_front();
    let s2 = env.stack.pop_front();
    match (s1, s2) {
        (Some(item1), Some(item2)) => match item1 {
            Item::List(mut program) => {
                env.expression
                    .push_front(Item::Word(Intern::new("unwrap".to_string())));
                let mut v = List::new();
                v.push_front(item2);

                env.expression.push_front(Item::List(v));
                append_expression(env, program)
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

pub fn dipdown(mut env: Environment) -> StepResult {
    let s1 = env.stack.pop_front();
    let s2 = env.stack.pop_front();
    let s3 = env.stack.pop_front();
    match (s1, s2, s3) {
        (Some(item1), Some(item2), Some(item3)) => match item1 {
            Item::List(program) => {
                env.expression
                    .push_front(Item::Word(Intern::new("unwrap".to_string())));
                let mut v = List::new();
                v.push_front(item2);
                v.push_front(item3);
                env.expression.push_front(Item::List(v));
                append_expression(env, program)
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

pub fn unpack(mut env: Environment) -> StepResult {
    if let Some(mut s1) = env.stack.front_mut() {
        if let Item::List(l) = s1 {
            if let Some(i) = l.pop_front() {
                env.stack.push_front(i);
            }
            Ok(env)
        } else {
            Err(invalid_type("+"))
        }
    } else {
        stack_underflow()
    }
}
fn is_truthy(i: Item) -> bool {
    match i {
        Item::Boolean(b) => b,
        Item::Nothing => false,
        Item::List(l) => !l.is_empty(),
        _ => true,
    }
}

pub fn branch(mut env: Environment) -> StepResult {
    let f = env.stack.pop_front();
    let t = env.stack.pop_front();
    let b = env.stack.pop_front();
    match (f, t, b) {
        (Some(f), Some(t), Some(b)) => match (f, t) {
            (Item::List(false_branch), Item::List(true_branch)) => append_expression(
                env,
                if is_truthy(b) {
                    true_branch
                } else {
                    false_branch
                },
            ),
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

pub fn step(mut env: Environment) -> StepResult {
    let p = env.stack.pop_front();
    let l = env.stack.pop_front();
    match (p, l) {
        (Some(p), Some(l)) => match (p, l) {
            (Item::List(p), Item::List(mut l)) => {
                if let Some(litem) = l.pop_front() {
                    if !l.is_empty() {
                        env.expression.push_front(word("step"));
                        env.expression.push_front(Item::List(p.clone()));
                        env.expression.push_front(Item::List(l));
                    }
                    env.expression.push_front(word("execute"));
                    env.stack.push_front(litem);
                    env.stack.push_front(Item::List(p));
                }
                Ok(env)
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

pub fn range(mut env: Environment) -> StepResult {
    let to = env.stack.pop_front();
    let from = env.stack.pop_front();
    match (from, to) {
        (Some(from), Some(to)) => match (from, to) {
            (Item::Int(from), Item::Int(to)) => {
                env.stack.push_front(Item::List(
                    (from..to).map(|i| Item::Int(i)).collect::<VecDeque<Item>>(),
                ));
                return Ok(env);
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

// (effect [rec2 rec1 then pred]
//                   ['[if]
//[(concat rec1
//         [[pred then rec1 rec2 'recur]] rec2)
// then pred]])

pub fn recur(mut env: Environment) -> StepResult {
    let rec2 = env.stack.pop_front();
    let rec1 = env.stack.pop_front();
    let then = env.stack.pop_front();
    let pred = env.stack.pop_front();
    match (rec2, rec1, then, pred) {
        (Some(rec2), Some(rec1), Some(then), Some(pred)) => match (rec2, rec1, then, pred) {
            (Item::List(rec2), Item::List(rec1), Item::List(then), Item::List(pred)) => {
                env.expression.push_front(word("if"));
                let r = Item::List(List::from([
                    Item::List(pred.clone()),
                    Item::List(then.clone()),
                    Item::List(rec1.clone()),
                    Item::List(rec2.clone()),
                    word("recur"),
                ]));
                let mut e = List::new();
                e.extend(rec1);
                e.push_back(r);
                e.extend(rec2);

                env.stack.push_front(Item::List(pred));
                env.stack.push_front(Item::List(then));
                env.stack.push_front(Item::List(e));
                Ok(env)
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

//(fn [{[l & others] 'stack :as env}]
//            (assoc env 'stack (apply list (vec others) l)))

pub fn evert(mut env: Environment) -> StepResult {
    let l = env.stack.pop_front();
    match l {
        Some(l) => match l {
            Item::List(mut l) => {
                mem::swap(&mut env.stack, &mut l);
                env.stack.push_front(Item::List(l));
                Ok(env)
            }
            _ => Err(invalid_type("+")),
        },
        _ => stack_underflow(),
    }
}

fn key_item(s: &str) -> KeyItem {
    to_key_item(word(s)).unwrap()
}

fn as_list(i: Option<&Item>) -> Option<List> {
    if let Some(i) = i {
        if let Item::List(l) = i {
            Some(l.clone())
        } else {
            None
        }
    } else {
        None
    }
}

fn as_word(i: &KeyItem) -> Option<Word> {
    match i {
        KeyItem::Word(w) => Some(w.clone()),
        KeyItem::Builtin(b) => Some(b.word.clone()),
        _ => None,
    }
}

fn to_lexicon_entry(w: Word, def: HashMap<KeyItem, Item>) -> WordDef {
    //println!("{:?}", def);
    let docs = WordDocs {
        examples: as_list(def.get(&key_item("examples"))),
        spec: as_list(def.get(&key_item("spec"))),
    };
    if let Some(d) = as_list(def.get(&key_item("definition"))) {
        WordDef::Derived(DerivedDef {
            definition: d,
            docs: docs,
        })
    } else {
        WordDef::Axiom(AxiomDef {
            docs: docs,
            f: Rc::new(move |_: Environment| {
                Err(Error::from(format!("Unimplemented word: {}", w)))
            }),
        })
    }
}

pub fn lexicon(mut env: Environment) -> StepResult {
    if let Ok(s) = fs::read_to_string("src/kcats/lexicon.kcats") {
        let items = serialize::parse(s, &Some(standard_dictionary()));
        let vitems = to_hash(List::from(items))?;
        for (k, def) in vitems.iter() {
            let h = to_hash(as_list(Some(def)).unwrap()).ok().unwrap();
            let word = as_word(k).unwrap();
            let newdef = to_lexicon_entry(word, h);
            let newdef2 = newdef.clone();
            env.dictionary
                .entry(word)
                .and_modify(|e| match (e, newdef) {
                    (WordDef::Axiom(a), WordDef::Axiom(new_a)) => {
                        a.docs = new_a.docs;
                    }
                    (WordDef::Derived(d), WordDef::Derived(new_d)) => {
                        d.docs = new_d.docs;
                        d.definition = new_d.definition;
                    }
                    _ => {}
                })
                .or_insert(newdef2);
        }
        Ok(env)
    } else {
        Err(Error::from("Could not read from lexicon file"))
    }
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoUpWAU9`.

Now we'll experiment with parsing edn (so the interpreter can read
input instead of having it hardcoded):

#+begin_src rust :tangle src/serialize.rs :crates '((edn-format . "3.2.2"))
extern crate edn_format;
use crate::types::*;
use std::collections::VecDeque;
use std::fmt;
use internment::Intern;

fn lookup_builtin(w: Word, standard_dictionary: &Option<Dictionary>) -> Item {
    if let Some(dict) = standard_dictionary {
        //println!("Looking up {} in dict of {} words", w, dict.len());
        if let Some(def) = dict.get(&w) {
            if let WordDef::Axiom(a) = def {
                //println!("Compiled builtin! {}", w);
                return Item::Builtin(BuiltinWord {word: w, f: a.f.clone()})
            }
        }
    }
    return Item::Word(w)
}

fn to_item(item: &edn_format::Value, standard_dictionary: &Option<Dictionary>) -> Item {
    match item {
        edn_format::Value::Integer(i) => Item::Int(*i),
        edn_format::Value::Vector(v) => {
            Item::List(v.iter().map(|i| to_item(i, standard_dictionary)).collect::<VecDeque<Item>>())
        }
        edn_format::Value::Symbol(s) => lookup_builtin(Intern::new(s.name().to_string()), standard_dictionary),
        edn_format::Value::Boolean(b) => Item::Boolean(*b),
        edn_format::Value::String(s) => Item::String(s.to_string()),
        edn_format::Value::Float(f) => Item::Float(f.into_inner()),
        _ => Item::Int(0),
    }
}

fn from_item(item: &Item) -> edn_format::Value {
    match item {
        Item::Int(i) => edn_format::Value::Integer(*i),
        Item::List(v) => edn_format::Value::Vector(
            v.iter()
                .map(|i| from_item(i))
                .collect::<Vec<edn_format::Value>>(),
        ),
        Item::Word(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
        Item::Boolean(b) => edn_format::Value::Boolean(*b),
        Item::String(s) => edn_format::Value::String(s.to_string()),
        Item::Float(f) => edn_format::Value::from(*f),
        _ => edn_format::Value::Integer(0),
    }
}

pub fn parse(s: String, standard_dictionary: &Option<Dictionary>) -> List {
    let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
    parser
        .map(move |r| to_item(&r.expect("expected valid element"), standard_dictionary))
        .collect()
}


pub fn emit(item: &Item) -> String {
    edn_format::emit_str(&from_item(item))
}

pub fn emit_all(items: &VecDeque<Item>) -> String {
    let mut s: String = String::new();
    for i in items {
        s.push_str(&emit(&i));
    }
    return s;
}

// print out envs in error messages
impl fmt::Debug for Environment {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{{ stack: {}, expression: {} }}",
               emit(&Item::List(self.stack.clone())),
               emit(&Item::List(self.expression.clone())),
        )
    }
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoVyY4IO`.

#+begin_src rust
// test swap
use std::collections::VecDeque;
type List = Vec<Item>;

type Stack = VecDeque<i32>;
#[derive(Debug)]
enum Item {
    Int(i32),
    List(List),
}

fn main(){
    use std::mem;
    let mut x = List::new();
    x.push(Item::Int(5));
    let mut y = List::new();
    y.push(Item::Int(6));
    //x.push(Item::List(y));
    mem::swap(&mut x, &mut y);
    y.push(Item::List(x));
    println!("{:?}",y);

    let mut v = Stack::new();
    v.push_front(5);
    v.push_front(6);
    println!("{:?}", v);
}

#+end_src

#+RESULTS:
: [Int(5), List([Int(6)])]
: [6, 5]

Test hash of fn
#+begin_src rust :crates
use std::collections::HashMap;
//use std::boxed::Box;
use std::rc::Rc;

struct Env {
    number: Option<i32>,
    dict: HashMap<String, Rc<dyn Fn(Env) -> Env>>
}

fn inc(i: i32) -> i32 {
    i + 1
}

fn make_thing(f: fn(i32) -> i32) -> impl Fn(Env) -> Env {
    move | mut e: Env | {
        if let Some(n) = e.number {
            e.number = Some(f(n));
            e
        } else { e }
        
    }
}

fn main () {
    let mut dict = HashMap::<String, Rc<dyn Fn(Env) -> Env>>::new();
    let i = make_thing(inc);
    dict.insert("inc".to_string(), Rc::new(i));
    let mut env = Env { number: Some(12), dict: dict };
    let f = env.dict.get(&"inc".to_string()).unwrap().clone();
    println!("{}", f(env).number.unwrap());
}
#+end_src

#+RESULTS:
: 13

#+begin_src rust :crates '((edn-format . "3.2.2"))

#+end_src

#+RESULTS:
: error: Could not compile `cargo3d8bm5`.

vec to hashmap
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;

impl<K, V> TryFrom<dyn Iterator<Item = dyn Eq>> for HashMap<K, V>
where K: Eq + Hash,
    
{
    type Error = ();

    fn try_from(v: dyn Iterator<Item = dyn Eq>) -> Result<Self, Self::Error> {
        
        HashMap::from_iter(v.map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {Err()}
        }))
    }
}

fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    let vec = vec![a, b];
    let h: HashMap<i32, i32> = HashMap::from_iter(
        vec.iter().map(|i| {
            if let [k,v] = i[0..2] {
                (k, v)
            }
            else {(0,0)}
        })
    );
    println!("{:?}", h);
}


#+end_src

#+RESULTS:
: error: Could not compile `cargo8MBNov`.

from reddit:
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;
#[derive(Debug)]
struct NotPairsError;

fn to_hashmap<T>(v: Vec<Vec<T>>) -> Result<HashMap<T, T>,NotPairsError>
    where T: Eq + Hash,
{
    v.iter().map(|v| match (v.get(0), v.get(1), v.get(2)) {
        (Some(k), Some(v), None) => Ok((k, v)),
        _ => Err(NotPairsError),
    }).collect()
}


fn main() {
    
    let a = vec![vec!["a", "b"], vec!["c", "d"], vec![]];

    
    println!("{:?}", to_hashmap(a));
}

#+end_src

#+RESULTS:
: error: Could not compile `cargorhVTIG`.

from reddit:

#+begin_src rust :crates '((itertools . "0.10.0"))
use itertools::Itertools;

use std::collections::HashMap;

fn into_hm<I, T, V>(iter: I) -> Result<HashMap<V, V>, String>
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    
}

trait IntoHashMap<T> {
    fn into_hashmap(self) -> Result<HashMap<T, T>, String>;
}

impl<I, T, V> IntoHashMap<V> for I
where
    I: IntoIterator<Item = T>,
    T: IntoIterator<Item = V>,
    V: std::hash::Hash + Eq,
{
    fn into_hashmap(self) -> Result<HashMap<V, V>, String> {
        into_hm(self.into_iter())
    }
}

fn main() {
    let v = vec![vec!["k1", "v1"], vec!["k2", "v2"]];
    println!("{:#?}", v.into_hashmap());
}
#+end_src



#+RESULTS:
: error: Could not compile `cargoTmcGbz`.

edn comment bug - doesn't parse correctly when 2nd line comment in multiline
comment is at beginning of line
#+begin_src rust :crates '((edn-format . "3.2.2"))
extern crate edn_format;

fn main() {
    println!("{:?}", edn_format::parse_str(";; abc\n;; def \n\n ced"));
}
#+end_src

#+RESULTS:
: Err(ParserErrorWithContext { context: [], row: 1, col: 2, error: UnexpectedCharacter(';') })

#+begin_src rust
use std::hash::Hash;
fn into_entry<T, K, V>(k: T, v: V) -> Result<(K, V), String>
where K: Eq + Hash
{
    match k {
        
    }
}
#+end_src

#+RESULTS:

#+begin_src rust
#[derive(Debug)]
enum Value {
    Int(i32),
    Float(f32),
    String(String)
}

#[derive(Debug)]
enum Key {
    Int(i32),
    String(String)
}

fn entry(mut l: Vec<Value>) -> Result<(Key, Value), String> {
    let v = l.pop();
    let k = l.pop();
    let e = l.pop();
    match (k, v, e) {
        (Some(k), Some(v), None) => {
            match (k) {
                Value::Int(k) => { Ok((Key::Int(k), v)) }
                _ => {Err("Key is wrong type".to_string())}
            }
            
        },
        _ => { Err("Entry must be a duple".to_string()) }
    }
}
fn main(){

    let v = vec![Value::Float(1.2), Value::Float(3.12)];
    println!("{:?}", entry(v));
    
}
#+end_src

#+RESULTS:
: Err("Key is wrong type")

* Tools
** Debugging
*** Trace analyzer
**** Overview
We can trace the execution of any program already (see [[Printing]] and
=before-step= option for evaluation). But once we have the trace
output it can be huge and difficult to find the place where things
went wrong.

We can apply a debugger after the fact, just using the trace output -
it contains all the data about what happened. We can do typical debug
operations like =step into=, =step over=, =breakpoint= etc.

**** Emacs lisp
#+begin_src emacs-lisp
;; Some functions to move around in a buffer containing
;; kcats trace output

(require 'parseedn 'parseclj-alist)

(setq kcats.trace/stack-expression-splitter :.)

(defun kcats.trace/split-line
    (parsed-line)
  (let ((splitter-pos (seq-position parsed-line kcats.trace/stack-expression-splitter)))
    (list (seq-subseq parsed-line 0 splitter-pos)
	  (seq-subseq parsed-line (1+ splitter-pos)))))

(defun kcats.trace/parse-current ()
  (interactive)
  (let ((l (thing-at-point 'line t)))
    (with-temp-buffer
      (insert l)
      (goto-char (point-min))
      (parseedn-read `((object . ,#'identity))))))

(defun kcats.trace/expression-depth ()
  (interactive)
  (length (first (kcats.trace/split-line (kcats.trace/parse-current)))))

(defun kcats.trace/step-over-forward ()
  (interactive)
  (let* ((starting-depth (kcats.trace/expression-depth))
	 (current-depth starting-depth)
	 (lines-unmoved 0))
    (while (and (>= current-depth starting-depth)
		(= lines-unmoved 0))
      (setq lines-unmoved (forward-line 1))
      (setq current-depth (kcats.trace/expression-depth))))
  (search-forward " :. "))

(defun kcats.trace/read-lexicon
    ()
  (beginning-of-buffer)
  (setq kcats.trace/lexicon (parseedn-read `((object . ,#'identity)))))

;; Why is there no "step-over-backward"? Because lots of words can end
;; on the same line, we don't know which one we want to search
;; backward for the beginning of. If you are stepping forward through
;; execution and you go too far, use `point-stack-pop' to return to
;; the last place you were.

;; Why is there no step-out? There is no function call stack. We don't
;; know which function we're currently executing, so we can't tell
;; when we've finished it.
#+end_src

#+RESULTS:
: kcats\.trace/step-over-forward

** Developing
*** Emacs mode
#+begin_src emacs-lisp
(defface kcats-brackets 
  '((((class color)) (:foreground "DimGrey" :weight bold)))
  "kcats brackets" :group 'faces)
(defface kcats-stackop 
  '((((class color)) (:foreground "LightGreen" :inherit 'font-lock-keyword-face)))
  "kcats stack manipulation operation" :group 'faces)

(defconst kcats-font-lock-keywords
      `(("\\[\\|\\]" 0 'kcats-brackets)
	(";;.*" 0 'font-lock-comment-face)
	(,(regexp-opt '("swap" "swapdown" "discard" "sink" "float" "clone" "snapshot" "evert") 'words) . (0 font-lock-builtin-face))
	(,(regexp-opt '("true" "false" "[]") 'words) . (0 font-lock-keyword-face))
        (,(regexp-opt '("first" "second" "pack" "unpack" "step" "filter"
			"map" "count" "join" "rest" "wrap" "unwrap" "reverse") 'words) . (0 font-lock-function-name-face))
	(,(regexp-opt '("execute" "dip" "dipdown" "shield" "shielddown" "shielddowndown" "inject"
			"loop" "while" "if" "branch" "recur" "times") 'words) . '(0 font-lock-preprocessor-face))
        ("#?\"" 0 'double-quote prepend)))

(add-hook 'kcats-mode-hook (lambda () (font-lock-add-keywords nil kcats-font-lock-keywords)))

(require 'smie) ;; indentation engine

(setq kcats-mode-syntax-table (let ((table (make-syntax-table)))
    ;; Initialize ASCII charset as symbol syntax
    (modify-syntax-entry '(0 . 127) "_" table)

    ;; Word syntax
    (modify-syntax-entry '(?0 . ?9) "w" table)
    (modify-syntax-entry '(?a . ?z) "w" table)
    (modify-syntax-entry '(?A . ?Z) "w" table)

    ;; Whitespace
    (modify-syntax-entry ?\s " " table)
    (modify-syntax-entry ?\xa0 " " table) ; non-breaking space
    (modify-syntax-entry ?\t " " table)
    (modify-syntax-entry ?\f " " table)
    ;; Setting commas as whitespace makes functions like `delete-trailing-whitespace' behave unexpectedly (#561)
    (modify-syntax-entry ?, "." table)

    ;; Delimiters
    (modify-syntax-entry ?\[ "(]" table)
    (modify-syntax-entry ?\] ")[" table)

    ;; Others
    (modify-syntax-entry ?\; "<" table) ; comment start
    (modify-syntax-entry ?\n ">" table) ; comment end
    (modify-syntax-entry ?\" "\"" table) ; string
    (modify-syntax-entry ?\\ "\\" table) ; escape

    table))

(define-derived-mode kcats-mode fundamental-mode "kcats"
  "major mode for editing kcats."
  (set-syntax-table kcats-mode-syntax-table)
  (setq-local comment-start ";") ;; try ";;"
  (setq-local comment-end "")
  
  (smie-setup nil (lambda (method arg)
		    (when (eq method :list-intro)
		      t)))
  (setq font-lock-defaults '(kcats-font-lock-keywords)))

(add-to-list 'auto-mode-alist '("\\.kcats\\'" . kcats-mode))
(defun my-restart-kcats-mode ()
  (interactive)
  (let ((kcats-mode-hook nil))
    (normal-mode)))
#+end_src

#+RESULTS:
: my-restart-kcats-mode

* Tasks
** DONE Make a reader for the language
needs to support comments. clojure reader probably sufficient?
** DONE stdlib in a separate kcats file
** DONE Nested envs no longer need to convert back and forth
** INPROGRESS More support for nested/related envs
Debuggers, spawning, ingesting etc
** DONE Native spec
Write spec in terms of predicates that return true if what's on the
stack is valid for the word. Probably not easy to get an explanation
as detailed as clojure.spec, but most of the specs should be very
simple list/number/etc.
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?
** TODO Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
* Notes
** Nested env Runtime structure
How do environments that create new environments control execution?

There could be a top level runtime that controls all the environments
(runs them in different threads, etc)

Or it could just be fully programmable where the entry-point env is
responsible for doing whatever it needs. 

The latter seems like the way to go, but what's the control mechanism?
I think threading a separate concern from how an env is executed (as
in, in a debugger etc)

A threadpool is probably fine, futures would probably do it, at least
as a first pass. But there won't be any top level "show me all the
environments" which would be super handy for use in an IDE. One way to
handle this would be - for any env that needs to send messages home to
some IDE, inherit that behavior from its parent and have the top level
env do that. However then there's the matter of how things like
breakpoints etc would be communicated down to where they're needed.

It's important to be able to distinguish between envs whose purpose is
to do the actual job and those that are part of the execution setup
(envs whose only job is to run other envs, say with logging or
debugging). It's kind of hard have a library that introduces a
hierarchy of envs and then still allow the user to debug it.
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+begin_src kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+end_src
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?


* Example programs
** Factorial
*** Recursive definition 
#+begin_src kcats :tangle no
10 
[fact [[clone 0 =]
       [discard 1]
       [clone dec fact *]
       if]]
inscribe
fact
#+end_src
*** Recursive with recur
#+begin_src kcats :tangle no
5
[clone 1 <=]
[]
[clone dec]
[execute *]
recur

5
[1]
[*]

#+end_src
*** Using range
#+begin_src kcats :tangle no
 10
 1 +
 2 swap
 range unpack
 [*] step
#+end_src
*** Plain loop
#+begin_src kcats :tangle no
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src
** Spawn child environments and pipe values back
#+begin_src clojure :tangle no
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[discard] dip ;; done with the pipe
+ ;; add numbers
#+end_src
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
 #+begin_src clojure :tangle no
 100 [0] [[1.0 swap /] dip +] primrec
 [100 0 swap 1 + 1 swap range [1.0 swap / +] step]
 #+end_src
** Primrec
#+begin_src clojure :tangle no
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
** Fibonacci
#+begin_example kcats
[40 [1 0] swap [[[+] shield] inject] times reverse]
#+end_example
** Prime numbers (sieve of eratosthenes)
#+begin_example

[1000 clone 2 swap range ;; all the numbers up to n
  [.+java.lang.Math/sqrt .+java.lang.Math/ceil .int 2] dip  ;; start counter at 2, stop at sqrt of n
  [ [=] dip swap ] ;; stop loop when the counter hits sqrt n
  [] ;; after loop, nothing left to do 
  [ [ [ [=] 
        [swap mod 0 = not]]
      [execute] any?] 
    filter ;; keep the counter but no multiples of it 
    [inc] dip] ;; increment counter
  [execute]
  recur
  [discard discard] dip] ;; drop the original args, just leaving the primes
#+end_example
** Prime factors
#+begin_example kcats
[300

     [] swap 2

     [/ 2 >]
     [ [mod 0 =]
       [clone sink [pack] dipdown / 2]
       [inc]
       if]
     while

     discard pack]
#+end_example
** bidirectional comms from a socket
#+begin_example clojure
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; assembled
 [[type ip-port]
  [address "localhost"]
  [port 9988]] ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 assemble] ;; receive
#+end_example
** Write string to a file
#+begin_example clojure
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_example
** Search the dictionary
#+begin_src kcats
[dictionary ;; put the dictionary of all words onto the stack as key value pairs
 [second ;; the value of one of those pairs
  [spec] lookup ;; look up the spec field
   first ;; the input part of the spec
   [program] =] ;; is it taking a single input, a program?
 filter ;; filter the dictionary using the above criteria
 [first] map] ;; of what remains, just keep the key (which is the word itself)

;; when we run this, we get
[[shield execute assert]]
;; which are the words in the dictionary that take just a program as
;; input.
#+end_src
