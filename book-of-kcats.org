# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a stack-based programming language similar to Joy,
and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Use case
Kcats is meant to primarily act as an approachable expression language
for end users. It will replace complex UI's with gigantic menus, with
an easy to learn language where users can express exactly what they
want. Its programs will generally be small snippets that are easily
shared and built upon.
* Goals
** Easy for a beginner programmer to learn
*** Use as few concepts as possible
The language should use as few concepts as possible. It may include

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ lists
+ Functions
+ Pipes

It will explicitly *not* use

+ Variables
+ Classes
+ Lexical or dynamic scope rules
+ Shared precompiled libraries
*** Easy to understand documentation
**** Documentation by example
By documenting by example only, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

Items inside square brackets [] are quotations.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
false â˜¯ ðŸ’­ true
#+END_EXAMPLE

In the example without knowing in advance what the â˜¯ symbol does, you
can figure out that it's a logical =not= operator.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000.

** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
** Easy to interoperate
For example, everything should be a value, and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received.

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

This language is meant to . There are a myriad of use cases even when the language is
the slowest language on earth.
** Easy static analysis
* Definining some terms
- stack :: A first-in, first-out structure. This is mainly where data
           the program needs to manipulate will be stored.
- aggregate :: A list of items, which can be interpreted either as
               data or executable code.
- program :: an aggregate intended to be executable.
- word :: causes the program to do something, usually taking some
          items from the top of the stack and using them to create new
          stack items. Some words may do nothing but put themselves on
          the stack.
- axiom word :: A word that is defined in the base language, not in
                terms of other words.
- definition :: what exactly a word is supposed to do, represented
                either in the base language for axiom words, or as a
                program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program being evaluated, which needs
                to be broken down into axiom words and executed.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
               or false on the stack.
- pipe :: A method to communicate between stacks and to the outside
          world. Values are put into pipes and emerge elsewhere (in
          the stack, another environment, a file, a socket, etc).
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Base Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library =expound= which gives easier
to understand error messages.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::boolean boolean?)
  (spec/def ::number number?)
  (spec/def ::string string?)
  (spec/def ::bytes bytes?)
  (spec/def ::integer integer?)
#+END_SRC

#+RESULTS:
: :kcats.core/boolean:kcats.core/number:kcats.core/string:kcats.core/bytes:kcats.core/integer

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be aggregates, which we haven't specced yet. That's ok,
recursive specs are allowed. Aggregates contain items, and items
can also be aggregates.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::item
    (spec/or :aggregate ::aggregate
             :boolean ::boolean
             :number ::number
             :string ::string
             :bytes ::bytes
             :word ::word))
#+END_SRC

Now we'll spec an aggregate, which is just a list. We'll use
clojure's vectors (which are indexed lists). We'll also spec out
programs, which are aggregates but intended to be executed (otherwise
there is no difference).

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (expound/def ::aggregate (spec/coll-of ::item :kind vector?) "aggregate?")
  (expound/def ::program ::aggregate)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (def word? symbol?)
  (spec/def ::word word?)

  (spec/def ::axiom-definition (spec/keys :req [::fn ::spec]))
  (spec/def ::program-definition (spec/keys :req [::fn ::definition]))

  (spec/def ::dictionary (spec/map-of ::word (spec/or ::axiom-definition
                                                      ::program-definition)))
#+END_SRC

Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

Since a stack is a list of items, we need to also define what a "stack
item" is - it's any of the types we've specced up until now. 

An expression is also a list of items that are being broken down into
their axiomatic parts.
#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (def stack? (every-pred (complement indexed?) sequential?))

  (spec/def ::stack (spec/coll-of ::item
                                  :kind stack?))

  (spec/def ::expression (spec/coll-of ::item
                                       :kind stack?))

#+END_SRC

Next we'll spec what an Environment is - it's currently just a
dictionary, stack, and expression put together. 

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::environment (spec/keys :req [::stack ::dictionary ::expression]))
#+END_SRC
** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a [[#definitions][program]]. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do and we return the
last environment.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (declare eval-step) ;; we'll define this later

  (defn eval
    [env]
    (->> env
         (iterate eval-step)
         (drop-while (comp seq ::expression))
         first))
#+END_SRC

Now, we define =onto-stack=,
which says what we do to put an item onto the stack. Simple items like
numbers, strings and undefined words, just go straight onto the stack
with no changes.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defmulti onto-stack
    "Evaluate one item in the given environment. A single step in a
    program's execution."
    (fn [{[item] ::expression}]
      (type item)))

  (defn- push
    "Push an item from the expression into the stack"
    [{[item & others] ::expression :as env}]
    (-> env
        (assoc ::expression others)
        (update ::stack conj item)))

  (defmethod onto-stack Number [env]
    (push env))

  (defmethod onto-stack String [env]
    (push env))

  (defmethod onto-stack Boolean [env]
    (push env))

  ;; PersistentVector is the clojure type for an aggregate
  (defmethod onto-stack clojure.lang.PersistentVector [env]
    (push env))

  (defmethod onto-stack (Class/forName "[B") [env]
    (push env))
#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

We'll also specify here what a step of evaluation is - it looks at the
next item in the expression. If it has a definition, it's replaced
with its definition. Otherwise it's put onto the stack.

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.
#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defmethod onto-stack clojure.lang.Symbol [{[word & others] ::expression
                                              ::keys [dictionary stack]
                                              :as env}]
    (let [{f ::fn spec ::spec} (dictionary word)]
      (when spec
        (spec/assert spec stack))
      (if f
        (f (update env ::expression rest))
        (push env))))

  (defn definition
    "Returns the definition of an item, if it's a word defined in terms
    of other words"
    [{::keys [dictionary] :as env} item]
    (some-> dictionary (get item) ::definition))

  (defn eval-step
    "Evaluate one step in the environment."
    [{[next-item & items :as expression] ::expression ::keys [stack dictionary] :as env}]
    (apply println (concat (reverse expression) "." stack))
    (if-let [d (definition env next-item)]
      (assoc env ::expression (concat (list* d) items)) ;; replace item with definition
      ;; eval the thing onto the stack
      (onto-stack env)))
#+END_SRC
** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (defn update-stack [f env]
    (update env ::stack f))

  (defn s-apply
    "Take nitems off the stack, apply them to f. f should return a list
     to put back onto the stack."
    [nitems f stack]
    (let [[a b] (split-at nitems stack)]
      ;; items are reversed so that we can write code with arguments in
      ;; the same order as we'd use in other langs, eg so that [2 1 >]
      ;; -> true
      ;;
      ;; The top item in the stack would normally be the first
      ;; arg, but that was the LAST arg written in the code.
      (into b (apply f (reverse a)))))

  (defn s-apply-one
    "Like s-apply, but useful for functions where you only want to put
     one item back on the stack and f doesn't return a
     list. Automatically creates a list of one item."
    [nitems f stack]
    (s-apply nitems (comp list f) stack))

  (defn f-stack
    "Apply nitems from stack to f, put result back on stack"
    [nitems f]
    (partial update-stack (partial s-apply-one nitems f)))

  (defn inscribe
    "Define a new word. Takes an aggregate off the stack which should be of the
    form:
    [new-word program]"
    [{[[word word-def] & others] ::stack
      ::keys [expression dictionary]}]
    {::stack others
     ::expression expression
     ::dictionary (assoc dictionary word {::definition word-def})})
#+END_SRC

We're going to need to do repeated operations, like the =map= of
functional programming, which means we need a mechanism to clone the
stack and do operations essentially in parallel. Discussion: how do we
do this in a composable way?

We need to support things like map and filter and every?, so it's not
necessarily just "run this program on each stack and collate the
result". For example, every? short circuits to produce =false= when
the first item fails the predicate.

We need an extra mechanism to control how/when those extra programs
are run.

What if we had a stack of stacks? 


#+BEGIN_EXAMPLE
1 inc  ;; map
2 inc
3 inc

1 odd?  ;; filter, every?
2 odd?
3 odd?
#+END_EXAMPLE

I'm not sure that's the right path, when joy/thun are using =cleave=
as a parallelism primitive. We might be able to build something
sufficiently flexible using that - basically doing a transduce using
cleave? I don't know if cleave is quite the right construct because it
only splits in two, and I could only see it being used in a reduce.

There are several things that need to happen:
+ copy stack
+ push item from original list onto stack
+ run program on copy 
+ possibly do something with the resulting to element(s)
+ possibly stop before traversing the entire original list

The undeveloped area seems to be the last two items, how to capture
that in a function or program.

#+BEGIN_SRC clojure 
  (defn parallel
    "Run program(s) by making a stack (list?) of environments. The first program ")

#+END_SRC

Here are some tests for what we
have so far. This test will inscribe a new word, =plus= and then use
it.
#+BEGIN_SRC clojure 
  (k '[1 2 [plus [+]] inscribe plus])
  ;; (3)

  (k '[1 2 3 [4 5 6] [* +] infra])
  ;; ([26] 3 2 1)
#+END_SRC

#+RESULTS:
#+begin_example
class java.lang.ClassCastExceptionclass clojure.lang.ExceptionInfoclass java.lang.ClassCastExceptionclass clojure.lang.ExceptionInfoExecution error (ClassCastException) at kcats.core/inscribe (core.clj:137).
clojure.lang.PersistentVector$ChunkedSeq cannot be cast to clojure.lang.IPersistentStack
Execution error - invalid arguments to kcats.core/eval16830$fn at (core.clj:88).
-- Spec failed --------------------

  ([* +] [3 2 1] 4 5 6)
   ^^^^^

should satisfy

  integer?

-------------------------
Detected 1 error
#+end_example

Now we can go ahead and start filling out axiom words in our default dictionary.

First we'll make some specs so we get a better error message when a
word doesn't get the stack arguments that it needs.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj

  (spec/def ::stack-min-depth-1 (spec/coll-of ::item
                                              :kind stack?
                                              :min-count 1))
  (spec/def ::stack-min-depth-2 (spec/coll-of ::item
                                              :kind stack?
                                              :min-count 2))

  (spec/def ::binary-arithmetic (spec/cat :x ::number
                                          :y ::number
                                          :others (spec/* ::item)))

  (spec/def ::predicate (spec/cat :x ::item
                                  :others (spec/* ::item)))

  (spec/def ::quoted-word (spec/coll-of ::word
                                        :count 1
                                        :kind vector?))

  (def arithmetic-words
    (into {} cat
          [(for [sym ['+ '- '/ '* '< '<= '> '>= 'min 'max 'quot 'rem 'mod]]
             [sym
              {::spec ::binary-arithmetic
               ::fn (f-stack 2 (resolve sym))}])
           (for [sym ['inc 'dec]]
             [sym
              {::spec (spec/cat :x ::number
                                :others (spec/* ::item))
               ::fn (f-stack 1 (resolve sym))}])]))

  (def predicates
    (into {} cat
          [(for [sym ['odd? 'even? 'sequential? 'zero? 'pos? 'neg?
                      'number? 'int? 'true? 'false? 'nil? 'some?
                      'string? 'empty?]]
             [sym {::spec ::predicate
                   ::fn (f-stack 1 (resolve sym))}])
           (for [sym ['starts-with? 'ends-with?]]
             [sym {::spec ::stack-min-depth-2
                   ::fn (f-stack 2 (resolve sym))}])]))

  (def cardinality
    (into {} cat
          [(for [[word num] {'first 1
                             'second 2
                             'third 3
                             'fourth 4
                             'fifth 5
                             'sixth 6
                             'seventh 7
                             'eighth 8
                             'ninth 9
                             'tenth 10}]
             [word {::spec (spec/coll-of ::item
                                         :kind stack?)
                    ::definition [num]}])]))
  (defn roll*
    [[depth distance & others]]
    (let [[top rest] (split-at depth others)
          [a b] (split-at (mod (- distance) depth) top)]
      (concat b a rest)))

  (defn clone*
    [[depth & others]]
    (let [[top rest] (split-at depth others)]
      (concat top (conj rest (last top)))))

  (defn discard*
    [[depth & others]]
    (let [[top [_ & rest]] (split-at (dec depth) others)]
      (concat top rest)))

  (defn dip*
    [{[depth p & others] ::stack
      expression ::expression
      dictionary ::dictionary}]
    (let [[top rest] (split-at depth others)]
      {::stack rest
       ::expression (concat p (reverse top) expression)
       ::dictionary dictionary}))

  (defn recur*
    [{[rec2 rec1 & others] ::stack
      expression ::expression
      dictionary ::dictionary}]
    (let [[then pred] others
          f [pred then rec1 rec2 'genrec]
          else (vec (concat rec1 [f] rec2))]
      {::stack (conj others else)
       ::expression (conj expression 'ifte)
       ::dictionary dictionary}))

  (defn spread*
    "Runs programs with the ability to undo stack effects, also adds
    potential parallelism (not implemented yet). Takes two programs,
    `spread` and `gather`. The `spread` program will be run on the
    current stack, and it should leave an aggregate `programs` on
    top. For each `program` in `programs`, a new temporary environment
    will be created, with the original stack (minus `spread` and
    `gather`), and `program` executed on it. Then all the `tops` of
    those environments' stacks will be gathered up into an aggregate and
    put on another fresh original stack (again without the original top
    two items), and the `gather` program will be executed on it."
    [{[gather spread & others] ::stack
      expression ::expression
      dictionary ::dictionary
      :as env}]
    (let [base-env (assoc env ::stack others)
          spread-env (update base-env ::expression concat spread)
          programs (-> spread-env eval ::stack first)
          tops (for [program programs]
                 (-> base-env
                     (update ::expression concat program)
                     eval
                     ::stack
                     ::first))]
      {::stack (conj others tops)
       ::expression (concat expression gather)
       ::dictionary dictionary}))

  ;; since we'll commonly be defining specs for a stack, we'll nearly
  ;; always not care about anything below a certain depth, so let's make
  ;; a macro that encapsulates that.
  (defmacro stack-spec
    [& args]
    `(spec/cat ~@args
               :others (spec/* ::item)))

  (def builtin-words
    (merge
     arithmetic-words
     predicates
     cardinality
     {'discard {::spec ::stack-min-depth-1
                ::fn (partial update-stack #'discard*)}
      'pop {::spec ::stack-min-depth-1
            ::definition '[1 discard]
            ::examples '[[[1 2 3 pop] [2 1]]
                        [[1 2 3 [a b c] pop] [3 2 1]]]}
      'clone {::spec ::stack-min-depth-1
              ::fn (partial update-stack
                            (fn [[item :as stack]]
                              (conj stack item)))
              ::examples '[[[1 2 3 clone] [3 3 2 1]]]}
      'swap {::spec ::stack-min-depth-2
             #_::fn #_(partial update-stack (fn [[a b & others]]
                                              (-> others
                                                  (conj a)
                                                  (conj b))))
             ::definition '[1 2 roll]
             ::examples '[[[1 2 3 swap] [2 3 1]]]}
      'roll {::spec (spec/coll-of ::item
                                  :kind stack?
                                  :min-count 2) ;; should be dynamic w depth
             ::fn (partial update-stack #'roll*)}
      'execute {::spec (stack-spec :program ::program)
                ::fn (fn [{[p & others] ::stack ::keys [dictionary expression]}]
                       {::stack others
                        ::expression (concat p expression)
                        ::dictionary dictionary})
                ::examples '[[[2 [+] 4 swap execute] [6]]]}
      'dip {::spec (stack-spec :depth integer?
                               :program ::aggregate)
            ::fn #'dip*}
      'quote {::spec (stack-spec :item ::item)
              ::fn (partial update-stack (fn [[item & others]]
                                           (concat others [[item]])))}
      'inscribe {::spec (stack-spec :definition (spec/tuple ::word ::aggregate))
                 ::fn #'inscribe
                 ::examples '[[[[add3 [3 +]] inscribe 5 add3] [8]]]}
      'describe {::spec (stack-spec :word (spec/tuple ::word))
                 ::fn (fn [{[[word] & others] ::stack dict ::dictionary :as env}]
                        (let [dfn (-> dict (get word) ::definition)]
                          (if dfn
                            (assoc env ::stack (conj others dfn))
                            (-> "Word %s is not defined"
                                (format word)
                                Exception.
                                throw))))}
      'branch {::spec (stack-spec :false-branch ::aggregate
                                  :true-branch ::aggregate
                                  :condition ::item)
               ::fn (fn [{[f t b & others] ::stack expression ::expression :as env}]
                      (-> env
                          (assoc ::stack others)
                          (update ::expression concat (if b t f))))}
      'ifte {::spec (stack-spec :false-branch ::aggregate
                                :true-branch ::aggregate
                                :condition ::program)
             ::definition '[[execute] second dip branch]}
      'step {::spec (stack-spec :program ::aggregate
                                :aggregate ::aggregate)
             ::fn (fn [{[p [agg-item & agg-rest] & others] ::stack
                        ::keys [expression dictionary]}]
                    {::expression (concat (cond-> ['execute]
                                            (seq agg-rest) (concat [(vec agg-rest) p 'step]))
                                          expression)
                     ::stack (conj others agg-item p)
                     ::dictionary dictionary})}
      'recur {::spec (stack-spec :rec2 ::program
                                 :rec1 ::program
                                 :true-branch ::program
                                 :false-branch ::program)
              ::fn #'recur*}
      'loop {::spec (stack-spec :program ::program
                                :flag ::item)
             ::fn (fn [{[p f & others] ::stack
                        ::keys [expression dictionary]}]
                    {::stack others
                     ::expression (if f
                                    (concat p [p 'loop] expression)
                                    expression)
                     ::dictionary dictionary})}
      'spread {::spec (stack-spec :gather ::program
                                  :spread ::program)
               ::fn #'spread*} 
      '= {::spec (stack-spec :x ::item, :y ::item)
          ::fn (f-stack 2 =)}
      'pack {::spec (stack-spec :x ::item
                                :aggregate ::aggregate)
             ::fn (f-stack 2 (fn [a x]
                               (conj (vec a) x)))
             ::examples '[[[[] 1 pack] [[1]]]
                         [[[1 2 3] 4 pack] [[1 2 3 4]]]]}
      'unpack {::spec (stack-spec :aggregate ::aggregate)
               ::fn (partial update-stack (fn [[[x & rest] & others]]
                                            (apply list x (vec rest) others)))}
      'count {::spec (stack-spec :aggregate ::aggregate)
              ::fn (partial update-stack (fn [[agg & others]]
                                           (println agg)
                                           (conj others (count agg))))}
      'join {::spec (stack-spec :agg1 ::aggregate
                                :agg2 ::aggregate)
             ::fn (f-stack 2 (comp vec concat))}
      'range {::spec (stack-spec :from ::integer
                                 :to ::integer)
              ::fn (f-stack 2 (comp vec range))}
      'swaack {::spec (stack-spec :list ::aggregate)
               ::doc "Swaps the list on top of the stack and the rest of the stack"
               ::fn (fn [{[a & others] ::stack ::keys [dictionary expression]}]
                      {::stack (apply list (vec others) a)
                       ::expression expression
                       ::dictionary dictionary})}
      'infra {::spec (stack-spec :program ::program
                                 :list ::aggregate)
              ::doc "Accept a quoted program and a list on the stack and run the program
                      with the list as its stack.  Does not affect the rest of the stack."
              ::definition '[swap swaack uncons dip swaack]}
      'some {::spec (stack-spec :program ::aggregate
                                :aggregate ::aggregate ;; TODO finish this
                                )
             ::fn (fn [env]
                    (update-stack
                     (fn [[p a & others :as stack]])))}
      'getfirst {::spec (spec/cat :aggregate ::aggregate, :other (spec/* ::item))
                 ::fn (f-stack 1 first)}
      'map {::spec (stack-spec :program ::aggregate
                               :aggregate ::aggregate)
            ;; runs a parallel simulation - if the map function
            ;; tries to add or remove more stack elements those
            ;; changes will be lost - only top stack element is
            ;; collected from each parallel run of p
            ::fn (fn [env]
                   #_(update-stack (fn [[p a & others :as stack]]
                                     (conj others
                                           (->> (for [item a]
                                                  (eval (with-stack env (conj others item)) p))
                                                (map (comp first :stack))
                                                (into []))))
                                   env))}
      'filter {::spec (stack-spec :program ::aggregate
                                  :aggregate ::aggregate)
               ;; runs a parallel simulation - if the filter function
               ;; tries to add or remove more stack elements those
               ;; changes will be lost - only top stack element is
               ;; collected from each parallel run of p
               ::fn (fn [env]
                      #_(update-stack (fn [[p a & others :as stack]]
                                        (->> a
                                             (filter #(leaves-true? (with-stack env (conj others %)) p))
                                             (into [])
                                             (conj others)
                                             (into [])))
                                      env))}

      'every? {::spec (stack-spec :program ::aggregate
                                  :aggregate ::aggregate)
               ::fn (fn [env]
                      #_(update-stack (fn [[p a & others :as stack]]
                                        (->> a
                                             (every? #(leaves-true? (with-stack env (conj others %)) p))
                                             (conj others)))
                                      env))}
      'and  {::spec (stack-spec :x ::item, :y ::item,)
             ::fn (f-stack 2 #(and %1 %2))}
      'or  {::spec (stack-spec :x ::item, :y ::item,)
            ::fn (f-stack 2 #(or %1 %2))}
      'in  {::spec (stack-spec :aggregate ::aggregate, :item ::item)
            ::fn (f-stack 2 contains?)}
      'intersection {::spec (stack-spec :aggregate-x ::aggregate, :aggregate-y ::aggregate,)
                     ::fn (f-stack 2 (fn [x y]
                                       (into []
                                             (clojure.set/intersection
                                              (into #{} x)
                                              (into #{} y)))))}
      'trace {::spec (stack-spec :program ::aggregate)
              ::fn (fn [{[p & others] :stack :as env}]
                     #_(reduce (fn [env item]
                                 (let [r (eval-one env item)]
                                   (debug r item)
                                   r))
                               (with-stack others)
                               p))}
      'multi {::spec (stack-spec :dispatch ::program)
              ::definition '[quote [execute [] swap get execute] concat]}}))

  (defn k
    "Run a program with the default env and return the result"
    [p]
    (::stack (eval {::stack '()
                    ::dictionary builtin-words
                    ::expression (list* p)})))

  (require '[clojure.test :as test])
  (defn test
    "Run through all the examples in the default env and make sure they work"
    []
    (doseq [[word {::keys [examples]}] builtin-words]
      (test/testing (str word)
        (doseq [[program exp-stack] examples]
          (->> {::stack '()
                ::dictionary builtin-words
                ::expression program}
               eval
               ::stack
               vec
               (= exp-stack)
               test/is)))))
#+END_SRC

#+RESULTS:
: :kcats.core/stack-min-depth-1:kcats.core/stack-min-depth-2:kcats.core/binary-arithmetic:kcats.core/predicate:kcats.core/quoted-word#'kcats.core/arithmetic-words#'kcats.core/predicates#'kcats.core/cardinality#'kcats.core/roll*#'kcats.core/clone*#'kcats.core/discard*#'kcats.core/dip*#'kcats.core/recur*#'kcats.core/spread*#'kcats.core/builtin-words#'kcats.core/k

** Maps/associations
A simple implementation that works well for small lists: specify
associations as lists of pairs.

Then include some words that depend on this functionality.

#+BEGIN_SRC clojure :tangle src/kcats/core.clj
  (spec/def ::pair (spec/coll-of ::item :kind vector? :count 2))

  (spec/def ::association-list (spec/coll-of ::pair
                                             :kind vector?))

  (def builtin-words
    (merge builtin-words
            {'assoc {::spec (spec/cat :item ::pair, :alist ::association-list
                                      :others (spec/* ::item))
                     ::fn (partial update-stack (fn [[item alist & others]]
                                                  (->> alist
                                                       (into {})
                                                       (apply assoc)
                                                       (into [])
                                                       (conj others))))}
             'lookup {::spec (spec/cat ::key ::item
                                       ::map ::association-list)
                      ::fn (partial update-stack (fn [[key alist & others]]
                                                   (conj others
                                                         (get (into {} alist) key []))))}
             'cond {::spec (spec/cat :test-expr-pairs ::association-list
                                     :other (spec/* ::item))
                    ::fn (fn [{[[[test expr :as first-clause]
                                 & other-clauses]
                                & others] ::stack
                               ::keys [dictionary expression]}]
                           {::expression (if first-clause
                                           (concat [test
                                                    expr ;; the then
                                                    [(vec other-clauses) 'cond] ;; the else
                                                    'ifte]
                                                   expression)
                                           expression)
                            ::stack (cond-> others
                                      ;; if cond is empty result is empty list
                                      (not first-clause) (conj []))
                            ::dictionary dictionary})}}))
#+END_SRC

#+RESULTS:
: :kcats.core/pair:kcats.core/association-list#'kcats.core/builtin-words


#+begin_src clojure :tangle src/kcats/core.clj

#+end_src
** Pipes
*** Basics
Pipes are a coordination construct - a way to get values from here to
there, when "there" is further away than a simple function call. In
that sense it "breaks" functional programming by introducing state,
but quite often real programs need to deal with state. That state
could just be something introduced by, and consumed by, the local
environment, or it could be received from another machine thousands of
miles away.

The interface is simple enough - we just need to be able to put values
into a pipe at one end, and take them off at the other. It's also
handy to know whether there's anything in the pipe or not, and whether
the pipe is "full" (nothing more will fit until something at the other
end is removed).

#+begin_src clojure :tangle src/kcats/pipe.clj
  (ns kcats.pipe)

  (defprotocol Pipe
    (put [pipe value] "Puts a value into the pipe, blocks if the pipe is full, returns value on success")
    (take [pipe] "Takes a value from the pipe, blocks if pipe is empty, returns the value")
    (empty? [pipe] "Returns whether the pipe has a value ready to take")
    (full? [pipe] "Returns whether the pipe has space to put a new value"))
#+end_src

Now we can make some higher level functions that will actually be what
kcats primitives will be defined in terms of.
#+begin_src clojure :tangle src/kcats/pipe.clj
  (def default-pause 10) ;; pause this long when polling empty/full

  (defn take!
    "Takes from the given pipe and returns a value, blocks if empty."
    [pipe]
    (loop []
      (if (empty? pipe)
        (do (Thread/sleep default-pause) (recur))
        (take pipe))))

  (defn put!
    "Puts a value into the given pipe and returns it, blocks if full."
    [pipe value]
    (loop []
      (if (full? pipe)
        (do (Thread/sleep default-pause) (recur))
        (do (put pipe value) value))))

  (defn select
    "Takes a coll of pipes. Whichever one is non-empty first, return the
    pipe and the value that was in it."
    [pipes]
    (loop [[this-pipe & remaining-pipes] pipes]
      (if this-pipe
        (if (empty? this-pipe)
          (recur remaining-pipes)
          ;; found it, return the pipe and value as a tuple
          [this-pipe (take! this-pipe)])
        ;; everything empty, start over
        (do (Thread/sleep default-pause)
            (recur pipes)))))
#+end_src

Now we can define a few different kinds of pipes, starting with simple
"local" types.
*** Atoms
This is a pipe that when you take, always returns the last value
put. It's never full, whatever you put just overwrites what was there
before. It has to be initialized with a value. It's functionally
equivalent to a clojure atom and is implemented in terms of one.
#+begin_src clojure :tangle src/kcats/pipe.clj
  (defrecord Atom [a]
      Pipe
    (put [this value] (reset! a value))
    (take [this] @a)
    (empty? [this] false)
    (full? [this] false))

  (defn ->atom
    "Creates a new atom pipe with initial value v"
    [v]
    (->Atom (atom v)))
#+end_src
*** Timeout
This is a pipe that when you take, it will block for a predefined
period of time (decided when the pipe is created), and then return the
boolean value =true=. It is always full (cannot accept puts - it will
just block, doesn't make sense to do it).

The purpose of this kind of pipe is to use with =select= - where you
have a set of pipes and you want to take from whichever one is
non-empty first. You can include a timeout pipe in there to guarantee
that at least one of them will return something eventually.

#+begin_src clojure :tangle src/kcats/pipe.clj
  (defrecord Timeout [until-timestamp]
      Pipe
    (put [this value])
    (take [this] true)
    (empty? [this] (< (System/currentTimeMillis) until-timestamp))
    (full? [this] true))

  (defn ->timeout
    "Creates a new timeout pipe that waits t milliseconds and then
    returns a single value (true) from the pipe"
    [t]
    (->Timeout (+ (System/currentTimeMillis) t)))
#+end_src
*** Notes
core.async has an out-of-band close message. Do we need that? Seems
handy but also adds complexity as it becomes an error condition trying
to put/take into a closed pipe, that would then need to be handled.

Seems acceptable to me that pipes are just there and if you want to
tell whoever's at the other end that you're done sending, just send
something that tells them that.

It might be nice for the receiver to be able to let the sender know
he's "hanging up", but I think that function is better handled at a
higher level of abstraction (something built on top of bidirectional
pipes, which is just two pipes with the sender and receiver swapped)
** Multimethods
These are words that have different behavior depending on what is on
the stack. 
#+BEGIN_SRC clojure :tangle src/kcats/core.clj

#+END_SRC
* Notes
** Instruction set
It might be prudent to define some low level words, and then define
the higher level words in terms of those words. Essentially trading
some performance for portability. Here's a stab at what some of the
low level words would be. We could refer to positions on the stack and
expression with an integer (positive = on stack, negative = on
expression)

- shift* items from the expression to the stack, or vice versa (neg),
  int argument. Oops the problem here is if you shift stuff from
  stack->expr whatever you shifted will get eval'd next, instead of
  what you probably wanted

- move* better than swap as you can specify what you're moving AND how
  far. This has the problem of needing to know how long the section of
  program is that you need to move things past. I'm not sure this is
  useful either, as moving things into the expression is not very useful
  
- exchange* items at the given locations (eg -1 1 swap would swap the
  top of the stack and top of the expression)

- swap* shorthand for 1 2 exchange* (swap the top two items)

- conj* the item on top of the stack into the agg just below it

- concat* the top n (or 2?) items (lists)

- execute* unwrap agg on ToS, move it into expr (to be eval'd)

- discard* get rid of items on the stack

- clone* duplicate items on the stack

- cleave* the env into two, execute the program on ToS on one of
  them, put result on other. drop the mutated env. -  see below

- booleans and* or* not*

- =* 

- branch*

- unwrap* - unwraps the aggregate at position n

- inscribe*

- describe* 

Using this we can define =dip= like this (nope, does not work due to
neg shift being worthless)

#+BEGIN_EXAMPLE
  1 2 swap* -1 shift* conj*

  3 1 2 [* +] . dip
  3 1 [* +] 2 . -1 shift* conj*
  3 1 [* +] . 2 conj*
  3 1 [* + 2]  
#+END_EXAMPLE


ok how about this

#+BEGIN_EXAMPLE
  swap* conj* execute*

  3 4 2 5 [* +] . dip
  3 4 2 5 [* +] . swap* conj* execute*
  3 4 2 [* +] 5 . conj* execute*
  3 4 2 [* + 5] . execute*
  3 4 2 . * + 5
  3 8 . + 5
  11 . 5
  11 5
#+END_EXAMPLE

 re cleave*, seems like there is some overlapping functionality
 between parallelism and preserving the stack for things like
 =nullary=. In both cases we're cloning the environment (or part of
 it) so that multiple modifications don't conflict with each other.

 The only difference is how we join the cloned stacks back together.

 With nullary, we clone the env, run the program on the clone, take
 the top of the stack and put it back on the original. throw the clone
 env away.

 With map, we clone the env (one for each item in the list), run the
 program in parallel on each env, gather up the top items in each env,
 and put it as a list on top of the original stack.

 The question is, can we leverage kcats itself to manage the intra-env
 computations? Seems like theoretically we could - make a new stack
 consisting of the other stacks as list items in the new one. Then you
 can process that arbitrarily and whatever remains can be used. Seems
 like maybe channels should be a dependency here, since that would
 easily pipe the right value back to the right env.

So, what's needed here is another combinator (like genrec etc) that
takes two programs:

+ one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

+ one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the =pop= would drop the =7= off the stack, so we're
testing that it gets resurrected for each item in the list =[1 2 3]=.

Let's define =f= as something that would take the input stack and leave

7 [[1 swap pop inc] [2 swap pop inc] [3 swap pop inc]] (concat'ing the
mapping function program onto each piece of data)

Then that list-of-lists is what's used to make new environments (in
the implementation of cleave*), each top-level item is a program to
run.

Then you'd have 3 environments, after the program had run, stacks look like this:

2
3
4

Then we'd need to specify how map gathers up the top items from this
stack and adds them to the original:

1 3 exchange pop pop

  #+BEGIN_EXAMPLE
So, what's needed here is another combinator (like genrec etc) that
takes two programs:

  ,* one that takes (a clone of) the current stack
  and leaves on top a list of lists (where each item will represent a
  stack in a new env).

  ,* one that takes a list of items that were on top of the various
  stacks, and turns them back into items to be put back on the original
  stack. (in the case of map, noop).

  Let's try an example

  7 [1 2 3] [swap pop inc] map

  In this example, the pop

  map

  7 [1 2 3] [inc] . map

  env1
  7 1 . inc
  7 2

  env2
  7 2 . inc
  7 3

  env3
  7 3 . inc
  7 4


  ,* distribute items f(stack) -> new env(s) expression (in the case of map, enstacken or whatever takes the agg on ToS as the items to be added)
  ,* run all the envs (one per item in the list below ToS) 
  ,* reduce all the ToSs (in the case of map we're already done)

  Let's try nullary

  2 3 [+] nullary

  ,* enstacken
  ,* run all (one)
  ,* conj o
#+END_EXAMPLE
** Dispatch
*** Basics
A multimethod is a function broken into two parts:

+ a dispatch (where the arguments are examined to figure out where to
  send them)
+ method call (based on the dispatch results, pass the same args to
  some other function)

Concatenative languages make composing functions easy so it's possible
all the language needs is a convenient way to create dispatches.

#+BEGIN_EXAMPLE
  [from where] [thing] get => the thing

  network {url "http://foo.com"} get => (a pipe to read data from)
  network {url "http://foo.com"} get bytes => (byte array)

  [foo bar baz quux] mapping foo get => bar
#+END_EXAMPLE

Defining a multifn

#+BEGIN_EXAMPLE
  ;; [program to prepend to method] multi word inscribe
  [type get] multi foo inscribe

  [url [sdf asdf]] foo addmethod
#+END_EXAMPLE

There are a few ways to approach this
*** Approaches
**** Clojure-like 
Tried and true, but requires the implementation of a type hierarchy to
do dispatch by type properly

**** Predicate based
This is where the implementation of multimethods is just =cond=. The
conditions are data (just like everything else) and to add methods,
you just insert a condition. 

A series of predicate/method pairs- Iterate over the pairs, and the
first one where the pred returns true, execute the
method. Performance-wise, it could be slower if there's lots of
methods defined. However there's no dispatch function to execute so in
some cases it could be faster. Ordering of the methods would become
important. For example, if you had a predicate like =object?= (that is
basically always true) you'd have to make sure that's last in the
list.

There's another performance issue - sometimes predicates are expensive
to calculate repeatedly. Let's say you have a list of a billion
integers, and you have a method that is dispatched to with =[int?
every?]=. There's a couple strategies to combat having to examine
every item in that list, especially multiple times:

+ Cache the result as metadata on the value. Predicates could, instead
  of popping the value off the stack and leaving a boolean, leave the
  value but with an added metadata, of which predicate was already run
  on it, and the result. Predicates can short-circuit by seeing if the
  metadata is there before actually running.
+ Allow anyone to populate that metadata. If you know a huge list is
  already going to return true on some predicate, you can just add the
  meta at creation time. Of course this is a foot gun so you have to
  be careful and understand these are assertions that can be wrong.

Generally I am not going to worry about performance yet but I want it
to be addressable with backward compatible additions to the language.

#+begin_example
  ;; basic multimethod pattern
  [clone [[pred1...] [method1]
          [pred2...] [method2]
          ...] 
#+end_example
#+BEGIN_EXAMPLE
  ;; old example code 

  [[odd?] execute [[true [inc]] [false []]] swap get execute]

  ;; so the pattern here is [dispatch-fn execute methods swap get execute]

  ;; if we want to add a method, we can just insert it with add

  ;; we can create an empty multi from a dispatch:

  [[odd?] list [execute [] swap get execute] concat ;; or some such

  ;; then to update an already inscribed method
  [[foo] dup describe ... (updating) ... 

  ;; another way to do this is to just run predicates until one matches,
     that might do away with types entirely and just leave predicates.

  [[int? [+]] [string? [concat]] loop-and-execute ;; loop thru these and
  execute the first program where the pred matches.

  ;; for example
  5 6 [[[int?] [+]] [[string?] [join]] loop-and-execute
  11

  "hi" " there" [[[int?] [+]] [[string?] [join]] loop-and-execute
  "hi there"

  ;; should the predicates leave the value on the stack?
  5 odd?
  5 true
  ;; or drop it?
  5 odd?
  true

  ;; generally we probably still want to keep values that we're running
  ;; a pred on, but maybe best to explicitly clone
  5 clone odd?
  5 true

  ;; or should we actually reset the stack like with map? the benefit is
     that preds don't have to be tidy. but really i can't think of any
     reason they wouldn't be. The whole point of them is that they only
     need one value as input.
#+END_EXAMPLE


** Pipes
This is a general coordination construct. A pipe is a one way
communication channel, you put values in at one end, and take them off
at the other. Where the data actually goes (in memory, over network,
to a file, etc) is up to the implementation.

There are a few words that a pipe needs to respond to:
+ put - put a value into the pipe (may block)
+ take - take a value out of the pipe (may block)
+ close - close the input end of the pipe (no more puts)

And then some higher level words that let you do more complex things:
+ choose - given a list of pipes, block until one has a value ready,
  then return [val pipe].
+ copy - given two pipes, the values that emerge from the first will
  also emerge from the 2nd.
+ dump - given a pipe and an aggregate, put all the items of the
  aggregate into the pipe.

Unlike go/coreasync, there are no non-blocking operations, as envs are
equivalent to go blocks, so everything is in a go block.
#+BEGIN_EXAMPLE
  ;; create a pipe 

  
#+END_EXAMPLE
** Hash maps
*** Use a map literal or not?
Do we add a new literal type for maps? ={a 1 b 2}= ?

Or do we just use a list literal and specify that we want to look at
it like a map? =[a 1 b 2] hashmap=?

Data's just data, should it also carry around how it's supposed to be
looked at? A hashmap is just a list with some optimizations (the data
is grouped by hash so that you can find an item in O(1) time - but you
can always construct a hashmap from a list as the list has all the
data).

All data can be represented as lists (possibly nested), eg a graph
=1->2<-3= is =[[1 2] [3 2]]=

Do we just not bother to turn a list into something else until we
reach a word that expects a certain semantic? for example:

=[a 1 b 2] b get= we're clearly using =get= as a hashmap get, not
trying to get a vector item at an index b. (however if you allowed
integer keys, it would become ambiguous - but let's ignore that for
now). So maybe the language impl can see that we intend to use this
list as a map, and create a hashmap under the covers. (note I no
longer think this is necessary esp for smaller maps. elisp just uses
association lists (O(n) lookup) and for small maps it's actually going
to be faster than hashmap lookup. The vast, vast majority is going to
fall into that category. Hashmaps should be available for larger data
but not the default for literals.
*** Hashmap/ case statement equivalence
There's no difference between a hashmap with get, and a case statement
in this language. So maybe we shouldn't bother with hashmap types? We
could just have a program that we pass around and can modify?
 
=[a 1 b 2] b case=
*** Environments as first class objects
If we can operate on envs on a stack, that might open up some simpler
implementations and/or better abstraction.
#+BEGIN_SRC clojure
  (defn stackify
    "Take the stacks of the given envs and add them to the stack of
    top-level-env"
    [{::keys [stack] :as top-level-env} envs]
    (update top-level-env :stack concat (mapv ::stack envs)))


#+END_SRC
** Types
How do we express types? We're definitely going to want to dispatch
methods based on "type" (whatever that may mean). One approach is to
just treat any map with a =type= field as an object. We'd need some
kind of inheritance functionality to be able to count, say, a =float=
type as a =number= type. However a single =type= may not be expressive
enough. In other languages, a type might be labelled with all the
interfaces or protocols it implements. I'm not sure that's necessary -
to find out if a type has a method implementation, we could possibly
introspect the dictionary and see what methods have a dispatch for
that type. It seems to me that would only be needed for exploratory
purposes (to find out what you can do with a given type), not at
runtime.

#+BEGIN_EXAMPLE
[type get] multi fetch inscribe ;; return bytes
[url [prog to get url]] [fetch] method put ;; uh oh, how do we avoid actually calling fetch here?? needs to be quoted
[[type url] [url "http://google.com"]] fetch
;; or how about a shorthand
[url "http://google/com"] hint fetch ;; where hint converts into a map with 2 values

[file [prog to read file]] [fetch] method put
[file "/tmp/blah.kcats"] hint fetch read eval ;; run a script?
#+END_EXAMPLE

What about generics? How to express "list of int"?

Could we make use of a predicate(s)? eg[ [value 1] [type integer?] ]
*** Discussion
At the lowest level, all values are just a sequence of bits. Machines
might be optimized for certain sizes and operations, but those are
implementation details.

Of course, the problem comes when a program gets a sequence of bits
but doesn't know what it's supposed to do with it. For example the =+=
operator might be intended to do arithmetic addition if the bits are
meant to be numbers, and concatenation if they're meant to be
text. How does it know which one it's got, when they're both just
sequences of bits and there's not necessarily any way to tell?

Type information included along with the value is the "typical"
solution, along with hierarchies etc. At least, there has to be a key
of some kind included that lets the program look up, in some way, what
it's supposed to do with the actual bits given a certain operator or
word.

Let's say there's a key k and the word w. The goal is to have a f(k,
w) that returns a program that manipulates the bits in the desired
way.
*** Predicate based
Since we make use of programs (executable lists) all over the place,
why not for type specification? We could have some native predicates
like =int?= =string?= etc, from which you can build up more complex
type-discerning predicates. Then dispatch is just going thru all the
methods until you hit one that matches.

#+begin_example

#+end_example
** Quoting
Do we need a special quote syntax other than aggregates? I'm thinking
of quoting a single word, (using lisp syntax here) is '(foo)
equivalent to 'foo? Obviously in lisp it isn't. I don't think it will
be in kcats either. For example the equivalent of assoc, it seems
reasonable to use a word as a key, but as soon as you put the word on
the stack, it's executed before we can assoc a value. That's not what
we intended. One way out is to do =[word] unwrap= which would just
leave =word= bare on the stack. Doing this might be rare enough that
it's ok to be that clunky vs making the language more complex to
support =quote=.

There's a couple examples I thought of where we might miss having a
special quote reading function.
 
+ If you want to be able to read a literal list and eval recursively
  so that you get the same access to evaluation in a literal that
  you'd get in other languages. eg in clojure 
  #+begin_src clojure
    {:a (+ 1 1)}
    ;;eval's to
    {:a 2}
  #+end_src
  to get this in kcats you'd have to do something like
  #+begin_src fundamental
    [[a [1 1 +]] eval-recurse
  #+end_src
  The problem here is that when we only have one list construct, we
  can't tell where we're supposed to stop recursing and start
  evaluating. So we might end up recursing into =[1 1 +]= instead of
  executing it as a program. Also, the bare word =a= is a problem,
  it's not supposed to be eval'd in this case. But =eval-recurse= has
  no way to know that.

  The quoting functionality only fixes the latter issue. The former is
  tough because even with a way to distinguish, what's on the stack
  it's evaluating in? What's the equivalent of 
  #+begin_src clojure
    (let [x 3]
      {:a (inc x)
       :b (* x 5)})
  #+end_src
 
  The reality is there isn't an equivalent because in a stack based
  lang, there are no "locals" with names. There are only stack items.
  
  So how would eval-recurse even work? Something like this?
  #+begin_src fundamental 
    1 [1 [1 +]] eval-recurse
    ;; if it's an atom, eval it, otherwise eval-recurse
    1 [1 [1 +]] [eval-recurse] map
    ;; done
    1 [1 2] 
  #+end_src
  
** Feature dependency tree
*** Types
**** Multimethods
***** Pipes
needs multi's because words like get/put should probably be generic
and have specific methods for pipes.
***** 
