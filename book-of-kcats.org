# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Synopsis
This is a literate programming document that will describe the
language =kcats=, a simple stack-based programming language similar to
[[https://en.wikipedia.org/wiki/Joy_(programming_language)][Joy]], and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Motivation
Most programming languages are too hard to learn. There are several
major issues in existing languages, that kcats intends to solve:

+ Existing languages have too many specialized, oddly-shaped tools
  when fewer general-purpose tools would do. Composable pieces beats
  specialization.

+ Existing languages use arcane symbols and terminology. What does an
  exclamation point mean? An asterisk? A double ampersand? What
  is a monad or subclass or a mixin or a thunk? There is no
  justification for the use of symbols. English words convey meaning
  perfectly well - far more people know the word "not", than what
  =!= means in a programming context.

+ Existing languages often provide no means to express short
  programs. You can't write just 1 line of C++ or even python. But you
  will be able to write meaningful kcats expressions that are just a
  few words, and be able to put them into an application to get it to
  do what you want. While typical applications are menu-driven, kcats
  based applications will be message-driven, where a message is some
  words sent to a running program. 
* Goals
** Easy for a beginner programmer to learn
*** Use english words instead of symbols
Kcats syntax is the simplest possible - it's just values (numbers,
words, text, true/false) and quotation marks. No other symbols - no
periods, exclamation points, semicolons, equals, plusses, ampersands,
or asterisks.

Quotations are marked with square brackets, those are the only two
symbols that carry any meaning. 
*** A few simple concepts
The language should use as few concepts as possible, including

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ Lists
+ Functions
+ Pipes

All of these are combined in various ways to achieve any type of
expression, the same way a few types of lego bricks can be combined to
make any object.
*** Easy to understand documentation
**** Documentation by example
By documenting by example, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as input,
then the resulting stack afterward (both the before and after stack
are surrounded with square braces):

#+BEGIN_EXAMPLE
[true ☯] [false]
[false ☯] [true]
#+END_EXAMPLE

In the example without knowing in advance what the =☯= symbol does, you
can figure out that it's a logical =not= operator.

There may be some supplemental english documentation, but the examples
should be sufficient to understand what the words mean.
** Powerful
The language should allow the user to express himself succinctly and
without a lot of ceremony or repetition.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000. The rest of the language would a re-usable
standard library.

While a simple implementation might not perform very well, it's a
start and performance can be improved over time.
** Useful for general programming
The language should be well positioned to handle various types of
programming tasks, including numerical computation, API client/server,
networking applications, machine learning, etc.

** Make tool development as easy as possible
+ Debuggers
+ IDEs

Wherever possible, tooling should be baked into the language.
** Easy to interoperate
For example, everything should be a value[fn:1] and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received).

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

[fn:1] Everything that makes sense to be a value. References to
real-world resources (like files on a particular disk or network
connections to a particular destination, etc) don't make sense to
serialize. The idea here is that non-serializable items will be just
pipes (and perhaps intermediate objects used to create a pipe, like
File objects, Streams etc).

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Static analysis
* Definining some terms
The following concepts are used to build kcats, and anyone who wants
to learn the language should be familiar with them. These terms will
be used throughout this document.
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- list :: One or more items bound up together, which can be
  interpreted either as data (for example, this week's weather
  forecast with high and low temperatures for each day), or executable
  code (for example, what to do with that data to figure out which day
  this week will be the warmest).
- program :: a list intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. 
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program that hasn't been executed yet.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between environments, and to the
  outside world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* How it works
** Basics
At the most basic level, kcats is a stack-based language. The idea is
you put data onto a stack, and then some words that operate on the
items in the stack (which might remove, replace, or add new items)

For example, if we mentally execute the program below, we first put
=1= onto the stack. Then we put =2= onto the stack (so that =2= is on
top and =1= is beneath it). Then we put the word =add= onto the stack
and it will consume the =2= and the =1= and replace them with the sum,
which is =3=.
#+begin_example
1 2 add
=> 3
#+end_example

Multiple steps are accomplished just by adding more words (and
possibly more data). For example, in the program below we can add =1=
and =2= (leaving =3= on the stack), and then put =5= and =multiply= on
the stack (which consumes the =5= and =3=, leaving =15=):

#+begin_example
1 2 add 5 multiply
=> 15
#+end_example

Here's how it would look step by step (where the =|= separates the
program that hasn't run yet - on the right, from the stack on the
left). The stack's top item is just to the left of the =|=.

#+begin_example
              | 1 2 add 5 multiply 
            1 | 2 add 5 multiply 
          1 2 | add 5 multiply
            3 | 5 multiply
          3 5 | multiply
           15 |  
#+end_example

When there is nothing remaining to the right of the =|=, the program
is finished. The result is what is left on the stack (in this case
=15=).

Words can also operate on lists (which will be enclosed in square
brackets, like =[1 2 3]=). You can see below the word =join= combines
two lists.
#+begin_example
[1 2 3] [4 5] join
=> [1 2 3 4 5]
#+end_example

** Programs that write programs
Things get interesting (and powerful) when you realize you can
manipulate programs exactly the same way as you can any other data.

One thing you can do with a list, is treat it like a program and
=execute= it. Notice that on the 5th and 6th line below, the word
=execute= takes the list from the top of the stack on the left, and
puts its contents back on the right, making it part of the program
remaining to be run!
#+begin_example
                      | 4 5 6 [multiply add] execute
                    4 | 5 6 [multiply add] execute
                  4 5 | 6 [multiply add] execute
                4 5 6 | [multiply add] execute
 4 5 6 [multiply add] | execute
                4 5 6 | multiply add
                 4 30 | add
                   34 |
#+end_example
Note that, when =multiply add= gets moved back to the expression,
there wasn't anything else in the expression. But often there would be
something there. =multiply add= would have gone in *front* of anything
else that was there and been executed first. In other words the
expression acts just like a stack - the last thing in is the first
thing out.

The same way we used =join= to combine two lists, we can combine two
small programs into one, and then =execute= it:

#+begin_example
4 5 6 [add] [multiply] join execute
=> 34
#+end_example

Note that words inside lists don't perform any action when the list is
put on the stack. You can think of it as a quote, a message being
passed along and not acted upon until it reaches the recipient.
* Implementations
+ [[file:prototype.org::*Prototype implementation][Prototype implementation]]
+ [[file:production.org::*Production implementation][Production implementation]]
* Using
** Building
*** Dependencies
+ emacs
+ Runtime/compiler for the implemenation you're trying to run

*** Creating the source
The source is contained within these org files, along with annotations
and other non-code information. To generate the source code (that the
runtime or compiler needs as separate files) before running or
building, open the org file for the given implementation, and run
=M-x= =org-babel-tangle=.

See [[*Build without using emacs interactvely][Build without using emacs interactvely]]
*** Building and Running
See the Using heading in the file for the implementation you want to
use.
** Debugging
*** Trace analyzer
**** Overview
We can trace the execution of any program already (see [[Printing]] and
=before-step= option for evaluation). But once we have the trace
output it can be huge and difficult to find the place where things
went wrong.

We can apply a debugger after the fact, just using the trace output -
it contains all the data about what happened. We can do typical debug
operations like =step into=, =step over=, =breakpoint= etc.

**** Emacs lisp
#+begin_src emacs-lisp
;; Some functions to move around in a buffer containing
;; kcats trace output

(require 'parseedn 'parseclj-alist)

(setq kcats.trace/stack-expression-splitter :.)

(defun kcats.trace/split-line
    (parsed-line)
  (let ((splitter-pos (seq-position parsed-line kcats.trace/stack-expression-splitter)))
    (list (seq-subseq parsed-line 0 splitter-pos)
	  (seq-subseq parsed-line (1+ splitter-pos)))))

(defun kcats.trace/parse-current ()
  (interactive)
  (let ((l (thing-at-point 'line t)))
    (with-temp-buffer
      (insert l)
      (goto-char (point-min))
      (parseedn-read `((object . ,#'identity))))))

(defun kcats.trace/expression-depth ()
  (interactive)
  (length (first (kcats.trace/split-line (kcats.trace/parse-current)))))

(defun kcats.trace/step-over-forward ()
  (interactive)
  (let* ((starting-depth (kcats.trace/expression-depth))
	 (current-depth starting-depth)
	 (lines-unmoved 0))
    (while (and (>= current-depth starting-depth)
		(= lines-unmoved 0))
      (setq lines-unmoved (forward-line 1))
      (setq current-depth (kcats.trace/expression-depth))))
  (search-forward " :. "))

(defun kcats.trace/read-lexicon
    ()
  (beginning-of-buffer)
  (setq kcats.trace/lexicon (parseedn-read `((object . ,#'identity)))))

;; Why is there no "step-over-backward"? Because lots of words can end
;; on the same line, we don't know which one we want to search
;; backward for the beginning of. If you are stepping forward through
;; execution and you go too far, use `point-stack-pop' to return to
;; the last place you were.

;; Why is there no step-out? There is no function call stack. We don't
;; know which function we're currently executing, so we can't tell
;; when we've finished it.
#+end_src

#+RESULTS:
: kcats\.trace/step-over-forward

** Developing
*** Emacs mode
#+begin_src emacs-lisp
(defface kcats-brackets 
  '((((class color)) (:foreground "DimGrey" :weight bold)))
  "kcats brackets" :group 'faces)
(defface kcats-stackop 
  '((((class color)) (:foreground "LightGreen" :inherit 'font-lock-keyword-face)))
  "kcats stack manipulation operation" :group 'faces)

(defconst kcats-font-lock-keywords
      `(("\\[\\|\\]" 0 'kcats-brackets)
	(";;.*" 0 'font-lock-comment-face)
	(,(regexp-opt '("swap" "swapdown" "discard" "sink" "float" "clone" "snapshot" "evert") 'words) . (0 font-lock-builtin-face))
	(,(regexp-opt '("true" "false" "[]") 'words) . (0 font-lock-keyword-face))
        (,(regexp-opt '("first" "second" "pack" "unpack" "step" "filter"
			"map" "count" "join" "rest" "wrap" "unwrap" "reverse") 'words) . (0 font-lock-function-name-face))
	(,(regexp-opt '("execute" "dip" "dipdown" "shield" "shielddown" "shielddowndown" "inject"
			"loop" "while" "if" "branch" "recur" "times") 'words) . '(0 font-lock-preprocessor-face))
        ("#?\"" 0 'double-quote prepend)))

(add-hook 'kcats-mode-hook (lambda () (font-lock-add-keywords nil kcats-font-lock-keywords)))

(require 'smie) ;; indentation engine

(setq kcats-mode-syntax-table (let ((table (make-syntax-table)))
    ;; Initialize ASCII charset as symbol syntax
    (modify-syntax-entry '(0 . 127) "_" table)

    ;; Word syntax
    (modify-syntax-entry '(?0 . ?9) "w" table)
    (modify-syntax-entry '(?a . ?z) "w" table)
    (modify-syntax-entry '(?A . ?Z) "w" table)

    ;; Whitespace
    (modify-syntax-entry ?\s " " table)
    (modify-syntax-entry ?\xa0 " " table) ; non-breaking space
    (modify-syntax-entry ?\t " " table)
    (modify-syntax-entry ?\f " " table)
    ;; Setting commas as whitespace makes functions like `delete-trailing-whitespace' behave unexpectedly (#561)
    (modify-syntax-entry ?, "." table)

    ;; Delimiters
    (modify-syntax-entry ?\[ "(]" table)
    (modify-syntax-entry ?\] ")[" table)

    ;; Others
    (modify-syntax-entry ?\; "<" table) ; comment start
    (modify-syntax-entry ?\n ">" table) ; comment end
    (modify-syntax-entry ?\" "\"" table) ; string
    (modify-syntax-entry ?\\ "\\" table) ; escape

    table))

(define-derived-mode kcats-mode fundamental-mode "kcats"
  "major mode for editing kcats."
  (set-syntax-table kcats-mode-syntax-table)
  (setq-local comment-start ";") ;; try ";;"
  (setq-local comment-end "")
  
  (smie-setup nil (lambda (method arg)
		    (when (eq method :list-intro)
		      t)))
  (setq font-lock-defaults '(kcats-font-lock-keywords)))

(add-to-list 'auto-mode-alist '("\\.kcats\\'" . kcats-mode))
(defun my-restart-kcats-mode ()
  (interactive)
  (let ((kcats-mode-hook nil))
    (normal-mode)))
#+end_src

#+RESULTS:
: my-restart-kcats-mode
*** org-babel mode
#+begin_src emacs-lisp
(defun org-babel-execute:kcats (body params)
  "Execute a block of kcats code with org-babel."
  (org-babel-eval
   kcats-babel-executable
   body))

(defcustom kcats-babel-executable "kcats"
  "Location of the kcats binary"
  :type 'string
  :group 'kcats-babel)
#+end_src
* Contributing
** Bug reports
Instead of opening a github issue, add a =TODO= subheading to the
[[*Issues][Issues]] heading. Commit the change and submit it as a pull request. In
the branch where that issue is being fixed, it will be changed to
=INPROGRESS=. When the issue is fixed, the heading will be
removed. (If you disagree that it's been fixed, submit a PR that
reverts the commit to remove it).

You can edit this file right on github, in your own fork of the
project, if you prefer.

Why do things this weird way? I don't want to rely on github, nice as
it is.
* Issues
** TODO Build without using emacs interactvely
Users should not be required to know emacs to build the project, only
have it installed. The build should be accessible from bash without
having to use emacs interactively. 
** TODO Remove platform interop from lexicon
That was only there as a cheat when there was only the prototype
implementation. The platforms are different and their function names
don't belong in the lexicon.

I'm not even sure there should be platform interop at all - it doesn't
appear to be possible in the rust impl anyway.

So far what I've done is have some lower level words actually in the
dictionary but marked them like `++lookup`. I haven't decided what to
do about this yet. Lower level words probably should just be first
class citizens and I just need to think of better names. Right now the
low level (single-depth) lookup is `++lookup` and the user-facing
`lookup` does the arbitrary depth. In this case, the user-facing name
probably needs to change to reflect what it does (something like
`drill` or `extract`), and then the low level can just be `lookup`.

That means for all the i/o and crypto interactions, there needs to be
low-level words. I'm not sure yet how to prevent namespace pollution,
as one of the design choices is
** TODO 'unassign' doesn't take a keylist, only a single key
Should change to match =assign= and =lookup=, accept a list instead of
a single bare word.
** INPROGRESS More support for nested/related envs
Debuggers, spawning, ingesting etc
** TODO Graphical environment browser/editor 
It would be nice to have a graphical display of all the environments
in an application, and be able to 
+ Drill into the environment and read the stack/expression/dictionary
+ Pause/resume execution
+ Apply debugging (breakpoint, step etc)
+ View pipes and what/where they connect to (draw lines if they
  connect somewhere else in the app)
+ Manually put things into pipes or take them out
+ Create new envs
+ Persist changes
+ Revert changes
** TODO Code distribution method
Let's say we write an app or library, how do we distribute it?
** TODO Clean up all the vector conversion
I've been calling =vec= a lot, sometimes just so the list will print
out with square braces. I now have a =repr= function that could do
this, so using =vec= for that purpose is no longer needed.

However, I can't get rid of all of them- for example, calling =conj=
on a vector vs list adds at different ends of the list so they are not
interchangeable in that respect. It may be dangerous to leave any
lists lying around if they might get conjed onto expecting it to go on
the end.
** DONE org-babel-execute for kcats

* Notes
** Higher level persistence abstraction
I wonder whether kcats should have any notion of files and sockets at
all. Sort of like java doesn't have any notion of memory addresses or
malloc/free - it operates at a higher level and handles mem management
for you. Maybe kcats handles persistence for you. This may be a sort
of chicken/egg problem where I need a network protocol to help w
persistence and I want that protocol to include kcats as a
language. Can they be bootstrapped as a single unit? Seems possible
but not easy. Persistence might involve having another party store
data for you, which might involve identity (to limit access) and money
(to incentivize someone to keep your data for later). That might be a
bit of a reach for a programming standard lib to handle.

And then there's the question of interop with other programs, how
would they communicate if kcats doesn't know what a file or socket is?
Maybe it can know what a file/socket is but you don't need to use it
except as interop (like clojure's java interop or java's jni).

So what would this look like?

Instead of telling the program *where* to persist, you just want it
persisted and you get a sort of claim check (maybe the hash of the
data?). Then to get it back later, you present the claim
check. Persistence is a best-effort deal (you can't be 100% sure no
disaster could wipe it out). So maybe also include some optional
params to indicate:

+ how long until you might need this again
+ how long you can wait between requesting it and getting it
+ how disaster-proof it needs to be
+ how much you're willing to pay to store it

Maybe we can even put messaging under this model - after all, sending
someone a message is in fact making a copy of data you have. You don't
necessarily want to retrieve it later though.

Computing might be better thought of as a worldwide resource - you
might not be able to trust someone else to do a computation for you
(yet, unless it's a specific type where you can verify without doing
the full computation yourself) but you can trust them with storage
(given enough redundancy - they can't steal your data because it's
encrypted).
** DHT of hash:content
This can be distributed storage of names and what they point to.

Let's say you have a file, "my-book-report", and later you want to be
able to retrieve it using that name. You hash the file, and
separately, the name (possibly after encrypting them to yourself), and
call the DHT store function on H(name), H(file). Later when you need
to get the file, you hash the name again and call DHT get on
H(name). You get the hash back which you can use to get the content
(from a separate system - either a local hash-based filesystem or
bittorrent-like sharing system, or ipfs)

This could also be used to map names to anything else - people,
machines, code libraries etc.
** File distribution

** Object construction, caching
Often we create objects similar to java construction, where the input
and output are informationally equivalent (you can reconstruct the
output from the input anytime you want, and sometimes vice versa).

It might be nice if kcats didn't force you as a user to do this type
of operation and just let you use the original data.

For example, lets say you have =[[file "/tmp/foo"]]=. That's an
association of =file= (a type) to a string. Really what that means is
we're referring to a file on disk. In java we'd construct a =File=
object with =new File("/tmp/foo")=. It'd be nice if everywhere in
kcats you never needed a =File= object and could use the original
descriptor instead (or a pipe you've already created, if state
matters). On the jvm platform obviously somewhere a =File= object
would get created but that should be hidden from view. How would that
work?

I thought of a word like =derive= that caches these things? Maybe it
would keep a cache of previously derived things and just return the
answer if asked again (like memoized function in clojure and could
even be implemented that way). It would also have a mapping of *how*
to derive one thing from another. eg =[[file "foo"]]= and create a
pipe-in to write to it. You'd first need an inputstream to the file
(as inputstream is what the pipe protocol is actually using).

The thing is, inputstreams are not values. They're stateful, pointers
to places on disk. So we probably can't cache them nor need to.

=derive= would be more for things like crypto keys created from a
seed.

For pipes, we need to go from a descriptor, to some platform specific
object, to a pipe. How do we keep platform specific code isolated? I'm
hesitant to make public abstractions for anything but pipes. I don't
want a =file= word that creates file objects from descriptors, kcats
users should never see that. The only solution I can think of is to
just leave the platform-specific code where it is, and have some kind
of switching mechanism like clj/cljs has.


*** Platform specific definitions
It's not good to have platform-specific code in the lexicon. That's
supposed to be a standard library, pure kcats and loaded without issue
no matter which platform.

However, it's also nice to have platform interop so we can leverage
the platform. The question is, how do we isolate the interop stuff?

It seems clear that it would be useful to have kcats words to deal
with platform-specific objects. For example, jvm's streams, files,
sockets etc. Bytes often come from these sources but kcats doesn't
deal with them officially, it only uses pipes. But we have to create a
pipe from these things.
** Adjectives and other parts of speech 
It might be nice to make kcats read more like english. 

#+begin_src kcats
[room little green paint]
[[[type room]]] | little green paint
[[[type room] [size little]]] | green paint

#+end_src
** Contextual words
It might be nice to have certain words defined only in
context. However it could be argued that the stack *is* the
context. Can we put more words on the stack? Seems plausible - put a
dictionary on the stack and step thru execution of a program just as
if it was a nested env, merging the new dictionary into the original.

But i'm not sure this is a good idea. We already have
multimethod-based words. What added value would contextual words give?


* Example programs
** Factorial
*** Recursive definition 
#+begin_src kcats :tangle no
10 
[fact [[clone 0 =]
       [discard 1]
       [clone dec fact *]
       if]]
inscribe
fact
#+end_src

#+RESULTS:
: 
: stack: [[[reason "type mismatch"] [asked [word]] [type error]] [fact [[clone 0 =] [discard 1] [clone dec fact *] if]] 10]
: expression: [inscribe fact]

*** Recursive with recur
#+begin_src kcats :tangle no
10
[1 <=]
[]
[clone dec]
[execute *]
recur
#+end_src

#+RESULTS:
: 
: [3628800]

*** Using range
#+begin_src kcats :tangle no
 10
 inc [1 2] dip range 
 [*] step
#+end_src

#+RESULTS:
: 
: [3628800]

*** Plain loop
#+begin_src kcats :tangle no
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src

#+RESULTS:
: 
: [3628800]

** Spawn child environments and pipe values back
#+begin_src clojure :tangle no
handoff clone ;; 2 copies of a pipe (one in, one out)
wrap [1 1 + put] join ;; build a program containing the pipe and some
                      ;; arthmetic problem, which puts the result in
                      ;; the pipe
spawn ;; a new env to run the above program
[2 3 +] dip ;; do another calculation in this env
take ;; the value from the pipe, which will come from the spawned env 
[discard] dip ;; done with the pipe
+ ;; add numbers
#+end_src
** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
#+begin_src kcats :tangle no
100 [0] [[1.0 swap /] dip +] primrec
#+end_src

#+RESULTS:
: 
: [5.187377517639621]

** Primrec
#+begin_src clojure :tangle no
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
** Fibonacci
#+begin_src kcats
40 [1 0] swap [[[+] shield] inject] times reverse
#+end_src

#+RESULTS:
: 
: [[0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141]]

** Prime numbers (sieve of eratosthenes)
#+begin_src kcats

1000 clone 2 swap range ;; all the numbers up to n
[.+java.lang.Math/sqrt .+java.lang.Math/ceil .int 2] dip  ;; start counter at 2, stop at sqrt of n
[ [=] dip swap ] ;; stop loop when the counter hits sqrt n
[] ;; after loop, nothing left to do 
[ [ [ [=] 
      [swap mod 0 = not]]
    [execute] any?] 
  filter ;; keep the counter but no multiples of it 
  [inc] dip] ;; increment counter
[execute]
recur
[discard discard] dip ;; drop the original args, just leaving the primes
#+end_src

#+RESULTS:
: 
: stack: [[[asked [sqrt]] [type error] [reason "word is not defined"]] 1000]
: expression: [sqrt ceil .int 2 [[2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999]] unwrap [[=] dip swap] [] [[[[=] [swap mod 0 = not]] [execute] any?] filter [inc] dip] [execute] recur [discard discard] dip]

** Prime factors
#+begin_src kcats
21449

[] swap 2

[/ 2 >]
[ [mod 0 =]
  [clone sink [pack] dipdown / 2]
  [inc]
  if]
while

discard pack
#+end_src

#+RESULTS:
: 
: [[89 241]]

** bidirectional comms from a socket
#+begin_example clojure
["" [string join] ;; each group of bytes that come out of the tunnel,
                  ;; convert to string and join to whatever we already
                  ;; assembled
 [[type ip-port]
  [address "localhost"]
  [port 9988]] ;; description of where to connect to (an ip port)
 tunnel ;; make a bidirectional tunnel
 "foo! bar!" put ;; send this string
 assemble] ;; receive
#+end_example
** Write string to a file
#+begin_example clojure
[[[file "/tmp/foo"]] pipe-in
 "blah" put
 close]
#+end_example
** Search the dictionary
#+begin_src kcats
[dictionary ;; put the dictionary of all words onto the stack as key value pairs
 [second ;; the value of one of those pairs
  [spec] lookup ;; look up the spec field
   first ;; the input part of the spec
   [program] =] ;; is it taking a single input, a program?
 filter ;; filter the dictionary using the above criteria
 [first] map] ;; of what remains, just keep the key (which is the word itself)

;; when we run this, we get
[[shield execute assert]]
;; which are the words in the dictionary that take just a program as
;; input.
#+end_src
