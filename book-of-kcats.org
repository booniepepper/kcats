# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj
* Synopsis
This is a literate programming document that will describe the
language =kcats=, a stack-based programming language similar to Joy,
and also implement it in code.

About the name: it's just "stack" spelled backward (since stack-based
programs read backward from traditional ones), pronounced "kay cats".
* Use case
Kcats is meant to primarily act as an approachable expression language
for end users. It will replace complex UI's with gigantic menus, with
an easy to learn language where users can express exactly what they
want. Its programs will generally be small snippets that are easily
shared and built upon.
* Goals
** Easy for a beginner programmer to learn
*** Use as few concepts as possible
The language should use as few concepts as possible. It may include

+ Stacks
+ Primitive datatypes (numbers, booleans, strings, bytes)
+ lists
+ Functions
+ Pipes

It will explicitly *not* use

+ Variables
+ Classes
+ Lexical or dynamic scope rules
+ Shared precompiled libraries
*** Easy to understand documentation
**** Documentation by example
By documenting by example only, no translation into other languages is
needed, as there is no prose to translate.

Each example is a line. It's the items put onto the stack as
input, then a thought bubble (ðŸ’­) then the resulting stack after
processing.

Items inside square brackets [] are quotations.

#+BEGIN_EXAMPLE
true â˜¯ ðŸ’­ false
false â˜¯ ðŸ’­ true
#+END_EXAMPLE

In the example without knowing in advance what the â˜¯ symbol does, you
can figure out that it's a logical =not= operator.
** Easy to implement
Making a working implementation should involve as few primitives as
possible, with the bulk of the language being defined in terms of the
few primitives. This may result in slow performance, but implementors
can incrementally improve performance by replacing core words with
primitive versions (written in the platform language).

Ideally the number of minimally required primitive words should be in
the "few dozen" range, and the LOC would be well under 10,000,
hopefully closer to 1000.

** Useful for general programming
** Make tool development as easy as possible
+ Debuggers
+ IDEs
** Easy to interoperate
For example, everything should be a value, and serializable (you
should be able to send anything to a remote interpreter, even one that
is not the same implementation, and have it understand the value it
received.

There will be no compiled binary code, at least, not a portable
one. If there is compilation it will be local only (all libs built
locally from source). 

* Non-goals
** Fast performance
It would be nice if kcats were at least as fast as slower scripting
languages like python and ruby, but we won't consider this a goal.

There are a myriad of use cases even when the language is the slowest
language on earth. Having a formal expression language that is easy to
learn and work with is still valuable even if it is computationally
inefficient.

I don't think there's any theoretical reason the language must be
slow, there are lots of optimizations that can be made over time.
** Easy static analysis
* Definining some terms
- stack :: A first-in, first-out structure. This is mainly where data
  the program needs to manipulate will be stored.
- aggregate :: A list of items, which can be interpreted either as
  data or executable code.
- program :: an aggregate intended to be executable.
- word :: causes the program to do something, usually taking some
  items from the top of the stack and using them to create new
  stack items. Some words may do nothing but put themselves on
  the stack.
- axiom word :: A word that is defined in the base language, not in
  terms of other words.
- definition :: what exactly a word is supposed to do, represented
  either in the base language for axiom words, or as a
  program.
- dictionary :: a list of words and their definitions.
- expression :: The part of the program being evaluated, which needs
  to be broken down into axiom words and executed.
- environment :: the entire state of an executing program. Note that
  applications will normally be composed of multiple environments that
  coordinate with each other.
- predicate :: a word that consumes stack items and leaves either true
  or false on the stack.
- pipe :: A method to communicate between stacks and to the outside
  world. Values are put into pipes and emerge elsewhere (in
  the stack, another environment, a file, a socket, etc).
* Prototype implementation
** Status
The first implementation is entirely experimental. Everything in it is
subject to change. Vast areas of functionality are missing or broken.
** Base Language
We select Clojure to build the prototype, as it's a solid prototyping
language, is fairly well matched to the goals. Clojure will likely not
be a "production" implementation.
** Basic type specs
First we'll create a clojure namespace and define some specs, which
will help us debug and document what is happening. We'll use the
clojure's built in spec and the library =expound= which gives easier
to understand error messages.

#+BEGIN_SRC clojure
  (ns kcats.core
    (:require [clojure.spec.alpha :as spec]
              [expound.alpha :as expound])
    (:refer-clojure :exclude [eval]))

  (set! spec/*explain-out* (expound/custom-printer
                            {:show-valid-values? true}))
  (spec/check-asserts true)
#+END_SRC

Kcats will use some types more or less unchanged from the way clojure
uses them. If it's a clojure boolean, it's a kcats boolean, etc.

#+BEGIN_SRC clojure
  (expound/def ::boolean boolean?)
  (expound/def ::number number?)
  (expound/def ::string string?)
  (expound/def ::bytes bytes?)
  (expound/def ::integer integer?)
#+END_SRC

#+RESULTS:
: :kcats.core/boolean:kcats.core/number:kcats.core/string:kcats.core/bytes:kcats.core/integer

Now we'll spec some concepts in kcats in terms of clojure
concepts. We'll need to specify what kinds of things can go in a
program or be put on a stack. We'll call those =items=. Note that
items can be aggregates, which we haven't specced yet. That's ok,
recursive specs are allowed. Aggregates contain items, and items
can also be aggregates.

#+BEGIN_SRC clojure :tangle
(in-ns 'kcats.core)

(expound/def ::item
  (spec/or :aggregate ::aggregate
           :boolean ::boolean
           :number ::number
           :string ::string
           :bytes ::bytes
           :word ::word
           :pipe :kcats.pipe/pipe))
#+END_SRC

#+RESULTS:
: #namespace[kcats.core]:kcats.core/item

Now we'll spec an aggregate, which is just a list. We'll use
clojure's vectors (which are indexed lists). We'll also spec out
programs, which are aggregates but intended to be executed (otherwise
there is no difference).

#+BEGIN_SRC clojure
  (expound/def ::aggregate (spec/coll-of ::item :kind vector?) "aggregate?")
  (expound/def ::program ::aggregate)
#+END_SRC

We'll also need words that perform actions- this maps well to
clojure's symbols which are used similarly. Then we will want to be
able to define new words in our new language so let's spec out what a
word's definition looks like - it's a program.

Finally we want to be able to keep track of all words we've defined,
so we'll spec a dictionary that allows us to look up a word's
definition. In a dictionary we're also going to have inscrutable
definitions are only implemented in clojure, not as other kcats words,
so we have to allow for those also. We'll call those axiom words.

#+BEGIN_SRC clojure
  (def word? symbol?)
  (expound/def ::word word?)

  (expound/def ::axiom-definition (spec/keys :req [::fn ::spec]))
  (expound/def ::program-definition (spec/keys :req [::definition]))

  (expound/def ::dictionary (spec/map-of ::word
                                         (spec/or :axiom ::axiom-definition
                                                  :user-defined ::program-definition)))
#+END_SRC

#+RESULTS:
: #'kcats.core/word?:kcats.core/word:kcats.core/axiom-definition:kcats.core/program-definition:kcats.core/dictionary

Next we'll spec a stack. We want it to easily implement a FIFO
stack, (meaning the last item you put in is accessible in constant
time), and clojure's built-in list type does this.

An expression is also a list of items that are being broken down into
their axiomatic parts.
#+BEGIN_SRC clojure
  (def stack? (every-pred (complement indexed?) sequential?))

  (expound/def ::stack (spec/coll-of ::item
                                  :kind stack?))

  (expound/def ::expression (spec/coll-of ::item
                                       :kind stack?))

#+END_SRC

Next we'll spec what an Environment is - it's currently just a
dictionary, stack, and expression put together. 

#+BEGIN_SRC clojure
  (expound/def ::environment (spec/keys :req [::stack ::dictionary ::expression]))
#+END_SRC
** Evaluation
Next we're going to define how the kcats language executes (or
evaluates) a [[#definitions][program]]. First we can say that to evaluate a program, we
will keep stepping through evaluation as long as the expression isn't
empty. Once it's empty, there's nothing left to do and we return the
last environment.

#+BEGIN_SRC clojure
(declare eval-step) ;; we'll define this later

(defn eval
  ([{:keys [max-steps before-step]} env]
   (let [eval-step (if before-step
                     (comp eval-step before-step)
                     eval-step)]
     (loop [{::keys [expression] :as env} env
            step-count 0]
       (if (or (not (seq expression)) ;; nothing left to run
               (and max-steps (>= step-count max-steps)))
         env
         (recur (eval-step env) (inc step-count))))))
  ([env]
   (eval {} env)))

#+END_SRC

#+RESULTS:
: #'kcats.core/eval-step#'kcats.core/eval

Now, we define =onto-stack=,
which says what we do to put an item onto the stack. Simple items like
numbers, strings and undefined words, just go straight onto the stack
with no changes.

#+BEGIN_SRC clojure
  (defmulti onto-stack
    "Evaluate one item in the given environment. A single step in a
    program's execution."
    (fn [{[item] ::expression}]
      (type item)))

  (defn- push
    "Push an item from the expression into the stack"
    [{[item & others] ::expression :as env}]
    (-> env
        (assoc ::expression others)
        (update ::stack conj item)))

  (defmethod onto-stack Number [env]
    (push env))

  (defmethod onto-stack String [env]
    (push env))

  (defmethod onto-stack Boolean [env]
    (push env))

  ;; PersistentVector is the clojure type for an aggregate
  (defmethod onto-stack clojure.lang.PersistentVector [env]
    (push env))

  (defmethod onto-stack (Class/forName "[B") [env]
    (push env))
#+END_SRC

Where the real action happens is when we evaluate a word. Each defined
word has a clojure function that will run when that word is
evaluated. If it's not defined, then the word will act like everything
else and just be put on the stack.

We'll also specify here what a step of evaluation is - it looks at the
next item in the expression. If it has a definition, it's replaced
with its definition. Otherwise it's put onto the stack.

Recall what =eval= does, it just keeps iterating =eval-step= until
there's nothing left in the expression.
#+BEGIN_SRC clojure
(defmethod onto-stack clojure.lang.Symbol [{[word & others] ::expression
                                            ::keys [dictionary stack]
                                            :as env}]
  (let [{f ::fn spec ::spec} (dictionary word)]
    (when spec
      (spec/assert spec stack))
    (if f
      (f (update env ::expression rest))
      (push env))))

(defn definition
  "Returns the definition of an item, if it's a word defined in terms
  of other words"
  [{::keys [dictionary] :as env} item]
  (some-> dictionary (get item) ::definition))

(defn eval-step
  "Evaluate one step in the environment."
  [{[next-item & items :as expression] ::expression ::keys [stack dictionary] :as env}]
  (if-let [d (definition env next-item)]
    (assoc env ::expression (concat (list* d) items)) ;; replace item with definition
    ;; eval the thing onto the stack
    (onto-stack env)))
 
(defn print-env
  "Prints the expression/stack and then return env"
  [{::keys [expression stack] :as env}]
  (apply pr (reverse expression))
  (print " . ")
  (apply prn stack)
  env)
#+END_SRC

#+RESULTS:
: #multifn[onto-stack 0x52d1130b]#'kcats.core/definition#'kcats.core/eval-step

** Built-in words
Eventually we'll want to define words in terms of other words. But
right now we don't have any words! So we'll have to define some, not
in terms of other words but as clojure functions. Then we can build
new words on top of those.

We'll need some utility functions that help us define these axiom
words.

#+BEGIN_SRC clojure
(defn update-stack [f env]
  (update env ::stack f))

(defn s-apply
  "Take nitems off the stack, apply them to f. f should return a list
   to put back onto the stack."
  [nitems f stack]
  (let [[a b] (split-at nitems stack)]
    ;; items are reversed so that we can write code with arguments in
    ;; the same order as we'd use in other langs, eg so that [2 1 >]
    ;; -> true
    ;;
    ;; The top item in the stack would normally be the first
    ;; arg, but that was the LAST arg written in the code.
    (into b (apply f (reverse a)))))

(defn s-apply-one
  "Like s-apply, but useful for functions where you only want to put
   one item back on the stack and f doesn't return a
   list. Automatically creates a list of one item."
  [nitems f stack]
  (s-apply nitems (comp list f) stack))

(defn f-stack
  "Apply nitems from stack to f, put result back on stack"
  [nitems f]
  (partial update-stack (partial s-apply-one nitems f)))

(defn env-effect
  "Calls f with nitems from stack, it should return a pair (items to
  prepend to the expression, items to replace the nitems with)"
  [nitems f]
  (fn [{::keys [stack expression dictionary]}]
    (let [[a b] (split-at nitems stack)
          [new-expression-items new-stack-items] (apply f a)]
          {::stack (concat new-stack-items b)
           ::expression (concat new-expression-items expression)
           ::dictionary dictionary})))

(defmacro effect
  [in out-expr out-stack]
  `(env-effect ~(count in) (fn ~in [~out-expr ~out-stack])))

(defmacro stack-effect
  "Takes a stack effect notation and turns it into a call to
  env-effect"
  [in out]
  `(env-effect ~(count in) (fn ~in [[] ~out])))

(defn inscribe
  "Define a new word. Takes an aggregate off the stack which should be of the
  form:
  [new-word program]"
  [{[word word-def & others] ::stack
    ::keys [expression dictionary]}]
  {::stack others
   ::expression expression
   ::dictionary (assoc dictionary word {::definition word-def})})

;; we won't allow the value nil/null in kcats. To signify "nothing"
;; we'll use an empty list. Here are some functions to convert between
;; clojure's idea of "nothing" and kcats'
(def nothing [])

(defn nothing?
  [x]
  (= nothing x))

(defn nothing->nil
  "Returns argument unless it's a kcats 'nothing' (empty list), in
  which case it returns nil"
  [x]
  (if (nothing? x)
    nil
    x))

(defn nil->nothing
  "Returns argument unless it's nil, in which case it returns empty list"
  [x]
  (if (nil? x)
    nothing
    x))
#+END_SRC

#+RESULTS:
: #'kcats.core/update-stack#'kcats.core/s-apply#'kcats.core/s-apply-one#'kcats.core/f-stack#'kcats.core/env-effect#'kcats.core/effect#'kcats.core/stack-effect#'kcats.core/inscribe#'kcats.core/nothing#'kcats.core/nothing?#'kcats.core/nothing->nil#'kcats.core/nil->nothing

#+BEGIN_SRC clojure
(in-ns 'kcats.core)
(expound/def ::stack-min-depth-1 (spec/coll-of ::item
                                               :kind stack?
                                               :min-count 1))
(expound/def ::stack-min-depth-2 (spec/coll-of ::item
                                               :kind stack?
                                               :min-count 2))
(expound/def ::stack-min-depth-3 (spec/coll-of ::item
                                               :kind stack?
                                               :min-count 3))

(expound/def ::binary-arithmetic (spec/cat :x ::number
                                           :y ::number
                                           :others (spec/* ::item)))

(expound/def ::predicate (spec/cat :x ::item
                                   :others (spec/* ::item)))

(expound/def ::quoted-word (spec/coll-of ::word
                                         :count 1
                                         :kind vector?))

;; since we'll commonly be defining specs for a stack, we'll nearly
;; always not care about anything below a certain depth, so let's make
;; a macro that encapsulates that.
(defmacro stack-spec
  [& args]
  `(spec/cat ~@args
             :others (spec/* ::item)))

(defonce core-words (atom {}))

(def arithmetic-words
  (into {} cat
        [(for [sym ['+ '- '/ '* '< '<= '> '>= 'min 'max 'quot 'rem 'mod]]
           [sym
            {::spec ::binary-arithmetic
             ::fn (f-stack 2 (resolve sym))}])
         (for [sym ['inc 'dec]]
           [sym
            {::spec (spec/cat :x ::number
                              :others (spec/* ::item))
             ::fn (f-stack 1 (resolve sym))}])]))

;; need to implement `some` to respect empty list being falsey
(def predicates
  (into {} cat
        [(for [sym ['odd? 'even? 'sequential? 'zero? 'pos? 'neg?
                    'number? 'int? 'true? 'false?
                    'string? 'empty?]]
           [sym {::spec ::predicate
                 ::fn (f-stack 1 (resolve sym))}])
         (for [sym ['starts-with? 'ends-with?]]
           [sym {::spec ::stack-min-depth-2
                 ::fn (f-stack 2 (resolve sym))}])]))

(def base-words
  {'discard {::spec (stack-spec :item ::item)
             ::fn (stack-effect [a] [])
             ::examples '[[[1 2 3 discard] [2 1]]
                          [[1 2 3 [a b c] discard] [3 2 1]]]}
   'clone {::spec (stack-spec :item ::item)
           ::fn (stack-effect [a] [a a])
           ::examples '[[[1 2 3 clone] [3 3 2 1]]]}
   'swap {::spec (stack-spec :item1 ::item, :item2 ::item)
          ::fn (stack-effect [a b] [b a])
          ::examples '[[[1 2 3 swap] [2 3 1]]]}
   'swapd {::spec ::stack-min-depth-3
          ::fn (stack-effect [a b c] [a c b])
          ::examples '[[[1 2 3 swapd] [3 1 2]]]}
   'rotate {::spec ::stack-min-depth-3
            ::fn (stack-effect [a b c] [c a b])}
   'execute {::spec (stack-spec :program ::program)
             ::fn (effect [p] p [])
             ::examples '[[[[1 2 +] execute] [3]]
                          [[2 [+] 4 swap execute] [6]]]}
   'dip {::spec (stack-spec :program ::aggregate
                            :item ::item)
         ::fn (effect [p a] (conj (vec p) a) [])
         ::examples '[[[1 8 [inc] dip] [8 2]]]}
   'dipd {::spec (stack-spec :program ::aggregate
                             :item1 ::item
                             :item2 ::item)
          ::fn (effect [p a b] (conj (vec p) b a) [])
          ::examples '[[[1 2 3 [inc] dipd] [3 2 2]]]}
   'wrap {::spec (stack-spec :item ::item)
          ::fn (stack-effect [a] [[a]])
          ::examples '[[[1 wrap] [[1]]]]}
   'unwrap {::spec (stack-spec :aggregate ::aggregate)
            ::fn (stack-effect [a] a)
            ::examples '[[[[1] unwrap] [1]]]}
   'inscribe {::spec (stack-spec :word ::word
                                 :definition ::aggregate)
              ::fn #'inscribe
              ::examples '[[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}
   'describe {::spec (stack-spec :word ::word)
              ::fn (fn [{[word & others] ::stack dict ::dictionary :as env}]
                     (let [dfn (-> dict (get word) ::definition)]
                       (if dfn
                         (assoc env ::stack (conj others dfn))
                         nothing)))}
   'branch {::spec (stack-spec :false-branch ::aggregate
                               :true-branch ::aggregate
                               :condition ::item)
            ::fn (effect [f t b]
                         (if (nothing->nil b) t f) [])
            ::examples '[[[5 true [3 *] [4 +] branch] [15]]
                         [[6 false [3 *] [4 +] branch] [10]]]}
   'ifte {::spec (stack-spec :false-branch ::aggregate
                             :true-branch ::aggregate
                             :condition ::program)
          ::definition '[[execute] dipd branch]
          ::examples '[[[5 [clone 5 =] [3 *] [4 +] ifte] [15]]
                       [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}
   'step {::spec (stack-spec :program ::aggregate
                             :aggregate ::aggregate)
          ::fn (effect [p [agg-item & agg-rest]]
                       (cond-> ['execute]
                         (seq agg-rest) (concat [(vec agg-rest) p 'step]))
                       [p agg-item])
          ::examples '[[[1 [2 3 4] [*] step] [24]]]}
   'recur {::spec (stack-spec :rec2 ::program
                              :rec1 ::program
                              :true-branch ::program
                              :false-branch ::program)
           ::fn (effect [rec2 rec1 then pred]
                        '[ifte]
                        [(vec (concat rec1 [[pred then rec1 rec2 'recur]] rec2))
                         then pred])
           ::examples '[[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}
   'primrec {::spec (stack-spec :rec1 ::program
                                :exit ::program
                                :data ::number)
             ::definition '[[execute] swap join ;; add execute to rec1 to be recur's rec2
                            [[discard] swap join] dip ;; add discard to exit condition
                            [[clone zero?]] dipd  ;; put the condition on bottom
                            [[clone dec]] dip ;; add the r1
                            recur] ;; now it's generic recur
             ::examples '[[[5 [1] [*] primrec] [120]]]}
   'loop {::spec (stack-spec :program ::program
                             :flag ::item)
          ::fn (effect [p f]
                       (when (nothing->nil f)
                         (concat p [p 'loop]))
                       [])
          ::examples '[[[10 true [-2 * clone 50 <] loop] [160]]]}
   '= {::spec (stack-spec :x ::item, :y ::item)
       ::fn (f-stack 2 =)
       ::examples '[[[1 1 =] [true]]
                    [["hi" "hi" =] [true]]
                    [["hi" "there" =] [false]]
                    [[[] false =] [false]]]}
   'pack {::spec (stack-spec :x ::item
                             :aggregate ::aggregate)
          ::fn (stack-effect [x a] [(conj (vec a) x)])
          ::examples '[[[[] 1 pack] [[1]]]
                       [[[1 2 3] 4 pack] [[1 2 3 4]]]]}
   'unpack {::spec (stack-spec :aggregate ::aggregate)
            ::fn (stack-effect [[a & others]] [a (vec others)])
            ::examples '[[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}
   'count {::spec (stack-spec :aggregate ::aggregate)
           ::fn (stack-effect [a] [(count a)])
           ::examples '[[[["a" "b" "c"] count] [3]]]}
   'join {::spec (stack-spec :agg1 ::aggregate
                             :agg2 ::aggregate)
          ::fn (f-stack 2 (comp vec concat))
          ::examples '[[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}
   'range {::spec (stack-spec :from ::integer
                              :to ::integer)
           ::fn (f-stack 2 (comp vec range))
           ::examples '[[[1 5 range] [[1 2 3 4]]]]}
   'swaack {::spec (stack-spec :list ::aggregate)
            ::doc "Swaps the list on top of the stack and the rest of the stack"
            ::fn (fn [{[a & others] ::stack ::keys [dictionary expression]}]
                   {::stack (apply list (vec others) a)
                    ::expression expression
                    ::dictionary dictionary})
            ::examples '[[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}
   'infra {::spec (stack-spec :program ::program
                              :list ::aggregate)
           ::doc "Accept a quoted program and a list on the stack and run the program
                    with the list as its stack.  Does not affect the rest of the stack."
           ::definition '[swap swaack unpack dip swaack]
           ::examples '[[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}
   'some? {::spec (stack-spec :item ::item)
           ::fn (f-stack 1 (comp some? nothing->nil))}
   'first {::spec (stack-spec :aggregate ::aggregate)
           ::fn (f-stack 1 first)}
   'second {::spec (stack-spec :aggregate ::aggregate)
           ::fn (f-stack 1 second)}
   'every? {::spec (stack-spec :program ::aggregate
                               :aggregate ::aggregate)
            ::fn (fn [env]
                   #_(update-stack (fn [[p a & others :as stack]]
                                     (->> a
                                          (every? #(leaves-true? (with-stack env (conj others %)) p))
                                          (conj others)))
                                   env))}
   'in  {::spec (stack-spec :aggregate ::aggregate, :item ::item)
         ::fn (f-stack 2 contains?)}
   'intersection {::spec (stack-spec :aggregate-x ::aggregate
                                     :aggregate-y ::aggregate)
                  ::fn (f-stack 2 (fn [x y]
                                    (into []
                                          (clojure.set/intersection
                                           (into #{} x)
                                           (into #{} y)))))}})
(swap! core-words merge
       base-words
       arithmetic-words
       predicates)

(defn default-env []
  {::stack '()
   ::dictionary @core-words
   ::expression '()})

(defn k
  "Run a program with the default env and return the result. Option to
  stop execution after `max-steps` if still unfinished, to prevent
  accidental infinite loops (for debugging purposes)"
  ([opts p]
   (::stack (eval opts (assoc (default-env) ::expression p))))
  ([p] (k {:before-step print-env} p)))

(require '[clojure.test :as test])
(defn test
  "Run through all the examples in the default env and make sure they
  work. Takes optional list of words to test"
  ([words]
   (doseq [[word {::keys [examples]}] (if words
                                        (select-keys @core-words words)
                                        @core-words)]
     (test/testing (str word)
       (doseq [[program exp-stack] examples]
         (->> program
              (k {:max-steps 500})
              vec
              (= exp-stack)
              test/is)))))
  ([] (test nil)))
#+END_SRC

#+RESULTS:
: #namespace[kcats.core]:kcats.core/stack-min-depth-1:kcats.core/stack-min-depth-2:kcats.core/stack-min-depth-3:kcats.core/binary-arithmetic:kcats.core/predicate:kcats.core/quoted-word#'kcats.core/stack-specnil#'kcats.core/arithmetic-words#'kcats.core/predicates#'kcats.core/base-words{ends-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, every? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e03d351b-8c01-4507-a64e-c247e2214eb9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--18847]}, unwrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c1f3dc6f-cd8e-4388-8726-3a490f2be47c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1] unwrap] [1]]]}, first #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e3ad18ae-cbb8-43c7-b0a2-bae01c820986", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, atom #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1dddc433-a6c0-4f2e-8cbc-3b0ee9c13b19", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:value :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, branch #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c7140a22-37a4-45fc-86e4-4410b4d70001", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]}, = #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "98812512-e2d1-4a80-ab5b-421393b8a175", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :y :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]]]}, step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c0bc51ec-7b87-43a5-a586-782a6f184baa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 [2 3 4] [*] step] [24]]]}, take #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.pipe/pipe {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "67a18f1c-72c6-44bc-aab2-fcdeabc9934c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:pipe :others], :forms [:kcats.pipe/pipe (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, dec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "453ed3ef-2db4-45fd-a597-298975e2e907", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, < #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "72246d2e-0dda-4002-a873-58064b36ae22", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :aggregate :others], :forms [:kcats.core/item :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]]]}, ifte #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "0692e1ec-888e-4bfb-b244-51a0764e4f4f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] dipd branch], :examples [[[5 [clone 5 =] [3 *] [4 +] ifte] [15]] [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}, infra #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "7e8ebaae-d3a6-4b9f-a32c-5abda70db689", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :list :others], :forms [:kcats.core/program :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Accept a quoted program and a list on the stack and run the program\n                    with the list as its stack.  Does not affect the rest of the stack.", :definition [swap swaack unpack dip swaack], :examples [[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}, some? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e448f0c7-c0bf-4791-b3b8-6aa703b63050", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, join #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "142035c7-6024-41a1-9a23-b0117a102bcc", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:agg1 :agg2 :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}, range #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/integer :kcats.core/integer {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bc18472a-f524-4ded-87ca-b9788cb60bb7", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:from :to :others], :forms [:kcats.core/integer :kcats.core/integer (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 5 range] [[1 2 3 4]]]]}, in #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2462fcc5-e670-4f7c-8e46-21e6f367c5be", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, pos? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, sequential? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, starts-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, neg? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, pipe? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fe4633b7-3045-4a82-b9ec-137e28fef99c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, <= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pushcond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "54cf99a1-8b65-47c1-8d3f-ba37b6a5844b", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :conditions :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [wrap swap join]}, intersection #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "298b8203-3408-4078-a731-aa21e79eb2c5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate-x :aggregate-y :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, * #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, min #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, wrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "8e654cea-5342-4876-9d41-a27c85612076", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 wrap] [[1]]]]}, get #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "d0aa2589-77da-495a-be1f-1615992ec2d5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:key :from :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[[[clone type]]]]}, swaack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2d262529-290f-4e48-89e3-dad9e37ff8f2", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:list :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Swaps the list on top of the stack and the rest of the stack", :fn #function[kcats.core/fn--18841], :examples [[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}, empty? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, quot #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, string? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, lookup #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/association-list], :ret {}, :ks [:kcats.core/key :kcats.core/map], :forms [:kcats.core/item :kcats.core/association-list], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] a lookup] [b]] [[[[a b] [c d]] e lookup] [[]]]]}, second #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a9981ec9-1de1-41af-a210-5b82bed088d3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, > #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, int? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, eval-step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/environment {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bd4722b6-6957-4b5a-a7ec-73e5e86671bd", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:environment :others], :forms [:kcats.core/environment (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, even? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, dip #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "d2d2d1a0-2803-4d96-baa0-4d586a2ea201", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 8 [inc] dip] [8 2]]]}, swapd #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swapd] [3 1 2]]]}, mod #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, primrec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7bce3e3-5ad9-421b-8e34-1b6141b946f9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec1 :exit :data :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] swap join [[discard] swap join] dip [[clone zero?]] dipd [[clone dec]] dip recur], :examples [[[5 [1] [*] primrec] [120]]]}, - #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, value #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2f771ed4-a3aa-470d-b752-95577a069bbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first second] [[value] unwrap lookup] ifte], :examples [[[[[foo 1]] value] [1]] [[[[type url] [value "http://foo.com"]] value] ["http://foo.com"]]]}, unpack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "dac7229a-7178-4e34-91af-37f4d89704fa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}, zero? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inscribe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "af1c6831-4054-4c6d-9691-42ff9b9364b3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :definition :others], :forms [:kcats.core/word :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #'kcats.core/inscribe, :examples [[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}, rem #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, execute #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "453c02fc-6371-4513-906c-07ed877cd127", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :others], :forms [:kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]}, recur #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f56cb266-9142-4590-9e70-86d2601abf6e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec2 :rec1 :true-branch :false-branch :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}, type #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "0ea94369-e530-4d81-81fd-3c33e4ee4c6a", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first first] [[type] unwrap lookup] ifte], :examples [[[[[foo 1]] type] [foo]] [[[[type url] [value "http://foo.com"]] type] [url]]]}, dipd #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "81d937a6-9423-4a09-b5ca-6220a1df968c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item1 :item2 :others], :forms [:kcats.core/aggregate :kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 [inc] dipd] [3 2 2]]]}, true? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, / #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, >= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, loop #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c9f4e610-e2c5-46af-bb65-eb921e065945", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :flag :others], :forms [:kcats.core/program :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[10 true [-2 * clone 50 <] loop] [160]]]}, cond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c30f4967-b255-4902-af58-51fda516344c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:test-expr-pairs :other], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17889]}, odd? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e2ea0cd3-de79-4eb4-a538-a810aa67779f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, + #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, false? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, clone #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "21d1a517-0aba-4fcb-94e9-3e01949344db", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 clone] [3 3 2 1]]]}, max #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, count #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "d26293a6-e1a4-4a12-8d7b-831553246e74", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] count] [3]]]}, swap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "df4d6820-3838-46c7-a0cd-409ab0a4d53e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item1 :item2 :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swap] [2 3 1]]]}, assoc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5cff9bad-ebe3-43a2-b664-a08a42471e54", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :alist :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] [a x] assoc] [[[a x] [c d]]]] [[[[a b] [c d]] [e x] assoc] [[[a b] [c d] [e x]]]]]}, describe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a0b2b35a-9ad8-431f-9498-cdc87c1184ca", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :others], :forms [:kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--18870]}, discard #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a3afbf0b-b0a3-4702-89cf-a3261cf0052a", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 discard] [2 1]] [[1 2 3 [a b c] discard] [3 2 1]]]}, rotate #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662]}, addmethod #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "00f6457b-0493-4dba-a0ca-c2edc6297dbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :word :others], :forms [:kcats.core/pair :kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone describe] dip pack [rotate pack] infra swap inscribe]}, number? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}}#'kcats.core/default-env#'kcats.core/knil#'kcats.core/test

Now we can go ahead and start filling out axiom words in our default dictionary.

#+RESULTS:
: :kcats.core/stack-min-depth-1:kcats.core/stack-min-depth-2:kcats.core/stack-min-depth-3:kcats.core/binary-arithmetic:kcats.core/predicate:kcats.core/quoted-word#'kcats.core/stack-spec#'kcats.core/arithmetic-words#'kcats.core/predicates#'kcats.core/recur*#'kcats.core/builtin-words#'kcats.core/default-env#'kcats.core/knil#'kcats.core/test

First we'll make some specs so we get a better error message when a
word doesn't get the stack arguments that it needs.

#+RESULTS:
: :kcats.core/stack-min-depth-1:kcats.core/stack-min-depth-2:kcats.core/stack-min-depth-3:kcats.core/binary-arithmetic:kcats.core/predicate:kcats.core/quoted-word#'kcats.core/stack-spec#'kcats.core/arithmetic-words#'kcats.core/predicates#'kcats.core/recur*#'kcats.core/builtin-words#'kcats.core/default-env#'kcats.core/knil#'kcats.core/test
** Logical operators
#+begin_src clojure

#+end_src
** Maps/associations
A simple implementation that works well for small lists: specify
associations as lists of pairs.

Then include some words that depend on this functionality.

#+BEGIN_SRC clojure
(expound/def ::pair (spec/coll-of ::item :kind vector? :count 2))

(expound/def ::association-list (spec/coll-of ::pair
                                              :kind vector?))

(def associative-words
  {'assoc {::spec (spec/cat :item ::pair, :alist ::association-list
                            :others (spec/* ::item))
           ::fn (f-stack 2 (fn [alist [k v :as item]]
                             (let [i (.indexOf (mapv first alist) k)]
                               (if (= -1 i)
                                 (conj alist item)
                                 (assoc alist i item)))))
           ::examples '[[[[[a b] [c d]] [a x] assoc] #_-> [[[a x] [c d]]]]
                        [[[[a b] [c d]] [e x] assoc] #_-> [[[a b] [c d] [e x]]]]]}
   'lookup {::spec (spec/cat ::key ::item
                             ::map ::association-list)
            ::fn (f-stack 2 (fn [alist key]
                              (get (into {} alist) key [])))
            ::examples '[[[[[a b] [c d]] a lookup] [b]]
                         [[[[a b] [c d]] e lookup] [[]]]]}
   'cond {::spec (spec/cat :test-expr-pairs ::association-list
                           :other (spec/* ::item))
          ::fn (fn [{[[[test expr :as first-clause]
                       & other-clauses]
                      & others] ::stack
                     ::keys [dictionary expression]}]
                 {::expression (if first-clause
                                 (concat [test
                                          expr ;; the then
                                          [(vec other-clauses) 'cond] ;; the else
                                          'ifte]
                                         expression)
                                 expression)
                  ::stack (cond-> others
                            ;; if cond is empty result is empty list
                            (not first-clause) (conj []))
                  ::dictionary dictionary})}
   'type {::spec (stack-spec :alist ::association-list)
          ::definition '[[clone count 1 =] ;; if it's a single item
                         [first first] ;; the type is the key of that first item
                         [[type] unwrap lookup] ;; otherwise look up the key 'type'
                         ifte]
          ::examples '[[[[[foo 1]] type] [foo]]
                       [[[[type url] [value "http://foo.com"]] type] [url]]]}
   'value {::spec (stack-spec :alist ::association-list)
           ::definition '[[clone count 1 =]
                          [first second]
                          [[value] unwrap lookup]
                          ifte]
           ::examples '[[[[[foo 1]] value] [1]]
                        
                        [[[[type url] [value "http://foo.com"]] value]
                         ["http://foo.com"]]]}})

(swap! core-words merge associative-words)
#+END_SRC

#+RESULTS:
: :kcats.core/pair:kcats.core/association-list#'kcats.core/associative-words{ends-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, every? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5bf98331-874a-4c59-bfd9-f05a54133222", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17791]}, unwrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fa4c429c-1049-4deb-b87f-4b6a18167ca6", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1] unwrap] [1]]]}, first #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5d0b6752-c25f-4bb2-ab20-6aad6f28b819", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, branch #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "48493db4-6246-494a-be94-9f014aea594c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]}, = #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6061340b-9b61-4fb3-a66f-2dd43e1c30ca", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :y :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]]]}, step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1b9e21a0-b07e-4454-a70e-0a85c0739f25", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 [2 3 4] [*] step] [24]]]}, dec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "32fb302c-c1c0-4a98-9ad3-73fce72ae512", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, < #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9185bd4b-c598-44b0-9db2-a887f60402a5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :aggregate :others], :forms [:kcats.core/item :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]]]}, ifte #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "00a4a65c-969b-4074-9c65-9e2efffa07ce", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] dipd branch], :examples [[[5 [clone 5 =] [3 *] [4 +] ifte] [15]] [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}, infra #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c3ca1047-0cf2-4120-96b8-d73f09a98f0c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :list :others], :forms [:kcats.core/program :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Accept a quoted program and a list on the stack and run the program\n                    with the list as its stack.  Does not affect the rest of the stack.", :definition [swap swaack unpack dip swaack], :examples [[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}, some? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9ae22cfc-b51e-4877-ae14-3986b31a4044", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, join #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "b6991964-ca9b-45d1-8ed2-a6bf801a7397", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:agg1 :agg2 :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}, range #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/integer :kcats.core/integer {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bc1dc2b3-347f-4b95-bddf-228b246242f2", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:from :to :others], :forms [:kcats.core/integer :kcats.core/integer (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 5 range] [[1 2 3 4]]]]}, in #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "3d0ecea5-ca4a-4502-b8b7-3a4b61c0bd87", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, pos? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, sequential? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, starts-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, neg? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, <= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pushcond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "54cf99a1-8b65-47c1-8d3f-ba37b6a5844b", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :conditions :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [wrap swap join]}, intersection #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f669e423-bbcb-4615-8cda-32e4b9ca6e22", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate-x :aggregate-y :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, * #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, min #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, wrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "ffd498fe-e695-446e-9d27-89f3698efc91", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 wrap] [[1]]]]}, swaack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "ad674bf3-5e0c-4a8f-828d-6b76e704c4c3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:list :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Swaps the list on top of the stack and the rest of the stack", :fn #function[kcats.core/fn--17785], :examples [[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}, empty? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, quot #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, string? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, lookup #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/association-list], :ret {}, :ks [:kcats.core/key :kcats.core/map], :forms [:kcats.core/item :kcats.core/association-list], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] a lookup] [b]] [[[[a b] [c d]] e lookup] [[]]]]}, second #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "b75a160d-563c-4391-b4c7-c271ddcf5fc4", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, > #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, int? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, eval-step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/environment {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bd4722b6-6957-4b5a-a7ec-73e5e86671bd", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:environment :others], :forms [:kcats.core/environment (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, even? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, dip #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "b219e06f-7fd2-45b9-a0a7-8b06b86c766f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 8 [inc] dip] [8 2]]]}, swapd #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swapd] [3 1 2]]]}, mod #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, primrec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "853fd7b7-8a8e-4ac0-8c63-b0e46195f792", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec1 :exit :data :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] swap join [[discard] swap join] dip [[clone zero?]] dipd [[clone dec]] dip recur], :examples [[[5 [1] [*] primrec] [120]]]}, - #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, value #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2f771ed4-a3aa-470d-b752-95577a069bbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first second] [[value] unwrap lookup] ifte], :examples [[[[[foo 1]] value] [1]] [[[[type url] [value "http://foo.com"]] value] ["http://foo.com"]]]}, unpack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "19380bbf-7dea-4905-9a01-74f3efd8aecb", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}, zero? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inscribe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f8548d1b-56c8-49fa-a977-32596dabaa29", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :definition :others], :forms [:kcats.core/word :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #'kcats.core/inscribe, :examples [[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}, rem #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, execute #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2afb8c7c-ee21-4619-8828-c425fe80dee8", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :others], :forms [:kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]}, recur #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "20885d7e-0b69-45d4-adf6-d16f35e58ff0", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec2 :rec1 :true-branch :false-branch :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}, type #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "0ea94369-e530-4d81-81fd-3c33e4ee4c6a", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first first] [[type] unwrap lookup] ifte], :examples [[[[[foo 1]] type] [foo]] [[[[type url] [value "http://foo.com"]] type] [url]]]}, dipd #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6f0bc348-d0bd-4ab9-be85-2366c4533954", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item1 :item2 :others], :forms [:kcats.core/aggregate :kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 [inc] dipd] [3 2 2]]]}, true? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, / #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, >= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, loop #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a74cf69e-6572-464c-b656-539240e883ea", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :flag :others], :forms [:kcats.core/program :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[10 true [-2 * clone 50 <] loop] [160]]]}, cond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c30f4967-b255-4902-af58-51fda516344c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:test-expr-pairs :other], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17889]}, odd? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "47a884af-c683-4cf0-bd8c-6ac24b2dc0e3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, + #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, false? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, clone #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 clone] [3 3 2 1]]]}, max #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, count #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "8ce6f4b0-cbad-454a-b23c-d9dd717e115d", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] count] [3]]]}, swap #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swap] [2 3 1]]]}, assoc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5cff9bad-ebe3-43a2-b664-a08a42471e54", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :alist :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] [a x] assoc] [[[a x] [c d]]]] [[[[a b] [c d]] [e x] assoc] [[[a b] [c d] [e x]]]]]}, describe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "447bdae6-7fb7-4f8b-89f8-4e07962a97ee", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :others], :forms [:kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17814]}, discard #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 discard] [2 1]] [[1 2 3 [a b c] discard] [3 2 1]]]}, rotate #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662]}, addmethod #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "00f6457b-0493-4dba-a0ca-c2edc6297dbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :word :others], :forms [:kcats.core/pair :kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone describe] dip pack [rotate pack] infra swap inscribe]}, number? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}}


#+begin_src clojure

#+end_src
** Methods
#+begin_src clojure
(swap! core-words merge
       {'pushcond {::spec (stack-spec :condition ::pair
                                      :conditions ::association-list)
                   ::definition '[wrap swap join]}
        'addmethod {::spec (stack-spec :condition ::pair
                                       :word ::word)
                    ::definition '[[clone describe] dip ;; get definition of word beneath
                                        ; and keep an extra copy for later inscribe
                                   pack ;; new condition onto end of definition
                                   [rotate ;; new condition to 1st
                                           ;; position - TODO: note this
                                           ;; could fail if the def is
                                           ;; more than just an alist
                                           ;; and 'cond'.
                                    pack] ;; new condition onto end of conditions
                                   infra 
                                   swap inscribe ;; redefine word
                                   ]}})
#+end_src

#+RESULTS:
: {ends-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, every? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fb4eaf08-db5b-4cf5-a6fc-e24a70f8ee57", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17135]}, unwrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6bd288a7-c1af-4512-8b26-32ef5275e06f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1] unwrap] [1]]]}, first #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "85037120-01a7-4839-a1fc-dd090bf733ff", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :other], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, branch #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7cdfd7e-7cb8-4178-a3b5-538ec8e0daa2", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]}, = #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "ad872f98-ee7d-4370-9fc2-3cb2b3eb4217", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :y :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]]]}, step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e8ee9da1-e285-4308-a92c-93aeefb418f6", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 [2 3 4] [*] step] [24]]]}, dec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c3a27745-d108-437e-9f68-3a4beb863f35", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, < #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "8fd2ccde-ee38-4a8e-9db2-cf3ead71fb9c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :aggregate :others], :forms [:kcats.core/item :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]]]}, ifte #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "4855918d-2e2b-4c97-8e7a-caa8d1f97a38", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] dipd branch], :examples [[[5 [clone 5 =] [3 *] [4 +] ifte] [15]] [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}, infra #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5827446c-7319-4fe1-86ea-841fdf926e54", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :list :others], :forms [:kcats.core/program :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Accept a quoted program and a list on the stack and run the program\n                    with the list as its stack.  Does not affect the rest of the stack.", :definition [swap swaack unpack dip swaack], :examples [[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}, some? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "31fd028a-f9e0-4aa3-839f-0fbd7c91e54e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, join #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f8ef9220-f7aa-42f8-b4b2-e7b710163293", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:agg1 :agg2 :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}, range #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/integer :kcats.core/integer {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "515ccbcd-72da-4ee2-a142-abf5909a5ad8", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:from :to :others], :forms [:kcats.core/integer :kcats.core/integer (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 5 range] [[1 2 3 4]]]]}, in #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1698e72f-98eb-498d-b538-7f87fd4da3f5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, pos? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, sequential? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, starts-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, neg? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, <= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pushcond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "db0fde7f-2050-4a84-9870-25e915a174f9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :conditions :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [wrap swap join]}, intersection #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "36fd7058-805b-465d-a5e6-bf41854ffb51", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate-x :aggregate-y :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, * #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, min #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, wrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "64efde6f-368a-460d-9406-22d9ade9e2da", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 wrap] [[1]]]]}, swaack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7c493b9-b4a0-4855-9f44-0df8db0d47c0", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:list :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Swaps the list on top of the stack and the rest of the stack", :fn #function[kcats.core/fn--17129], :examples [[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}, empty? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, quot #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, string? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, lookup #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/association-list], :ret {}, :ks [:kcats.core/key :kcats.core/map], :forms [:kcats.core/item :kcats.core/association-list], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] a lookup] [b]] [[[[a b] [c d]] e lookup] [[]]]]}, > #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, int? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, even? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, dip #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fac05d2c-8f18-4649-b8ae-bc9fecd6a12e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 8 [inc] dip] [8 2]]]}, mod #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, primrec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "56fa958c-8c14-4d1e-a390-3901adc5bbce", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec1 :exit :data :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] swap join [[discard] swap join] dip [[clone zero?]] dipd [[clone dec]] dip recur], :examples [[[5 [1] [*] primrec] [120]]]}, - #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, unpack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1224e1e1-cba5-488e-b672-107f1e9e056b", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}, zero? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inscribe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5af816be-4dcc-4f80-a725-ff6b955d9610", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :definition :others], :forms [:kcats.core/word :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #'kcats.core/inscribe, :examples [[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}, rem #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, execute #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "620caaef-fed0-4c17-8b2f-5d05ff74cf9d", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :others], :forms [:kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]}, recur #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "028bd342-a954-4177-94c3-db1c59258ca1", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec2 :rec1 :true-branch :false-branch :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}, type #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "b835728c-2dc3-4c07-8070-972afe250053", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first first] [[type] unwrap lookup] ifte], :examples [[[[[foo 1]] type] [foo]] [[[[type url] [value "http://foo.com"]] type] [url]]]}, dipd #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9da6e2cf-e59f-42a8-91d0-d0aded19104c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item1 :item2 :others], :forms [:kcats.core/aggregate :kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 [inc] dipd] [3 2 2]]]}, true? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, / #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, >= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, loop #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6bf55a1b-f0c6-4eb3-83b9-61f5a4fd7cb3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :flag :others], :forms [:kcats.core/program :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[10 true [-2 * clone 50 <] loop] [160]]]}, cond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a6e02a6e-4f26-4231-89cd-208f88d062c8", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:test-expr-pairs :other], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17252]}, odd? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "97fe389c-868b-4d96-8951-d38ffb96f006", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, + #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, false? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, clone #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 clone] [3 3 2 1]]]}, max #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, count #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "63e36cd2-9ef0-4120-a655-aad823127483", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] count] [3]]]}, swap #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swap] [2 3 1]]]}, assoc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9f28566d-5d9c-4748-89f3-b7a2f3d334ba", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :alist :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] [a x] assoc] [[[a x] [c d]]]] [[[[a b] [c d]] [e x] assoc] [[[a b] [c d] [e x]]]]]}, describe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [#object[clojure.spec.alpha$tuple_impl$reify__2098 0x5f07115f "clojure.spec.alpha$tuple_impl$reify__2098@5f07115f"] {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5fd5f8b3-7111-4f23-9bff-be83c93d75aa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :others], :forms [(clojure.spec.alpha/tuple :kcats.core/word) (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17156]}, discard #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 discard] [2 1]] [[1 2 3 [a b c] discard] [3 2 1]]]}, rotate #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662]}, number? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}}

** Nested Environments
*** Basics
Kcats environments are just data. We can manipulate an environment
within another environment to achieve various features:

+ A debugger (each evaluation step checks to see whether it should
  stop at a breakpoint etc)
+ Spawning copies of the same environment so that we can do things like
  map/filter/some etc (that require us to restore an environment to a
  previous state, and do another calculation with it)
*** Implementation
First let's spec what a nested environment looks like
#+begin_src clojure 
  (declare env->clj)

  (expound/def ::nested-environment
    (spec/and ::association-list #(->> % env->clj (spec/valid? ::environment))))
#+end_src

#+RESULTS:
: :kcats.core/nested-environment

We'll need to move back and forth between clojure's idea of an
environment and the equivalent representation in kcats.

#+begin_src clojure
  (defn env->clj
    "Convert an env from kcats format to clj"
    [e]
    (let [ec (into {} e)]
      {::stack (-> ec (get 'stack) list* (or '()))
       ::dictionary (merge builtin-words (into {}
                                               (for [[k v] (get ec 'dictionary)]
                                                 [k {::definition v}])))
       ::expression (or (list* (get ec 'expression)) '())}))

  (defn env->k
    "Convert an env from clj format to kcats"
    [e]
    [['stack (-> e ::stack vec)]
     ['dictionary (into {}
                        (for [[k {::keys [definition]}] (::dictionary e)
                              :when definition]
                          [k definition]))]
     ['expression (-> e ::expression vec)]])
#+end_src

#+RESULTS:
: #'kcats.core/->env

Now we can define an axiom word that steps through a nested
environment's execution.

#+begin_src clojure
(swap! core-words merge
       {'eval-step {::spec (stack-spec :environment ::environment)
                    ::fn (f-stack 1 (comp env->k eval-step env->clj))}})
#+end_src

#+RESULTS:
: {ends-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, every? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fb4eaf08-db5b-4cf5-a6fc-e24a70f8ee57", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17135]}, unwrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6bd288a7-c1af-4512-8b26-32ef5275e06f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1] unwrap] [1]]]}, first #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "85037120-01a7-4839-a1fc-dd090bf733ff", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :other], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, branch #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7cdfd7e-7cb8-4178-a3b5-538ec8e0daa2", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]}, = #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "ad872f98-ee7d-4370-9fc2-3cb2b3eb4217", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :y :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]]]}, step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e8ee9da1-e285-4308-a92c-93aeefb418f6", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 [2 3 4] [*] step] [24]]]}, dec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c3a27745-d108-437e-9f68-3a4beb863f35", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, < #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "8fd2ccde-ee38-4a8e-9db2-cf3ead71fb9c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :aggregate :others], :forms [:kcats.core/item :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]]]}, ifte #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "4855918d-2e2b-4c97-8e7a-caa8d1f97a38", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] dipd branch], :examples [[[5 [clone 5 =] [3 *] [4 +] ifte] [15]] [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}, infra #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5827446c-7319-4fe1-86ea-841fdf926e54", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :list :others], :forms [:kcats.core/program :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Accept a quoted program and a list on the stack and run the program\n                    with the list as its stack.  Does not affect the rest of the stack.", :definition [swap swaack unpack dip swaack], :examples [[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}, some? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "31fd028a-f9e0-4aa3-839f-0fbd7c91e54e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, join #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f8ef9220-f7aa-42f8-b4b2-e7b710163293", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:agg1 :agg2 :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}, range #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/integer :kcats.core/integer {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "515ccbcd-72da-4ee2-a142-abf5909a5ad8", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:from :to :others], :forms [:kcats.core/integer :kcats.core/integer (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 5 range] [[1 2 3 4]]]]}, in #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1698e72f-98eb-498d-b538-7f87fd4da3f5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, pos? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, sequential? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, starts-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, neg? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, <= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pushcond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "db0fde7f-2050-4a84-9870-25e915a174f9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :conditions :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [wrap swap join]}, intersection #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "36fd7058-805b-465d-a5e6-bf41854ffb51", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate-x :aggregate-y :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, * #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, min #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, wrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "64efde6f-368a-460d-9406-22d9ade9e2da", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 wrap] [[1]]]]}, swaack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7c493b9-b4a0-4855-9f44-0df8db0d47c0", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:list :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Swaps the list on top of the stack and the rest of the stack", :fn #function[kcats.core/fn--17129], :examples [[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}, empty? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, quot #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, string? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, lookup #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/association-list], :ret {}, :ks [:kcats.core/key :kcats.core/map], :forms [:kcats.core/item :kcats.core/association-list], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] a lookup] [b]] [[[[a b] [c d]] e lookup] [[]]]]}, > #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, int? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, eval-step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/environment {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bd4722b6-6957-4b5a-a7ec-73e5e86671bd", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:environment :others], :forms [:kcats.core/environment (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, even? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, dip #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "fac05d2c-8f18-4649-b8ae-bc9fecd6a12e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 8 [inc] dip] [8 2]]]}, mod #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, primrec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "56fa958c-8c14-4d1e-a390-3901adc5bbce", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec1 :exit :data :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] swap join [[discard] swap join] dip [[clone zero?]] dipd [[clone dec]] dip recur], :examples [[[5 [1] [*] primrec] [120]]]}, - #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, unpack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1224e1e1-cba5-488e-b672-107f1e9e056b", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}, zero? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inscribe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5af816be-4dcc-4f80-a725-ff6b955d9610", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :definition :others], :forms [:kcats.core/word :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #'kcats.core/inscribe, :examples [[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}, rem #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, execute #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "620caaef-fed0-4c17-8b2f-5d05ff74cf9d", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :others], :forms [:kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]}, recur #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "028bd342-a954-4177-94c3-db1c59258ca1", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec2 :rec1 :true-branch :false-branch :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}, type #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "b835728c-2dc3-4c07-8070-972afe250053", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first first] [[type] unwrap lookup] ifte], :examples [[[[[foo 1]] type] [foo]] [[[[type url] [value "http://foo.com"]] type] [url]]]}, dipd #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9da6e2cf-e59f-42a8-91d0-d0aded19104c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item1 :item2 :others], :forms [:kcats.core/aggregate :kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 [inc] dipd] [3 2 2]]]}, true? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, / #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, >= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, loop #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "6bf55a1b-f0c6-4eb3-83b9-61f5a4fd7cb3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :flag :others], :forms [:kcats.core/program :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[10 true [-2 * clone 50 <] loop] [160]]]}, cond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a6e02a6e-4f26-4231-89cd-208f88d062c8", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:test-expr-pairs :other], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17252]}, odd? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "97fe389c-868b-4d96-8951-d38ffb96f006", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, + #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, false? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, clone #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 clone] [3 3 2 1]]]}, max #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, count #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "63e36cd2-9ef0-4120-a655-aad823127483", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] count] [3]]]}, swap #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swap] [2 3 1]]]}, assoc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "9f28566d-5d9c-4748-89f3-b7a2f3d334ba", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :alist :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] [a x] assoc] [[[a x] [c d]]]] [[[[a b] [c d]] [e x] assoc] [[[a b] [c d] [e x]]]]]}, describe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [#object[clojure.spec.alpha$tuple_impl$reify__2098 0x5f07115f "clojure.spec.alpha$tuple_impl$reify__2098@5f07115f"] {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5fd5f8b3-7111-4f23-9bff-be83c93d75aa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :others], :forms [(clojure.spec.alpha/tuple :kcats.core/word) (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17156]}, discard #:kcats.core{:spec :kcats.core/stack-min-depth-1, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 discard] [2 1]] [[1 2 3 [a b c] discard] [3 2 1]]]}, rotate #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662]}, number? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}}

** Pipes
*** Basics
Pipes are a coordination construct - a way to get values from here to
there, when "there" is further away than a simple function call. In
that sense it "breaks" functional programming by introducing state,
but quite often real programs need to deal with state. That state
could just be something introduced by, and consumed by, the local
environment, or it could be received from another machine thousands of
miles away.

The interface is simple enough - we just need to be able to put values
into a pipe at one end, and take them off at the other. It's also
handy to know whether there's anything in the pipe or not, and whether
the pipe is "full" (nothing more will fit until something at the other
end is removed).

#+begin_src clojure :tangle src/kcats/pipe.clj
(ns kcats.pipe
  (:require [kcats.core :as core]
            [clojure.spec.alpha :as spec]
            [expound.alpha :as expound])
  (:refer-clojure :exclude [take empty?]))

(defprotocol Pipe
  (put [pipe value] "Puts a value into the pipe, blocks if the pipe is full, returns value on success")
  (take [pipe] "Takes a value from the pipe, blocks if pipe is empty, returns the value")
  (empty? [pipe] "Returns whether the pipe has a value ready to take")
  (full? [pipe] "Returns whether the pipe has space to put a new value"))
#+end_src

#+RESULTS:
: nilPipe

Now we can make some higher level functions that will actually be what
kcats primitives will be defined in terms of.
#+begin_src clojure :tangle src/kcats/pipe.clj
  (def default-pause 10) ;; pause this long when polling empty/full

  (defn take!
    "Takes from the given pipe and returns a value, blocks if empty."
    [pipe]
    (loop []
      (if (empty? pipe)
        (do (Thread/sleep default-pause) (recur))
        (take pipe))))

  (defn put!
    "Puts a value into the given pipe and returns it, blocks if full."
    [pipe value]
    (loop []
      (if (full? pipe)
        (do (Thread/sleep default-pause) (recur))
        (do (put pipe value) value))))

  (defn select
    "Takes a coll of pipes. Whichever one is non-empty first, return the
    pipe and the value that was in it."
    [pipes]
    (loop [[this-pipe & remaining-pipes] pipes]
      (if this-pipe
        (if (empty? this-pipe)
          (recur remaining-pipes)
          ;; found it, return the pipe and value as a tuple
          [this-pipe (take! this-pipe)])
        ;; everything empty, start over
        (do (Thread/sleep default-pause)
            (recur pipes)))))
#+end_src

#+RESULTS:
: #'kcats.pipe/default-pause#'kcats.pipe/take!#'kcats.pipe/put!#'kcats.pipe/select

Now we can define a few different kinds of pipes, starting with simple
"local" types.
*** Atoms
This is a pipe that when you take, always returns the last value
put. It's never full, whatever you put just overwrites what was there
before. It has to be initialized with a value, therefore it's also
never empty. It's functionally equivalent to a clojure atom and is
implemented in terms of one.
#+begin_src clojure :tangle src/kcats/pipe.clj
  (defrecord Atom [a]
      Pipe
    (put [this value] (reset! a value))
    (take [this] @a)
    (empty? [this] false)
    (full? [this] false))

  (defn ->atom
    "Creates a new atom pipe with initial value v"
    [v]
    (->Atom (atom v)))
#+end_src

#+RESULTS:
: kcats.pipe.Atom#'kcats.pipe/->atom

*** Timeout
This is a pipe that when you take, it will block for a predefined
period of time (decided when the pipe is created), and then return the
boolean value =true=. It is always full (cannot accept puts - it will
just block, doesn't make sense to do it).

The purpose of this kind of pipe is to use with =select= - where you
have a set of pipes and you want to take from whichever one is
non-empty first. You can include a timeout pipe in there to guarantee
that at least one of them will return something eventually.

#+begin_src clojure :tangle src/kcats/pipe.clj
  (defrecord Timeout [until-timestamp]
      Pipe
    (put [this value])
    (take [this] true)
    (empty? [this] (< (System/currentTimeMillis) until-timestamp))
    (full? [this] true))

  (defn ->timeout
    "Creates a new timeout pipe that waits t milliseconds and then
    returns a single value (true) from the pipe"
    [t]
    (->Timeout (+ (System/currentTimeMillis) t)))
#+end_src

#+RESULTS:
: kcats.pipe.Timeout#'kcats.pipe/->timeout

*** Words
#+begin_src clojure :tangle src/kcats/pipe.clj
(in-ns 'kcats.pipe)

(expound/def ::pipe (partial satisfies? Pipe))

(swap! core/core-words merge
       {'atom {::core/spec (core/stack-spec :value ::core/item)
               ::core/fn (core/stack-effect [v] [(->atom v)])}
        'pipe? {::core/spec (core/stack-spec :item ::core/item)
                ::core/fn (core/stack-effect [v] [(satisfies? Pipe v)])}
        'take {::core/spec (core/stack-spec :pipe ::pipe)
               ::core/fn (core/stack-effect [p] [(take p) p])}
        'put {::core/spec (core/stack-spec :value ::core/item
                                           :pipe ::pipe)
              ::core/fn (core/stack-effect [v p] [(doto p (put v))])}
        'get {::core/spec (core/stack-spec :key ::core/item
                                      :from ::core/item)
              ::core/definition '[[[[clone type ]]]]}})

#+end_src

#+RESULTS:
: #namespace[kcats.pipe]:kcats.pipe/pipe{ends-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, every? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e03d351b-8c01-4507-a64e-c247e2214eb9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--18847]}, unwrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c1f3dc6f-cd8e-4388-8726-3a490f2be47c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1] unwrap] [1]]]}, first #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e3ad18ae-cbb8-43c7-b0a2-bae01c820986", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, put #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.pipe/pipe {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "ce31793c-a41e-4bd0-bba4-4250321b289d", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:value :pipe :others], :forms [:kcats.core/item :kcats.pipe/pipe (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, atom #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "1e0f852d-a795-4306-a8a8-2987652498af", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:value :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, branch #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c7140a22-37a4-45fc-86e4-4410b4d70001", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]}, = #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "98812512-e2d1-4a80-ab5b-421393b8a175", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :y :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 1 =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] false =] [false]]]}, step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c0bc51ec-7b87-43a5-a586-782a6f184baa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :aggregate :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 [2 3 4] [*] step] [24]]]}, take #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.pipe/pipe {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e7bd448c-5bc3-4f25-a84e-5b58e9a8d33c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:pipe :others], :forms [:kcats.pipe/pipe (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, dec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "453ed3ef-2db4-45fd-a597-298975e2e907", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, < #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "72246d2e-0dda-4002-a873-58064b36ae22", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :aggregate :others], :forms [:kcats.core/item :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[] 1 pack] [[1]]] [[[1 2 3] 4 pack] [[1 2 3 4]]]]}, ifte #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "0692e1ec-888e-4bfb-b244-51a0764e4f4f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:false-branch :true-branch :condition :others], :forms [:kcats.core/aggregate :kcats.core/aggregate :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] dipd branch], :examples [[[5 [clone 5 =] [3 *] [4 +] ifte] [15]] [[6 [clone 5 =] [3 *] [4 +] ifte] [10]]]}, infra #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "7e8ebaae-d3a6-4b9f-a32c-5abda70db689", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :list :others], :forms [:kcats.core/program :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Accept a quoted program and a list on the stack and run the program\n                    with the list as its stack.  Does not affect the rest of the stack.", :definition [swap swaack unpack dip swaack], :examples [[[1 2 3 [4 5 6] [* +] infra] [[26] 3 2 1]]]}, some? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e448f0c7-c0bf-4791-b3b8-6aa703b63050", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, join #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "142035c7-6024-41a1-9a23-b0117a102bcc", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:agg1 :agg2 :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]]}, range #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/integer :kcats.core/integer {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bc18472a-f524-4ded-87ca-b9788cb60bb7", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:from :to :others], :forms [:kcats.core/integer :kcats.core/integer (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[1 5 range] [[1 2 3 4]]]]}, in #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2462fcc5-e670-4f7c-8e46-21e6f367c5be", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, pos? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, sequential? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, starts-with? #:kcats.core{:spec :kcats.core/stack-min-depth-2, :fn #function[clojure.core/partial/fn--5824]}, neg? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, pipe? #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "de23f25b-9d52-4258-b91c-4e10dd648b19", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662]}, <= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, pushcond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "54cf99a1-8b65-47c1-8d3f-ba37b6a5844b", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :conditions :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [wrap swap join]}, intersection #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "298b8203-3408-4078-a731-aa21e79eb2c5", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate-x :aggregate-y :others], :forms [:kcats.core/aggregate :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, * #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, min #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, wrap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "8e654cea-5342-4876-9d41-a27c85612076", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 wrap] [[1]]]]}, get #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "3921be46-3977-4c70-85fb-37596c36b63c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:key :from :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[[[clone type]]]]}, swaack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2d262529-290f-4e48-89e3-dad9e37ff8f2", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:list :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :doc "Swaps the list on top of the stack and the rest of the stack", :fn #function[kcats.core/fn--18841], :examples [[[1 2 3 [4 5 6] swaack] [[3 2 1] 4 5 6]]]}, empty? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, quot #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, string? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, lookup #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/association-list], :ret {}, :ks [:kcats.core/key :kcats.core/map], :forms [:kcats.core/item :kcats.core/association-list], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] a lookup] [b]] [[[[a b] [c d]] e lookup] [[]]]]}, second #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a9981ec9-1de1-41af-a210-5b82bed088d3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, > #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, int? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, eval-step #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/environment {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "bd4722b6-6957-4b5a-a7ec-73e5e86671bd", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:environment :others], :forms [:kcats.core/environment (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, even? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, dip #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "d2d2d1a0-2803-4d96-baa0-4d586a2ea201", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item :others], :forms [:kcats.core/aggregate :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 8 [inc] dip] [8 2]]]}, swapd #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swapd] [3 1 2]]]}, mod #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, primrec #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a7bce3e3-5ad9-421b-8e34-1b6141b946f9", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec1 :exit :data :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[execute] swap join [[discard] swap join] dip [[clone zero?]] dipd [[clone dec]] dip recur], :examples [[[5 [1] [*] primrec] [120]]]}, - #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, value #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "2f771ed4-a3aa-470d-b752-95577a069bbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first second] [[value] unwrap lookup] ifte], :examples [[[[[foo 1]] value] [1]] [[[[type url] [value "http://foo.com"]] value] ["http://foo.com"]]]}, unpack #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "dac7229a-7178-4e34-91af-37f4d89704fa", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] unpack] ["a" ["b" "c"]]]]}, zero? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inscribe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word :kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "af1c6831-4054-4c6d-9691-42ff9b9364b3", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :definition :others], :forms [:kcats.core/word :kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #'kcats.core/inscribe, :examples [[[[3 +] [add3] unwrap inscribe 5 add3] [8]]]}, rem #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, execute #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "453c02fc-6371-4513-906c-07ed877cd127", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :others], :forms [:kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]}, recur #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "f56cb266-9142-4590-9e70-86d2601abf6e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:rec2 :rec1 :true-branch :false-branch :others], :forms [:kcats.core/program :kcats.core/program :kcats.core/program :kcats.core/program (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[3 [clone 1 <=] [] [clone dec] [execute *] recur] [6]]]}, type #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "0ea94369-e530-4d81-81fd-3c33e4ee4c6a", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:alist :others], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone count 1 =] [first first] [[type] unwrap lookup] ifte], :examples [[[[[foo 1]] type] [foo]] [[[[type url] [value "http://foo.com"]] type] [url]]]}, dipd #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate :kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "81d937a6-9423-4a09-b5ca-6220a1df968c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :item1 :item2 :others], :forms [:kcats.core/aggregate :kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 [inc] dipd] [3 2 2]]]}, true? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, / #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, >= #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, loop #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/program :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c9f4e610-e2c5-46af-bb65-eb921e065945", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:program :flag :others], :forms [:kcats.core/program :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[10 true [-2 * clone 50 <] loop] [160]]]}, cond #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "c30f4967-b255-4902-af58-51fda516344c", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:test-expr-pairs :other], :forms [:kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--17889]}, odd? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, inc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/number {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "e2ea0cd3-de79-4eb4-a538-a810aa67779f", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:x :others], :forms [:kcats.core/number (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824]}, + #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, false? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}, clone #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "21d1a517-0aba-4fcb-94e9-3e01949344db", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 clone] [3 3 2 1]]]}, max #:kcats.core{:spec :kcats.core/binary-arithmetic, :fn #function[clojure.core/partial/fn--5824]}, count #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/aggregate {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "d26293a6-e1a4-4a12-8d7b-831553246e74", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:aggregate :others], :forms [:kcats.core/aggregate (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[["a" "b" "c"] count] [3]]]}, swap #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item :kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "df4d6820-3838-46c7-a0cd-409ab0a4d53e", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item1 :item2 :others], :forms [:kcats.core/item :kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 swap] [2 3 1]]]}, assoc #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/association-list {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "5cff9bad-ebe3-43a2-b664-a08a42471e54", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :alist :others], :forms [:kcats.core/pair :kcats.core/association-list (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[clojure.core/partial/fn--5824], :examples [[[[[a b] [c d]] [a x] assoc] [[[a x] [c d]]]] [[[[a b] [c d]] [e x] assoc] [[[a b] [c d] [e x]]]]]}, describe #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a0b2b35a-9ad8-431f-9498-cdc87c1184ca", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:word :others], :forms [:kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/fn--18870]}, discard #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/item {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "a3afbf0b-b0a3-4702-89cf-a3261cf0052a", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:item :others], :forms [:kcats.core/item (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :fn #function[kcats.core/env-effect/fn--13662], :examples [[[1 2 3 discard] [2 1]] [[1 2 3 [a b c] discard] [3 2 1]]]}, rotate #:kcats.core{:spec :kcats.core/stack-min-depth-3, :fn #function[kcats.core/env-effect/fn--13662]}, addmethod #:kcats.core{:spec {:clojure.spec.alpha/op :clojure.spec.alpha/pcat, :ps [:kcats.core/pair :kcats.core/word {:clojure.spec.alpha/op :clojure.spec.alpha/rep, :p2 :kcats.core/item, :splice false, :forms :kcats.core/item, :id #uuid "00f6457b-0493-4dba-a0ca-c2edc6297dbf", :p1 :kcats.core/item, :ret []}], :ret {}, :ks [:condition :word :others], :forms [:kcats.core/pair :kcats.core/word (clojure.spec.alpha/* :kcats.core/item)], :rep+ nil}, :definition [[clone describe] dip pack [rotate pack] infra swap inscribe]}, number? #:kcats.core{:spec :kcats.core/predicate, :fn #function[clojure.core/partial/fn--5824]}}

*** Notes
core.async has an out-of-band close message. Do we need that? Seems
handy but also adds complexity as it becomes an error condition trying
to put/take into a closed pipe, that would then need to be handled.

Seems acceptable to me that pipes are just there and if you want to
tell whoever's at the other end that you're done sending, just send
something that tells them that.

It might be nice for the receiver to be able to let the sender know
he's "hanging up", but I think that function is better handled at a
higher level of abstraction (something built on top of bidirectional
pipes, which is just two pipes with the sender and receiver swapped)
** Multimethods
These are words that have different behavior depending on what is on
the stack. 
#+BEGIN_SRC clojure

#+END_SRC
* Notes
** Instruction set
It might be prudent to define some low level words, and then define
the higher level words in terms of those words. Essentially trading
some performance for portability. Here's a stab at what some of the
low level words would be. We could refer to positions on the stack and
expression with an integer (positive = on stack, negative = on
expression)

- shift* items from the expression to the stack, or vice versa (neg),
  int argument. Oops the problem here is if you shift stuff from
  stack->expr whatever you shifted will get eval'd next, instead of
  what you probably wanted

- move* better than swap as you can specify what you're moving AND how
  far. This has the problem of needing to know how long the section of
  program is that you need to move things past. I'm not sure this is
  useful either, as moving things into the expression is not very useful
  
- exchange* items at the given locations (eg -1 1 swap would swap the
  top of the stack and top of the expression)

- swap* shorthand for 1 2 exchange* (swap the top two items)

- conj* the item on top of the stack into the agg just below it

- concat* the top n (or 2?) items (lists)

- execute* unwrap agg on ToS, move it into expr (to be eval'd)

- discard* get rid of items on the stack

- clone* duplicate items on the stack

- cleave* the env into two, execute the program on ToS on one of
  them, put result on other. drop the mutated env. -  see below

- booleans and* or* not*

- =* 

- branch*

- unwrap* - unwraps the aggregate at position n

- inscribe*

- describe* 

Using this we can define =dip= like this (nope, does not work due to
neg shift being worthless)

#+BEGIN_EXAMPLE
  1 2 swap* -1 shift* conj*

  3 1 2 [* +] . dip
  3 1 [* +] 2 . -1 shift* conj*
  3 1 [* +] . 2 conj*
  3 1 [* + 2]  
#+END_EXAMPLE


ok how about this

#+BEGIN_EXAMPLE
  swap* conj* execute*

  3 4 2 5 [* +] . dip
  3 4 2 5 [* +] . swap* conj* execute*
  3 4 2 [* +] 5 . conj* execute*
  3 4 2 [* + 5] . execute*
  3 4 2 . * + 5
  3 8 . + 5
  11 . 5
  11 5
#+END_EXAMPLE

re cleave*, seems like there is some overlapping functionality
between parallelism and preserving the stack for things like
=nullary=. In both cases we're cloning the environment (or part of
it) so that multiple modifications don't conflict with each other.

The only difference is how we join the cloned stacks back together.

With nullary, we clone the env, run the program on the clone, take
the top of the stack and put it back on the original. throw the clone
env away.

With map, we clone the env (one for each item in the list), run the
program in parallel on each env, gather up the top items in each env,
and put it as a list on top of the original stack.

The question is, can we leverage kcats itself to manage the intra-env
computations? Seems like theoretically we could - make a new stack
consisting of the other stacks as list items in the new one. Then you
can process that arbitrarily and whatever remains can be used. Seems
like maybe channels should be a dependency here, since that would
easily pipe the right value back to the right env.

So, what's needed here is another combinator (like genrec etc) that
takes two programs:

+ one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

+ one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the =pop= would drop the =7= off the stack, so we're
testing that it gets resurrected for each item in the list =[1 2 3]=.

Let's define =f= as something that would take the input stack and leave

7 [[1 swap pop inc] [2 swap pop inc] [3 swap pop inc]] (concat'ing the
mapping function program onto each piece of data)

Then that list-of-lists is what's used to make new environments (in
the implementation of cleave*), each top-level item is a program to
run.

Then you'd have 3 environments, after the program had run, stacks look like this:

2
3
4

Then we'd need to specify how map gathers up the top items from this
stack and adds them to the original:

1 3 exchange pop pop

#+BEGIN_EXAMPLE
So, what's needed here is another combinator (like genrec etc) that
takes two programs:

,* one that takes (a clone of) the current stack
and leaves on top a list of lists (where each item will represent a
stack in a new env).

,* one that takes a list of items that were on top of the various
stacks, and turns them back into items to be put back on the original
stack. (in the case of map, noop).

Let's try an example

7 [1 2 3] [swap pop inc] map

In this example, the pop

map

7 [1 2 3] [inc] . map

env1
7 1 . inc
7 2

env2
7 2 . inc
7 3

env3
7 3 . inc
7 4


,* distribute items f(stack) -> new env(s) expression (in the case of map, enstacken or whatever takes the agg on ToS as the items to be added)
,* run all the envs (one per item in the list below ToS) 
,* reduce all the ToSs (in the case of map we're already done)

Let's try nullary

2 3 [+] nullary

,* enstacken
,* run all (one)
,* conj o
#+END_EXAMPLE
** Dispatch
*** Basics
A multimethod is a function broken into two parts:

+ a dispatch (where the arguments are examined to figure out where to
  send them)
+ method call (based on the dispatch results, pass the same args to
  some other function)

Concatenative languages make composing functions easy so it's possible
all the language needs is a convenient way to create dispatches.

#+BEGIN_EXAMPLE
  [from where] [thing] get => the thing

  network {url "http://foo.com"} get => (a pipe to read data from)
  network {url "http://foo.com"} get bytes => (byte array)

  [foo bar baz quux] mapping foo get => bar
#+END_EXAMPLE

Defining a multifn

#+BEGIN_EXAMPLE
  ;; [program to prepend to method] multi word inscribe
  [type get] multi foo inscribe

  [url [sdf asdf]] foo addmethod
#+END_EXAMPLE

There are a few ways to approach this
*** Approaches
**** Clojure-like 
Tried and true, but requires the implementation of a type hierarchy to
do dispatch by type properly

**** Predicate based
This is where the implementation of multimethods is just =cond=. The
conditions are data (just like everything else) and to add methods,
you just insert a condition. 

A series of predicate/method pairs- Iterate over the pairs, and the
first one where the pred returns true, execute the
method. Performance-wise, it could be slower if there's lots of
methods defined. However there's no dispatch function to execute so in
some cases it could be faster. (Note also, that because there's a
stack here, we could always have a dispatch value available too)
Ordering of the methods would become important. For example, if you
had a predicate like =object?= (that is basically always true) you'd
have to make sure that's last in the list.

There's another performance issue - sometimes predicates are expensive
to calculate repeatedly. Let's say you have a list of a billion
integers, and you have a method that is dispatched to with =[int?
every?]=. There's a couple strategies to combat having to examine
every item in that list, especially multiple times:

+ Cache the result as metadata on the value. Predicates could, instead
  of popping the value off the stack and leaving a boolean, leave the
  value but with an added metadata, of which predicate was already run
  on it, and the result. Predicates can short-circuit by seeing if the
  metadata is there before actually running.
+ Allow anyone to populate that metadata. If you know a huge list is
  already going to return true on some predicate, you can just add the
  meta at creation time. Of course this is a foot gun so you have to
  be careful and understand these are assertions that can be wrong.

Generally I am not going to worry about performance yet but I want it
to be addressable with backward compatible additions to the language.

#+begin_example
  ;; basic multimethod pattern
  [clone [[pred1...] [method1]
          [pred2...] [method2]
          ...] 
#+end_example
#+BEGIN_EXAMPLE
  ;; old example code 

  [[odd?] execute [[true [inc]] [false []]] swap get execute]

  ;; so the pattern here is [dispatch-fn execute methods swap get execute]

  ;; if we want to add a method, we can just insert it with add

  ;; we can create an empty multi from a dispatch:

  [[odd?] list [execute [] swap get execute] concat ;; or some such

  ;; then to update an already inscribed method
  [[foo] dup describe ... (updating) ... 

  ;; another way to do this is to just run predicates until one matches,
     that might do away with types entirely and just leave predicates.

  [[int? [+]] [string? [concat]] loop-and-execute ;; loop thru these and
  execute the first program where the pred matches.

  ;; for example
  5 6 [[[int?] [+]] [[string?] [join]] loop-and-execute
  11

  "hi" " there" [[[int?] [+]] [[string?] [join]] loop-and-execute
  "hi there"

  ;; should the predicates leave the value on the stack?
  5 odd?
  5 true
  ;; or drop it?
  5 odd?
  true

  ;; generally we probably still want to keep values that we're running
  ;; a pred on, but maybe best to explicitly clone
  5 clone odd?
  5 true

  ;; or should we actually reset the stack like with map? the benefit is
     that preds don't have to be tidy. but really i can't think of any
     reason they wouldn't be. The whole point of them is that they only
     need one value as input.
#+END_EXAMPLE


** Pipes
This is a general coordination construct. A pipe is a one way
communication channel, you put values in at one end, and take them off
at the other. Where the data actually goes (in memory, over network,
to a file, etc) is up to the implementation.

There are a few words that a pipe needs to respond to:
+ put - put a value into the pipe (may block)
+ take - take a value out of the pipe (may block)
+ close - close the input end of the pipe (no more puts)

And then some higher level words that let you do more complex things:
+ choose - given a list of pipes, block until one has a value ready,
  then return [val pipe].
+ copy - given two pipes, the values that emerge from the first will
  also emerge from the 2nd.
+ dump - given a pipe and an aggregate, put all the items of the
  aggregate into the pipe.

Unlike go/coreasync, there are no non-blocking operations, as envs are
equivalent to go blocks, so everything is in a go block.
#+BEGIN_EXAMPLE
  ;; create a pipe 

  
#+END_EXAMPLE

*** Problem
Pipes have non-representable content. For example, a pipe is made from
a clojure Atom, how do we represent that as a pure value? You can
maybe encode the memory reference and pass it around somehow - but you
can't take an atom and send it over the wire to a different
process. That isn't the same atom, it can't dereference some other
process's memory. 

This kind of makes the goal of "everything is a value and
serializable" unattainable, but maybe we can get close enough.

We could get sophisticated and pass an atom over the wire but as it
passes, wrap it in such a way that putting a value into it gets sent
back to its origin. That would be pretty powerful (and possibly
dangerous).
** Hash maps
*** Use a map literal or not?
Do we add a new literal type for maps? ={a 1 b 2}= ?

Or do we just use a list literal and specify that we want to look at
it like a map? =[a 1 b 2] hashmap=?

Data's just data, should it also carry around how it's supposed to be
looked at? A hashmap is just a list with some optimizations (the data
is grouped by hash so that you can find an item in O(1) time - but you
can always construct a hashmap from a list as the list has all the
data).

All data can be represented as lists (possibly nested), eg a graph
=1->2<-3= is =[[1 2] [3 2]]=

Do we just not bother to turn a list into something else until we
reach a word that expects a certain semantic? for example:

=[a 1 b 2] b get= we're clearly using =get= as a hashmap get, not
trying to get a vector item at an index b. (however if you allowed
integer keys, it would become ambiguous - but let's ignore that for
now). So maybe the language impl can see that we intend to use this
list as a map, and create a hashmap under the covers. (note I no
longer think this is necessary esp for smaller maps. elisp just uses
association lists (O(n) lookup) and for small maps it's actually going
to be faster than hashmap lookup. The vast, vast majority is going to
fall into that category. Hashmaps should be available for larger data
but not the default for literals.
*** Hashmap/ case statement equivalence
There's no difference between a hashmap with get, and a case statement
in this language. So maybe we shouldn't bother with hashmap types? We
could just have a program that we pass around and can modify?
 
=[a 1 b 2] b case=
** Types
How do we express types? We're definitely going to want to dispatch
methods based on "type" (whatever that may mean). One approach is to
just treat any map with a =type= field as an object. We'd need some
kind of inheritance functionality to be able to count, say, a =float=
type as a =number= type. However a single =type= may not be expressive
enough. In other languages, a type might be labelled with all the
interfaces or protocols it implements. I'm not sure that's necessary -
to find out if a type has a method implementation, we could possibly
introspect the dictionary and see what methods have a dispatch for
that type. It seems to me that would only be needed for exploratory
purposes (to find out what you can do with a given type), not at
runtime.

#+BEGIN_EXAMPLE
[type get] multi fetch inscribe ;; return bytes
[url [prog to get url]] [fetch] method put ;; uh oh, how do we avoid actually calling fetch here?? needs to be quoted
[[type url] [url "http://google.com"]] fetch
;; or how about a shorthand
[url "http://google/com"] hint fetch ;; where hint converts into a map with 2 values

[file [prog to read file]] [fetch] method put
[file "/tmp/blah.kcats"] hint fetch read eval ;; run a script?
#+END_EXAMPLE

What about generics? How to express "list of int"?

Could we make use of a predicate(s)? eg[ [value 1] [type integer?] ]
*** Discussion
At the lowest level, all values are just a sequence of bits. Machines
might be optimized for certain sizes and operations, but those are
implementation details.

Of course, the problem comes when a program gets a sequence of bits
but doesn't know what it's supposed to do with it. For example the =+=
operator might be intended to do arithmetic addition if the bits are
meant to be numbers, and concatenation if they're meant to be
text. How does it know which one it's got, when they're both just
sequences of bits and there's not necessarily any way to tell?

Type information included along with the value is the "typical"
solution, along with hierarchies etc. At least, there has to be a key
of some kind included that lets the program look up, in some way, what
it's supposed to do with the actual bits given a certain operator or
word.

Let's say there's a key k and the word w. The goal is to have a f(k,
w) that returns a program that manipulates the bits in the desired
way.
*** Predicate based
Since we make use of programs (executable lists) all over the place,
why not for type specification? We could have some native predicates
like =int?= =string?= etc, from which you can build up more complex
type-discerning predicates. Then dispatch is just going thru all the
methods until you hit one that matches.

#+begin_example

#+end_example
** Quoting
Do we need a special quote syntax other than aggregates? I'm thinking
of quoting a single word, (using lisp syntax here) is '(foo)
equivalent to 'foo? Obviously in lisp it isn't. I don't think it will
be in kcats either. For example the equivalent of assoc, it seems
reasonable to use a word as a key, but as soon as you put the word on
the stack, it's executed before we can assoc a value. That's not what
we intended. One way out is to do =[word] unwrap= which would just
leave =word= bare on the stack. Doing this might be rare enough that
it's ok to be that clunky vs making the language more complex to
support =quote=.

There's a couple examples I thought of where we might miss having a
special quote reading function.
 
+ If you want to be able to read a literal list and eval recursively
  so that you get the same access to evaluation in a literal that
  you'd get in other languages. eg in clojure 
  #+begin_src clojure :tangle no
    {:a (+ 1 1)}
    ;;eval's to
    {:a 2}
  #+end_src
  to get this in kcats you'd have to do something like
  #+begin_src fundamental
    [[a [1 1 +]] eval-recurse
  #+end_src
  The problem here is that when we only have one list construct, we
  can't tell where we're supposed to stop recursing and start
  evaluating. So we might end up recursing into =[1 1 +]= instead of
  executing it as a program. Also, the bare word =a= is a problem,
  it's not supposed to be eval'd in this case. But =eval-recurse= has
  no way to know that.

  The quoting functionality only fixes the latter issue. The former is
  tough because even with a way to distinguish, what's on the stack
  it's evaluating in? What's the equivalent of 
  #+begin_src clojure :tangle no
    (let [x 3]
      {:a (inc x)
       :b (* x 5)})
  #+end_src
 
  The reality is there isn't an equivalent because in a stack based
  lang, there are no "locals" with names. There are only stack items.
  
  So how would eval-recurse even work? Something like this?
  #+begin_src fundamental 
    1 [1 [1 +]] eval-recurse
    ;; if it's an atom, eval it, otherwise eval-recurse
    1 [1 [1 +]] [eval-recurse] map
    ;; done
    1 [1 2] 
  #+end_src
  
** Feature dependency tree
*** Types
**** Multimethods
***** Pipes
needs multi's because words like get/put should probably be generic
and have specific methods for pipes.

** Nullary/unary/etc?
Do we need these? If a program knows that the items it consumes will
be needed later, it can =clone= them. And if a program is going to run
another program that it knows will consume items it needs, it can also
=clone= them first.

So at first glance it would seem that nullary et al aren't needed. 

Even if they were needed, these names are too difficult for the target
audience to understand. We need better names and I can't think of any
right now.

** better names?
- dipd :: dipdown 
- ifte :: if
- swaack :: swapstack, switch, pivot
- primrec :: ?
- infra :: inject? 
** Example programs
*** Factorial
**** Recursive definition 
#+begin_src fundamental
 10 
 [fact [[clone 0 =]
        [discard 1]
        [clone dec fact *]
        ifte]]
 inscribe
 fact
#+end_src
**** Recursive with recur
#+begin_src fundamental
 5
 [clone 1 <=]
 []
 [clone dec]
 [execute *]
 recur

 5
 [1]
 [*]
 
#+end_src
**** Using range
#+begin_src fundamental
 10
 1 +
 2 swap
 range unpack
 [*] step
#+end_src
**** Plain loop
#+begin_src fundamental
10 clone 
true [dec clone [*] dip clone 1 >] loop
discard
#+end_src
*** Jensen's Device
 https://rosettacode.org/wiki/Jensen%27s_Device
 #+begin_src fundamental
 100 [0] [[1.0 swap /] dip +] primrec
 [100 0 swap 1 + 1 swap range [1.0 swap / +] step]
 #+end_src
*** Primrec
#+begin_src fundamental
(k {:max-steps 2000
                :foo '[ 5
                 [clone zero?]
                 [discard 1]
                 [clone dec]
                 [execute *]
                 recur]}
               '[5 [1] [*] [execute] swap join ;; add the execute to r2
                 [[discard] swap join] dip ;; add the discard to r1
                 [[clone zero?]] dipd] ;; put the condition on bottom
                )
#+end_src
